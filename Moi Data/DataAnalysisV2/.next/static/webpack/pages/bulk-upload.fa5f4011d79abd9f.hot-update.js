"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/bulk-upload",{

/***/ "./lib/validators.ts":
/*!***************************!*\
  !*** ./lib/validators.ts ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PLATFORM_SCHEMAS: function() { return /* binding */ PLATFORM_SCHEMAS; },\n/* harmony export */   validateCSV: function() { return /* binding */ validateCSV; }\n/* harmony export */ });\n/* harmony import */ var papaparse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! papaparse */ \"./node_modules/papaparse/papaparse.min.js\");\n/* harmony import */ var papaparse__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(papaparse__WEBPACK_IMPORTED_MODULE_0__);\n\nconst PLATFORM_SCHEMAS = {\n    meta: {\n        required: [\n            \"Day\",\n            \"Campaign name\",\n            \"Ad set name\",\n            \"Ad name\",\n            \"Amount spent (INR)\",\n            \"CTR (link click-through rate)\",\n            \"CPM (cost per 1,000 impressions)\"\n        ],\n        dateColumn: \"Day\",\n        requiredDateFormat: \"YYYY-MM-DD\",\n        acceptedFormats: [\n            \"YYYY-MM-DD\"\n        ],\n        orderMatters: false // Meta exports can vary\n    },\n    google: {\n        required: [\n            \"Day\",\n            \"Campaign\",\n            \"Cost\",\n            \"CTR\",\n            \"Avg. CPM\"\n        ],\n        dateColumn: \"Day\",\n        requiredDateFormat: \"YYYY-MM-DD\",\n        acceptedFormats: [\n            \"YYYY-MM-DD\"\n        ],\n        orderMatters: false // Google Ads exports are flexible\n    },\n    shopify: {\n        required: [\n            \"Day\",\n            \"UTM campaign\",\n            \"UTM term\",\n            \"UTM content\",\n            \"Online store visitors\",\n            \"Sessions that completed checkout\"\n        ],\n        dateColumn: \"Day\",\n        requiredDateFormat: \"YYYY-MM-DD\",\n        acceptedFormats: [\n            \"YYYY-MM-DD\"\n        ],\n        orderMatters: false // Shopify reports are flexible\n    }\n};\nasync function validateCSV(platform, file) {\n    return new Promise((resolve)=>{\n        papaparse__WEBPACK_IMPORTED_MODULE_0___default().parse(file, {\n            header: true,\n            preview: 100,\n            complete: (results)=>{\n                const validation = performValidation(platform, results.data, results.meta.fields || []);\n                resolve(validation);\n            },\n            error: (error)=>{\n                resolve({\n                    isValid: false,\n                    hasErrors: true,\n                    hasWarnings: false,\n                    needsCorrection: false,\n                    errors: [\n                        {\n                            type: \"parse_error\",\n                            message: error.message\n                        }\n                    ],\n                    warnings: [],\n                    rowCount: 0,\n                    columnCount: 0,\n                    dateRange: null\n                });\n            }\n        });\n    });\n}\nfunction performValidation(platform, data, headers) {\n    const schema = PLATFORM_SCHEMAS[platform];\n    const errors = [];\n    const warnings = [];\n    // Clean headers (remove BOM, trim whitespace)\n    const cleanHeaders = headers.map((h)=>h.replace(/^\\ufeff/, \"\").trim());\n    // Check for case-sensitive column matching issues\n    const columnMappingIssues = [];\n    for (const requiredCol of schema.required){\n        // Try exact match first\n        const exactMatch = cleanHeaders.find((h)=>h === requiredCol);\n        if (exactMatch) continue;\n        // Try case-insensitive match\n        const caseInsensitiveMatch = cleanHeaders.find((h)=>h.toLowerCase() === requiredCol.toLowerCase());\n        if (caseInsensitiveMatch) {\n            columnMappingIssues.push({\n                required: requiredCol,\n                found: caseInsensitiveMatch,\n                issue: \"case_mismatch\"\n            });\n        } else {\n            // Try fuzzy match (similar names)\n            const fuzzyMatch = cleanHeaders.find((h)=>normalizeColumnName(h) === normalizeColumnName(requiredCol));\n            if (fuzzyMatch) {\n                columnMappingIssues.push({\n                    required: requiredCol,\n                    found: fuzzyMatch,\n                    issue: \"name_variation\"\n                });\n            } else {\n                columnMappingIssues.push({\n                    required: requiredCol,\n                    issue: \"missing\"\n                });\n            }\n        }\n    }\n    // Report column issues\n    const missingColumns = columnMappingIssues.filter((issue)=>issue.issue === \"missing\");\n    const caseMismatchColumns = columnMappingIssues.filter((issue)=>issue.issue === \"case_mismatch\");\n    const nameVariationColumns = columnMappingIssues.filter((issue)=>issue.issue === \"name_variation\");\n    if (missingColumns.length > 0) {\n        errors.push({\n            type: \"missing_columns\",\n            message: \"Missing required columns: \".concat(missingColumns.map((c)=>c.required).join(\", \")),\n            howToFix: \"Add the missing columns to your CSV file with the exact names shown above\",\n            examples: [\n                \"Open your CSV in Excel/Google Sheets\",\n                \"Add new columns with headers: \" + missingColumns.map((c)=>'\"'.concat(c.required, '\"')).join(\", \"),\n                \"Fill with appropriate data or leave empty if no data available\"\n            ],\n            columns: missingColumns.map((c)=>c.required)\n        });\n    }\n    if (caseMismatchColumns.length > 0) {\n        errors.push({\n            type: \"column_case_mismatch\",\n            message: \"Column case mismatch found: \".concat(caseMismatchColumns.map((c)=>'\"'.concat(c.found, '\" should be \"').concat(c.required, '\"')).join(\", \")),\n            howToFix: \"Update column headers to match the exact case (uppercase/lowercase) required\",\n            examples: [\n                \"Open your CSV file in Excel/Google Sheets\",\n                ...caseMismatchColumns.map((c)=>'Rename \"'.concat(c.found, '\" to \"').concat(c.required, '\"')),\n                \"Save the file and re-upload\"\n            ],\n            columns: caseMismatchColumns.map((c)=>c.required)\n        });\n    }\n    if (nameVariationColumns.length > 0) {\n        warnings.push({\n            type: \"column_name_variations\",\n            message: \"Column name variations detected: \".concat(nameVariationColumns.map((c)=>'\"'.concat(c.found, '\" might be \"').concat(c.required, '\"')).join(\", \")),\n            howToFix: \"Verify and rename columns to match exact required names\",\n            examples: [\n                \"Check if these column mappings are correct:\",\n                ...nameVariationColumns.map((c)=>'\"'.concat(c.found, '\" → \"').concat(c.required, '\"')),\n                \"Rename columns if needed and re-upload\"\n            ],\n            details: nameVariationColumns\n        });\n    }\n    // Check for unexpected columns that might indicate wrong platform\n    const unexpectedColumns = cleanHeaders.filter((header)=>!schema.required.some((req)=>normalizeColumnName(header) === normalizeColumnName(req)));\n    if (unexpectedColumns.length > 0 && unexpectedColumns.length > 3) {\n        warnings.push({\n            type: \"unexpected_columns\",\n            message: \"Many unexpected columns found (\".concat(unexpectedColumns.length, \"). Verify this is the correct platform.\"),\n            details: {\n                unexpectedColumns: unexpectedColumns.slice(0, 5)\n            }\n        });\n    }\n    // Check for common CSV formatting issues\n    if (headers.some((h)=>h.includes(\"\\uFEFF\"))) {\n        warnings.push({\n            type: \"bom_detected\",\n            message: \"BOM (Byte Order Mark) detected in CSV headers. This may cause parsing issues.\",\n            details: {\n                note: \"Save file as UTF-8 without BOM\"\n            }\n        });\n    }\n    // Check for empty headers\n    const emptyHeaders = cleanHeaders.filter((h)=>!h || h.trim() === \"\");\n    if (emptyHeaders.length > 0) {\n        errors.push({\n            type: \"empty_headers\",\n            message: \"Found \".concat(emptyHeaders.length, \" empty column headers. All columns must have names.\"),\n            columns: [\n                \"\".concat(emptyHeaders.length, \" empty headers\")\n            ]\n        });\n    }\n    // Check for duplicate headers\n    const duplicateHeaders = cleanHeaders.filter((header, index)=>cleanHeaders.indexOf(header) !== index);\n    if (duplicateHeaders.length > 0) {\n        errors.push({\n            type: \"duplicate_headers\",\n            message: \"Duplicate column headers found: \".concat([\n                ...new Set(duplicateHeaders)\n            ].join(\", \")),\n            columns: duplicateHeaders\n        });\n    }\n    // Validate date formats (STRICT - must be YYYY-MM-DD)\n    const dateColumn = findColumnByName(cleanHeaders, schema.dateColumn);\n    if (dateColumn) {\n        const dateValidation = validateDateFormats(data, dateColumn);\n        // Check for wrong date formats - make this an ERROR not warning\n        const allowedFormats = schema.acceptedFormats;\n        const nonStandardFormats = dateValidation.detectedFormats.filter((format)=>!allowedFormats.includes(format));\n        if (nonStandardFormats.length > 0) {\n            errors.push({\n                type: \"invalid_date_format\",\n                message: \"Date column '\".concat(dateColumn, \"' must use \").concat(schema.requiredDateFormat, \" format. Found: \").concat(nonStandardFormats.join(\", \")),\n                howToFix: \"Convert all dates in '\".concat(dateColumn, \"' column to YYYY-MM-DD format\"),\n                examples: [\n                    \"Open CSV in Excel/Google Sheets\",\n                    \"Select the entire Date column\",\n                    \"Format cells as Custom: YYYY-MM-DD (e.g., 2025-11-10)\",\n                    \"Or use find/replace: 10/11/2025 → 2025-11-10\",\n                    \"Save as CSV and re-upload\"\n                ],\n                columns: [\n                    dateColumn\n                ]\n            });\n        }\n        // Check for invalid/unparseable dates\n        if (dateValidation.invalidDates.length > 0) {\n            errors.push({\n                type: \"invalid_date_values\",\n                message: \"Invalid date values found in '\".concat(dateColumn, \"': \").concat(dateValidation.invalidDates.slice(0, 3).map((d)=>d.value).join(\", \")),\n                columns: [\n                    dateColumn\n                ]\n            });\n        }\n        // Only add warnings for minor issues if no errors\n        if (nonStandardFormats.length === 0 && dateValidation.invalidDates.length === 0 && dateValidation.detectedFormats.length > 1) {\n            warnings.push({\n                type: \"date_format_inconsistency\",\n                message: \"Multiple date formats detected in \".concat(dateColumn),\n                details: dateValidation\n            });\n        }\n    }\n    // Validate numeric columns\n    const numericValidation = validateNumericColumns(platform, data, cleanHeaders);\n    warnings.push(...numericValidation);\n    return {\n        isValid: errors.length === 0,\n        hasErrors: errors.length > 0,\n        hasWarnings: warnings.length > 0,\n        needsCorrection: warnings.length > 0,\n        errors,\n        warnings,\n        rowCount: data.length,\n        columnCount: headers.length,\n        dateRange: detectDateRange(data, dateColumn)\n    };\n}\nfunction normalizeColumnName(name) {\n    return name.toLowerCase().trim().replace(/[^\\w]/g, \"_\");\n}\nfunction findColumnByName(headers, targetName) {\n    return headers.find((header)=>normalizeColumnName(header) === normalizeColumnName(targetName));\n}\nfunction validateDateFormats(data, dateColumn) {\n    const formats = new Set();\n    const invalidDates = [];\n    data.slice(0, 50).forEach((row, index)=>{\n        const dateValue = row[dateColumn];\n        if (dateValue) {\n            const detectedFormat = detectDateFormat(dateValue);\n            if (detectedFormat) {\n                formats.add(detectedFormat);\n            } else {\n                invalidDates.push({\n                    row: index,\n                    value: dateValue\n                });\n            }\n        }\n    });\n    return {\n        hasIssues: formats.size > 1 || invalidDates.length > 0,\n        detectedFormats: Array.from(formats),\n        invalidDates,\n        recommendedFormat: \"YYYY-MM-DD\"\n    };\n}\nfunction detectDateFormat(dateString) {\n    const trimmed = dateString.trim();\n    const patterns = [\n        {\n            regex: /^\\d{4}-\\d{2}-\\d{2}$/,\n            format: \"YYYY-MM-DD\"\n        },\n        {\n            regex: /^\\d{2}-\\d{2}-\\d{4}$/,\n            format: \"DD-MM-YYYY\"\n        },\n        {\n            regex: /^\\d{1,2}\\/\\d{1,2}\\/\\d{4}$/,\n            format: \"DD/MM/YYYY\"\n        },\n        {\n            regex: /^\\d{2}\\/\\d{2}\\/\\d{4}$/,\n            format: \"DD/MM/YYYY\"\n        },\n        {\n            regex: /^\\d{4}\\/\\d{2}\\/\\d{2}$/,\n            format: \"YYYY/MM/DD\"\n        },\n        {\n            regex: /^\\d{2}\\.\\d{2}\\.\\d{4}$/,\n            format: \"DD.MM.YYYY\"\n        }\n    ];\n    for (const pattern of patterns){\n        if (pattern.regex.test(trimmed)) {\n            return pattern.format;\n        }\n    }\n    return null;\n}\nfunction validateNumericColumns(platform, data, headers) {\n    const warnings = [];\n    const numericColumns = getNumericColumns(platform, headers);\n    numericColumns.forEach((column)=>{\n        const nonNumericValues = data.slice(0, 50).map((row, index)=>({\n                index,\n                value: row[column]\n            })).filter((item)=>item.value && isNaN(parseFloat(item.value.toString().replace(/[,%]/g, \"\"))));\n        if (nonNumericValues.length > 0) {\n            warnings.push({\n                type: \"non_numeric_values\",\n                message: \"Non-numeric values detected in \".concat(column),\n                column,\n                samples: nonNumericValues.slice(0, 5)\n            });\n        }\n    });\n    return warnings;\n}\nfunction getNumericColumns(platform, headers) {\n    const numericPatterns = {\n        meta: [\n            \"amount\",\n            \"spent\",\n            \"cost\",\n            \"ctr\",\n            \"cpm\"\n        ],\n        google: [\n            \"cost\",\n            \"ctr\",\n            \"cpm\"\n        ],\n        shopify: [\n            \"visitors\",\n            \"sessions\",\n            \"checkout\",\n            \"duration\",\n            \"pageviews\"\n        ]\n    };\n    return headers.filter((header)=>{\n        const normalized = normalizeColumnName(header);\n        return numericPatterns[platform].some((pattern)=>normalized.includes(pattern));\n    });\n}\nfunction detectDateRange(data, dateColumn) {\n    if (!dateColumn || data.length === 0) return null;\n    const dates = data.map((row)=>row[dateColumn]).filter(Boolean).map((dateStr)=>new Date(dateStr)).filter((date)=>!isNaN(date.getTime())).sort();\n    if (dates.length === 0) return null;\n    return {\n        start: dates[0].toISOString().split(\"T\")[0],\n        end: dates[dates.length - 1].toISOString().split(\"T\")[0],\n        totalDays: Math.ceil((dates[dates.length - 1].getTime() - dates[0].getTime()) / (1000 * 60 * 60 * 24)) + 1\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvdmFsaWRhdG9ycy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTRCO0FBdUNyQixNQUFNQyxtQkFPUjtJQUNIQyxNQUFNO1FBQ0pDLFVBQVU7WUFDUjtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtTQUNEO1FBQ0RDLFlBQVk7UUFDWkMsb0JBQW9CO1FBQ3BCQyxpQkFBaUI7WUFBQztTQUFhO1FBQy9CQyxjQUFjLE1BQU0sd0JBQXdCO0lBQzlDO0lBQ0FDLFFBQVE7UUFDTkwsVUFBVTtZQUNSO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7U0FDRDtRQUNEQyxZQUFZO1FBQ1pDLG9CQUFvQjtRQUNwQkMsaUJBQWlCO1lBQUM7U0FBYTtRQUMvQkMsY0FBYyxNQUFNLGtDQUFrQztJQUN4RDtJQUNBRSxTQUFTO1FBQ1BOLFVBQVU7WUFDUjtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7U0FDRDtRQUNEQyxZQUFZO1FBQ1pDLG9CQUFvQjtRQUNwQkMsaUJBQWlCO1lBQUM7U0FBYTtRQUMvQkMsY0FBYyxNQUFNLCtCQUErQjtJQUNyRDtBQUNGLEVBQUM7QUFFTSxlQUFlRyxZQUFZQyxRQUFrQixFQUFFQyxJQUFVO0lBQzlELE9BQU8sSUFBSUMsUUFBUSxDQUFDQztRQUNsQmQsc0RBQVUsQ0FBQ1ksTUFBTTtZQUNmSSxRQUFRO1lBQ1JDLFNBQVM7WUFDVEMsVUFBVSxDQUFDQztnQkFDVCxNQUFNQyxhQUFhQyxrQkFBa0JWLFVBQVVRLFFBQVFHLElBQUksRUFBRUgsUUFBUWpCLElBQUksQ0FBQ3FCLE1BQU0sSUFBSSxFQUFFO2dCQUN0RlQsUUFBUU07WUFDVjtZQUNBSSxPQUFPLENBQUNBO2dCQUNOVixRQUFRO29CQUNOVyxTQUFTO29CQUNUQyxXQUFXO29CQUNYQyxhQUFhO29CQUNiQyxpQkFBaUI7b0JBQ2pCQyxRQUFRO3dCQUFDOzRCQUFFQyxNQUFNOzRCQUFlQyxTQUFTUCxNQUFNTyxPQUFPO3dCQUFDO3FCQUFFO29CQUN6REMsVUFBVSxFQUFFO29CQUNaQyxVQUFVO29CQUNWQyxhQUFhO29CQUNiQyxXQUFXO2dCQUNiO1lBQ0Y7UUFDRjtJQUNGO0FBQ0Y7QUFFQSxTQUFTZCxrQkFBa0JWLFFBQWtCLEVBQUVXLElBQVcsRUFBRWMsT0FBaUI7SUFDM0UsTUFBTUMsU0FBU3BDLGdCQUFnQixDQUFDVSxTQUFTO0lBQ3pDLE1BQU1rQixTQUE0QixFQUFFO0lBQ3BDLE1BQU1HLFdBQWdDLEVBQUU7SUFFeEMsOENBQThDO0lBQzlDLE1BQU1NLGVBQWVGLFFBQVFHLEdBQUcsQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRUMsT0FBTyxDQUFDLFdBQVcsSUFBSUMsSUFBSTtJQUVuRSxrREFBa0Q7SUFDbEQsTUFBTUMsc0JBQWdGLEVBQUU7SUFFeEYsS0FBSyxNQUFNQyxlQUFlUCxPQUFPbEMsUUFBUSxDQUFFO1FBQ3pDLHdCQUF3QjtRQUN4QixNQUFNMEMsYUFBYVAsYUFBYVEsSUFBSSxDQUFDTixDQUFBQSxJQUFLQSxNQUFNSTtRQUNoRCxJQUFJQyxZQUFZO1FBRWhCLDZCQUE2QjtRQUM3QixNQUFNRSx1QkFBdUJULGFBQWFRLElBQUksQ0FBQ04sQ0FBQUEsSUFDN0NBLEVBQUVRLFdBQVcsT0FBT0osWUFBWUksV0FBVztRQUc3QyxJQUFJRCxzQkFBc0I7WUFDeEJKLG9CQUFvQk0sSUFBSSxDQUFDO2dCQUN2QjlDLFVBQVV5QztnQkFDVk0sT0FBT0g7Z0JBQ1BJLE9BQU87WUFDVDtRQUNGLE9BQU87WUFDTCxrQ0FBa0M7WUFDbEMsTUFBTUMsYUFBYWQsYUFBYVEsSUFBSSxDQUFDTixDQUFBQSxJQUNuQ2Esb0JBQW9CYixPQUFPYSxvQkFBb0JUO1lBR2pELElBQUlRLFlBQVk7Z0JBQ2RULG9CQUFvQk0sSUFBSSxDQUFDO29CQUN2QjlDLFVBQVV5QztvQkFDVk0sT0FBT0U7b0JBQ1BELE9BQU87Z0JBQ1Q7WUFDRixPQUFPO2dCQUNMUixvQkFBb0JNLElBQUksQ0FBQztvQkFDdkI5QyxVQUFVeUM7b0JBQ1ZPLE9BQU87Z0JBQ1Q7WUFDRjtRQUNGO0lBQ0Y7SUFFQSx1QkFBdUI7SUFDdkIsTUFBTUcsaUJBQWlCWCxvQkFBb0JZLE1BQU0sQ0FBQ0osQ0FBQUEsUUFBU0EsTUFBTUEsS0FBSyxLQUFLO0lBQzNFLE1BQU1LLHNCQUFzQmIsb0JBQW9CWSxNQUFNLENBQUNKLENBQUFBLFFBQVNBLE1BQU1BLEtBQUssS0FBSztJQUNoRixNQUFNTSx1QkFBdUJkLG9CQUFvQlksTUFBTSxDQUFDSixDQUFBQSxRQUFTQSxNQUFNQSxLQUFLLEtBQUs7SUFFakYsSUFBSUcsZUFBZUksTUFBTSxHQUFHLEdBQUc7UUFDN0I3QixPQUFPb0IsSUFBSSxDQUFDO1lBQ1ZuQixNQUFNO1lBQ05DLFNBQVMsNkJBQTRFLE9BQS9DdUIsZUFBZWYsR0FBRyxDQUFDb0IsQ0FBQUEsSUFBS0EsRUFBRXhELFFBQVEsRUFBRXlELElBQUksQ0FBQztZQUMvRUMsVUFBVTtZQUNWQyxVQUFVO2dCQUNSO2dCQUNBLG1DQUFtQ1IsZUFBZWYsR0FBRyxDQUFDb0IsQ0FBQUEsSUFBSyxJQUFlLE9BQVhBLEVBQUV4RCxRQUFRLEVBQUMsTUFBSXlELElBQUksQ0FBQztnQkFDbkY7YUFDRDtZQUNERyxTQUFTVCxlQUFlZixHQUFHLENBQUNvQixDQUFBQSxJQUFLQSxFQUFFeEQsUUFBUTtRQUM3QztJQUNGO0lBRUEsSUFBSXFELG9CQUFvQkUsTUFBTSxHQUFHLEdBQUc7UUFDbEM3QixPQUFPb0IsSUFBSSxDQUFDO1lBQ1ZuQixNQUFNO1lBQ05DLFNBQVMsK0JBQWlILE9BQWxGeUIsb0JBQW9CakIsR0FBRyxDQUFDb0IsQ0FBQUEsSUFBSyxJQUEyQkEsT0FBdkJBLEVBQUVULEtBQUssRUFBQyxpQkFBMEIsT0FBWFMsRUFBRXhELFFBQVEsRUFBQyxNQUFJeUQsSUFBSSxDQUFDO1lBQ3BIQyxVQUFVO1lBQ1ZDLFVBQVU7Z0JBQ1I7bUJBQ0dOLG9CQUFvQmpCLEdBQUcsQ0FBQ29CLENBQUFBLElBQUssV0FBMkJBLE9BQWhCQSxFQUFFVCxLQUFLLEVBQUMsVUFBbUIsT0FBWFMsRUFBRXhELFFBQVEsRUFBQztnQkFDdEU7YUFDRDtZQUNENEQsU0FBU1Asb0JBQW9CakIsR0FBRyxDQUFDb0IsQ0FBQUEsSUFBS0EsRUFBRXhELFFBQVE7UUFDbEQ7SUFDRjtJQUVBLElBQUlzRCxxQkFBcUJDLE1BQU0sR0FBRyxHQUFHO1FBQ25DMUIsU0FBU2lCLElBQUksQ0FBQztZQUNabkIsTUFBTTtZQUNOQyxTQUFTLG9DQUFzSCxPQUFsRjBCLHFCQUFxQmxCLEdBQUcsQ0FBQ29CLENBQUFBLElBQUssSUFBMEJBLE9BQXRCQSxFQUFFVCxLQUFLLEVBQUMsZ0JBQXlCLE9BQVhTLEVBQUV4RCxRQUFRLEVBQUMsTUFBSXlELElBQUksQ0FBQztZQUN6SEMsVUFBVTtZQUNWQyxVQUFVO2dCQUNSO21CQUNHTCxxQkFBcUJsQixHQUFHLENBQUNvQixDQUFBQSxJQUFLLElBQW1CQSxPQUFmQSxFQUFFVCxLQUFLLEVBQUMsU0FBa0IsT0FBWFMsRUFBRXhELFFBQVEsRUFBQztnQkFDL0Q7YUFDRDtZQUNENkQsU0FBU1A7UUFDWDtJQUNGO0lBRUEsa0VBQWtFO0lBQ2xFLE1BQU1RLG9CQUFvQjNCLGFBQWFpQixNQUFNLENBQUN2QyxDQUFBQSxTQUM1QyxDQUFDcUIsT0FBT2xDLFFBQVEsQ0FBQytELElBQUksQ0FBQ0MsQ0FBQUEsTUFBT2Qsb0JBQW9CckMsWUFBWXFDLG9CQUFvQmM7SUFHbkYsSUFBSUYsa0JBQWtCUCxNQUFNLEdBQUcsS0FBS08sa0JBQWtCUCxNQUFNLEdBQUcsR0FBRztRQUNoRTFCLFNBQVNpQixJQUFJLENBQUM7WUFDWm5CLE1BQU07WUFDTkMsU0FBUyxrQ0FBMkQsT0FBekJrQyxrQkFBa0JQLE1BQU0sRUFBQztZQUNwRU0sU0FBUztnQkFBRUMsbUJBQW1CQSxrQkFBa0JHLEtBQUssQ0FBQyxHQUFHO1lBQUc7UUFDOUQ7SUFDRjtJQUVBLHlDQUF5QztJQUN6QyxJQUFJaEMsUUFBUThCLElBQUksQ0FBQzFCLENBQUFBLElBQUtBLEVBQUU2QixRQUFRLENBQUMsWUFBWTtRQUMzQ3JDLFNBQVNpQixJQUFJLENBQUM7WUFDWm5CLE1BQU07WUFDTkMsU0FBUztZQUNUaUMsU0FBUztnQkFBRU0sTUFBTTtZQUFpQztRQUNwRDtJQUNGO0lBRUEsMEJBQTBCO0lBQzFCLE1BQU1DLGVBQWVqQyxhQUFhaUIsTUFBTSxDQUFDZixDQUFBQSxJQUFLLENBQUNBLEtBQUtBLEVBQUVFLElBQUksT0FBTztJQUNqRSxJQUFJNkIsYUFBYWIsTUFBTSxHQUFHLEdBQUc7UUFDM0I3QixPQUFPb0IsSUFBSSxDQUFDO1lBQ1ZuQixNQUFNO1lBQ05DLFNBQVMsU0FBNkIsT0FBcEJ3QyxhQUFhYixNQUFNLEVBQUM7WUFDdENLLFNBQVM7Z0JBQUUsR0FBc0IsT0FBcEJRLGFBQWFiLE1BQU0sRUFBQzthQUFnQjtRQUNuRDtJQUNGO0lBRUEsOEJBQThCO0lBQzlCLE1BQU1jLG1CQUFtQmxDLGFBQWFpQixNQUFNLENBQUMsQ0FBQ3ZDLFFBQVF5RCxRQUNwRG5DLGFBQWFvQyxPQUFPLENBQUMxRCxZQUFZeUQ7SUFFbkMsSUFBSUQsaUJBQWlCZCxNQUFNLEdBQUcsR0FBRztRQUMvQjdCLE9BQU9vQixJQUFJLENBQUM7WUFDVm5CLE1BQU07WUFDTkMsU0FBUyxtQ0FBNkUsT0FBMUM7bUJBQUksSUFBSTRDLElBQUlIO2FBQWtCLENBQUNaLElBQUksQ0FBQztZQUNoRkcsU0FBU1M7UUFDWDtJQUNGO0lBRUEsc0RBQXNEO0lBQ3RELE1BQU1wRSxhQUFhd0UsaUJBQWlCdEMsY0FBY0QsT0FBT2pDLFVBQVU7SUFDbkUsSUFBSUEsWUFBWTtRQUNkLE1BQU15RSxpQkFBaUJDLG9CQUFvQnhELE1BQU1sQjtRQUVqRCxnRUFBZ0U7UUFDaEUsTUFBTTJFLGlCQUFpQjFDLE9BQU8vQixlQUFlO1FBQzdDLE1BQU0wRSxxQkFBcUJILGVBQWVJLGVBQWUsQ0FBQzFCLE1BQU0sQ0FBQzJCLENBQUFBLFNBQVUsQ0FBQ0gsZUFBZVYsUUFBUSxDQUFDYTtRQUNwRyxJQUFJRixtQkFBbUJ0QixNQUFNLEdBQUcsR0FBRztZQUNqQzdCLE9BQU9vQixJQUFJLENBQUM7Z0JBQ1ZuQixNQUFNO2dCQUNOQyxTQUFTLGdCQUF3Q00sT0FBeEJqQyxZQUFXLGVBQXlENEUsT0FBNUMzQyxPQUFPaEMsa0JBQWtCLEVBQUMsb0JBQWdELE9BQTlCMkUsbUJBQW1CcEIsSUFBSSxDQUFDO2dCQUNySEMsVUFBVSx5QkFBb0MsT0FBWHpELFlBQVc7Z0JBQzlDMEQsVUFBVTtvQkFDUjtvQkFDQTtvQkFDQTtvQkFDQTtvQkFDQTtpQkFDRDtnQkFDREMsU0FBUztvQkFBQzNEO2lCQUFXO1lBQ3ZCO1FBQ0Y7UUFFQSxzQ0FBc0M7UUFDdEMsSUFBSXlFLGVBQWVNLFlBQVksQ0FBQ3pCLE1BQU0sR0FBRyxHQUFHO1lBQzFDN0IsT0FBT29CLElBQUksQ0FBQztnQkFDVm5CLE1BQU07Z0JBQ05DLFNBQVMsaUNBQWlEOEMsT0FBaEJ6RSxZQUFXLE9BQTBFLE9BQXJFeUUsZUFBZU0sWUFBWSxDQUFDZixLQUFLLENBQUMsR0FBRyxHQUFHN0IsR0FBRyxDQUFDNkMsQ0FBQUEsSUFBS0EsRUFBRUMsS0FBSyxFQUFFekIsSUFBSSxDQUFDO2dCQUN6SEcsU0FBUztvQkFBQzNEO2lCQUFXO1lBQ3ZCO1FBQ0Y7UUFFQSxrREFBa0Q7UUFDbEQsSUFBSTRFLG1CQUFtQnRCLE1BQU0sS0FBSyxLQUFLbUIsZUFBZU0sWUFBWSxDQUFDekIsTUFBTSxLQUFLLEtBQUttQixlQUFlSSxlQUFlLENBQUN2QixNQUFNLEdBQUcsR0FBRztZQUM1SDFCLFNBQVNpQixJQUFJLENBQUM7Z0JBQ1puQixNQUFNO2dCQUNOQyxTQUFTLHFDQUFnRCxPQUFYM0I7Z0JBQzlDNEQsU0FBU2E7WUFDWDtRQUNGO0lBQ0Y7SUFFQSwyQkFBMkI7SUFDM0IsTUFBTVMsb0JBQW9CQyx1QkFBdUI1RSxVQUFVVyxNQUFNZ0I7SUFDakVOLFNBQVNpQixJQUFJLElBQUlxQztJQUVqQixPQUFPO1FBQ0w3RCxTQUFTSSxPQUFPNkIsTUFBTSxLQUFLO1FBQzNCaEMsV0FBV0csT0FBTzZCLE1BQU0sR0FBRztRQUMzQi9CLGFBQWFLLFNBQVMwQixNQUFNLEdBQUc7UUFDL0I5QixpQkFBaUJJLFNBQVMwQixNQUFNLEdBQUc7UUFDbkM3QjtRQUNBRztRQUNBQyxVQUFVWCxLQUFLb0MsTUFBTTtRQUNyQnhCLGFBQWFFLFFBQVFzQixNQUFNO1FBQzNCdkIsV0FBV3FELGdCQUFnQmxFLE1BQU1sQjtJQUNuQztBQUNGO0FBRUEsU0FBU2lELG9CQUFvQm9DLElBQVk7SUFDdkMsT0FBT0EsS0FBS3pDLFdBQVcsR0FBR04sSUFBSSxHQUFHRCxPQUFPLENBQUMsVUFBVTtBQUNyRDtBQUVBLFNBQVNtQyxpQkFBaUJ4QyxPQUFpQixFQUFFc0QsVUFBa0I7SUFDN0QsT0FBT3RELFFBQVFVLElBQUksQ0FBQzlCLENBQUFBLFNBQ2xCcUMsb0JBQW9CckMsWUFBWXFDLG9CQUFvQnFDO0FBRXhEO0FBRUEsU0FBU1osb0JBQW9CeEQsSUFBVyxFQUFFbEIsVUFBa0I7SUFDMUQsTUFBTXVGLFVBQVUsSUFBSWhCO0lBQ3BCLE1BQU1RLGVBQXNCLEVBQUU7SUFFOUI3RCxLQUFLOEMsS0FBSyxDQUFDLEdBQUcsSUFBSXdCLE9BQU8sQ0FBQyxDQUFDQyxLQUFLcEI7UUFDOUIsTUFBTXFCLFlBQVlELEdBQUcsQ0FBQ3pGLFdBQVc7UUFDakMsSUFBSTBGLFdBQVc7WUFDYixNQUFNQyxpQkFBaUJDLGlCQUFpQkY7WUFDeEMsSUFBSUMsZ0JBQWdCO2dCQUNsQkosUUFBUU0sR0FBRyxDQUFDRjtZQUNkLE9BQU87Z0JBQ0xaLGFBQWFsQyxJQUFJLENBQUM7b0JBQUU0QyxLQUFLcEI7b0JBQU9ZLE9BQU9TO2dCQUFVO1lBQ25EO1FBQ0Y7SUFDRjtJQUVBLE9BQU87UUFDTEksV0FBV1AsUUFBUVEsSUFBSSxHQUFHLEtBQUtoQixhQUFhekIsTUFBTSxHQUFHO1FBQ3JEdUIsaUJBQWlCbUIsTUFBTUMsSUFBSSxDQUFDVjtRQUM1QlI7UUFDQW1CLG1CQUFtQjtJQUNyQjtBQUNGO0FBRUEsU0FBU04saUJBQWlCTyxVQUFrQjtJQUMxQyxNQUFNQyxVQUFVRCxXQUFXN0QsSUFBSTtJQUUvQixNQUFNK0QsV0FBVztRQUNmO1lBQUVDLE9BQU87WUFBdUJ4QixRQUFRO1FBQWE7UUFDckQ7WUFBRXdCLE9BQU87WUFBdUJ4QixRQUFRO1FBQWE7UUFDckQ7WUFBRXdCLE9BQU87WUFBNkJ4QixRQUFRO1FBQWE7UUFDM0Q7WUFBRXdCLE9BQU87WUFBeUJ4QixRQUFRO1FBQWE7UUFDdkQ7WUFBRXdCLE9BQU87WUFBeUJ4QixRQUFRO1FBQWE7UUFDdkQ7WUFBRXdCLE9BQU87WUFBeUJ4QixRQUFRO1FBQWE7S0FDeEQ7SUFFRCxLQUFLLE1BQU15QixXQUFXRixTQUFVO1FBQzlCLElBQUlFLFFBQVFELEtBQUssQ0FBQ0UsSUFBSSxDQUFDSixVQUFVO1lBQy9CLE9BQU9HLFFBQVF6QixNQUFNO1FBQ3ZCO0lBQ0Y7SUFDQSxPQUFPO0FBQ1Q7QUFFQSxTQUFTSyx1QkFBdUI1RSxRQUFrQixFQUFFVyxJQUFXLEVBQUVjLE9BQWlCO0lBQ2hGLE1BQU1KLFdBQWdDLEVBQUU7SUFDeEMsTUFBTTZFLGlCQUFpQkMsa0JBQWtCbkcsVUFBVXlCO0lBRW5EeUUsZUFBZWpCLE9BQU8sQ0FBQ21CLENBQUFBO1FBQ3JCLE1BQU1DLG1CQUFtQjFGLEtBQUs4QyxLQUFLLENBQUMsR0FBRyxJQUNwQzdCLEdBQUcsQ0FBQyxDQUFDc0QsS0FBS3BCLFFBQVc7Z0JBQUVBO2dCQUFPWSxPQUFPUSxHQUFHLENBQUNrQixPQUFPO1lBQUMsSUFDakR4RCxNQUFNLENBQUMwRCxDQUFBQSxPQUFRQSxLQUFLNUIsS0FBSyxJQUFJNkIsTUFBTUMsV0FBV0YsS0FBSzVCLEtBQUssQ0FBQytCLFFBQVEsR0FBRzNFLE9BQU8sQ0FBQyxTQUFTO1FBRXhGLElBQUl1RSxpQkFBaUJ0RCxNQUFNLEdBQUcsR0FBRztZQUMvQjFCLFNBQVNpQixJQUFJLENBQUM7Z0JBQ1puQixNQUFNO2dCQUNOQyxTQUFTLGtDQUF5QyxPQUFQZ0Y7Z0JBQzNDQTtnQkFDQU0sU0FBU0wsaUJBQWlCNUMsS0FBSyxDQUFDLEdBQUc7WUFDckM7UUFDRjtJQUNGO0lBRUEsT0FBT3BDO0FBQ1Q7QUFFQSxTQUFTOEUsa0JBQWtCbkcsUUFBa0IsRUFBRXlCLE9BQWlCO0lBQzlELE1BQU1rRixrQkFBOEM7UUFDbERwSCxNQUFNO1lBQUM7WUFBVTtZQUFTO1lBQVE7WUFBTztTQUFNO1FBQy9DTSxRQUFRO1lBQUM7WUFBUTtZQUFPO1NBQU07UUFDOUJDLFNBQVM7WUFBQztZQUFZO1lBQVk7WUFBWTtZQUFZO1NBQVk7SUFDeEU7SUFFQSxPQUFPMkIsUUFBUW1CLE1BQU0sQ0FBQ3ZDLENBQUFBO1FBQ3BCLE1BQU11RyxhQUFhbEUsb0JBQW9CckM7UUFDdkMsT0FBT3NHLGVBQWUsQ0FBQzNHLFNBQVMsQ0FBQ3VELElBQUksQ0FBQ3lDLENBQUFBLFVBQVdZLFdBQVdsRCxRQUFRLENBQUNzQztJQUN2RTtBQUNGO0FBRUEsU0FBU25CLGdCQUFnQmxFLElBQVcsRUFBRWxCLFVBQThCO0lBQ2xFLElBQUksQ0FBQ0EsY0FBY2tCLEtBQUtvQyxNQUFNLEtBQUssR0FBRyxPQUFPO0lBRTdDLE1BQU04RCxRQUFRbEcsS0FDWGlCLEdBQUcsQ0FBQ3NELENBQUFBLE1BQU9BLEdBQUcsQ0FBQ3pGLFdBQVcsRUFDMUJtRCxNQUFNLENBQUNrRSxTQUNQbEYsR0FBRyxDQUFDbUYsQ0FBQUEsVUFBVyxJQUFJQyxLQUFLRCxVQUN4Qm5FLE1BQU0sQ0FBQ3FFLENBQUFBLE9BQVEsQ0FBQ1YsTUFBTVUsS0FBS0MsT0FBTyxLQUNsQ0MsSUFBSTtJQUVQLElBQUlOLE1BQU05RCxNQUFNLEtBQUssR0FBRyxPQUFPO0lBRS9CLE9BQU87UUFDTHFFLE9BQU9QLEtBQUssQ0FBQyxFQUFFLENBQUNRLFdBQVcsR0FBR0MsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFO1FBQzNDQyxLQUFLVixLQUFLLENBQUNBLE1BQU05RCxNQUFNLEdBQUcsRUFBRSxDQUFDc0UsV0FBVyxHQUFHQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7UUFDeERFLFdBQVdDLEtBQUtDLElBQUksQ0FBQyxDQUFDYixLQUFLLENBQUNBLE1BQU05RCxNQUFNLEdBQUcsRUFBRSxDQUFDbUUsT0FBTyxLQUFLTCxLQUFLLENBQUMsRUFBRSxDQUFDSyxPQUFPLEVBQUMsSUFBTSxRQUFPLEtBQUssS0FBSyxFQUFDLEtBQU07SUFDM0c7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvdmFsaWRhdG9ycy50cz81NmIwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBQYXBhIGZyb20gJ3BhcGFwYXJzZSdcbmltcG9ydCB7IFBsYXRmb3JtIH0gZnJvbSAnLi9zdXBhYmFzZSdcblxuZXhwb3J0IGludGVyZmFjZSBWYWxpZGF0aW9uUmVzdWx0IHtcbiAgaXNWYWxpZDogYm9vbGVhblxuICBoYXNFcnJvcnM6IGJvb2xlYW5cbiAgaGFzV2FybmluZ3M6IGJvb2xlYW5cbiAgbmVlZHNDb3JyZWN0aW9uOiBib29sZWFuXG4gIGVycm9yczogVmFsaWRhdGlvbkVycm9yW11cbiAgd2FybmluZ3M6IFZhbGlkYXRpb25XYXJuaW5nW11cbiAgcm93Q291bnQ6IG51bWJlclxuICBjb2x1bW5Db3VudDogbnVtYmVyXG4gIGRhdGVSYW5nZTogRGF0ZVJhbmdlIHwgbnVsbFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFZhbGlkYXRpb25FcnJvciB7XG4gIHR5cGU6IHN0cmluZ1xuICBtZXNzYWdlOiBzdHJpbmdcbiAgaG93VG9GaXg6IHN0cmluZ1xuICBleGFtcGxlcz86IHN0cmluZ1tdXG4gIGNvbHVtbnM/OiBzdHJpbmdbXVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFZhbGlkYXRpb25XYXJuaW5nIHtcbiAgdHlwZTogc3RyaW5nXG4gIG1lc3NhZ2U6IHN0cmluZ1xuICBob3dUb0ZpeD86IHN0cmluZ1xuICBleGFtcGxlcz86IHN0cmluZ1tdXG4gIGNvbHVtbj86IHN0cmluZ1xuICBzYW1wbGVzPzogYW55W11cbiAgZGV0YWlscz86IGFueVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIERhdGVSYW5nZSB7XG4gIHN0YXJ0OiBzdHJpbmdcbiAgZW5kOiBzdHJpbmdcbiAgdG90YWxEYXlzOiBudW1iZXJcbn1cblxuZXhwb3J0IGNvbnN0IFBMQVRGT1JNX1NDSEVNQVM6IFJlY29yZDxQbGF0Zm9ybSwge1xuICByZXF1aXJlZDogc3RyaW5nW11cbiAgZGF0ZUNvbHVtbjogc3RyaW5nXG4gIHJlcXVpcmVkRGF0ZUZvcm1hdDogc3RyaW5nXG4gIGFjY2VwdGVkRm9ybWF0czogc3RyaW5nW11cbiAgb3JkZXJNYXR0ZXJzOiBib29sZWFuXG4gIGV4cGVjdGVkT3JkZXI/OiBzdHJpbmdbXVxufT4gPSB7XG4gIG1ldGE6IHtcbiAgICByZXF1aXJlZDogW1xuICAgICAgJ0RheScsXG4gICAgICAnQ2FtcGFpZ24gbmFtZScsXG4gICAgICAnQWQgc2V0IG5hbWUnLCBcbiAgICAgICdBZCBuYW1lJyxcbiAgICAgICdBbW91bnQgc3BlbnQgKElOUiknLFxuICAgICAgJ0NUUiAobGluayBjbGljay10aHJvdWdoIHJhdGUpJyxcbiAgICAgICdDUE0gKGNvc3QgcGVyIDEsMDAwIGltcHJlc3Npb25zKSdcbiAgICBdLFxuICAgIGRhdGVDb2x1bW46ICdEYXknLFxuICAgIHJlcXVpcmVkRGF0ZUZvcm1hdDogJ1lZWVktTU0tREQnLFxuICAgIGFjY2VwdGVkRm9ybWF0czogWydZWVlZLU1NLUREJ10sXG4gICAgb3JkZXJNYXR0ZXJzOiBmYWxzZSAvLyBNZXRhIGV4cG9ydHMgY2FuIHZhcnlcbiAgfSxcbiAgZ29vZ2xlOiB7XG4gICAgcmVxdWlyZWQ6IFtcbiAgICAgICdEYXknLFxuICAgICAgJ0NhbXBhaWduJyxcbiAgICAgICdDb3N0JyxcbiAgICAgICdDVFInLFxuICAgICAgJ0F2Zy4gQ1BNJ1xuICAgIF0sXG4gICAgZGF0ZUNvbHVtbjogJ0RheScsXG4gICAgcmVxdWlyZWREYXRlRm9ybWF0OiAnWVlZWS1NTS1ERCcsXG4gICAgYWNjZXB0ZWRGb3JtYXRzOiBbJ1lZWVktTU0tREQnXSxcbiAgICBvcmRlck1hdHRlcnM6IGZhbHNlIC8vIEdvb2dsZSBBZHMgZXhwb3J0cyBhcmUgZmxleGlibGVcbiAgfSxcbiAgc2hvcGlmeToge1xuICAgIHJlcXVpcmVkOiBbXG4gICAgICAnRGF5JyxcbiAgICAgICdVVE0gY2FtcGFpZ24nLFxuICAgICAgJ1VUTSB0ZXJtJyxcbiAgICAgICdVVE0gY29udGVudCcsXG4gICAgICAnT25saW5lIHN0b3JlIHZpc2l0b3JzJyxcbiAgICAgICdTZXNzaW9ucyB0aGF0IGNvbXBsZXRlZCBjaGVja291dCdcbiAgICBdLFxuICAgIGRhdGVDb2x1bW46ICdEYXknLFxuICAgIHJlcXVpcmVkRGF0ZUZvcm1hdDogJ1lZWVktTU0tREQnLFxuICAgIGFjY2VwdGVkRm9ybWF0czogWydZWVlZLU1NLUREJ10sXG4gICAgb3JkZXJNYXR0ZXJzOiBmYWxzZSAvLyBTaG9waWZ5IHJlcG9ydHMgYXJlIGZsZXhpYmxlXG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHZhbGlkYXRlQ1NWKHBsYXRmb3JtOiBQbGF0Zm9ybSwgZmlsZTogRmlsZSk6IFByb21pc2U8VmFsaWRhdGlvblJlc3VsdD4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBQYXBhLnBhcnNlKGZpbGUsIHtcbiAgICAgIGhlYWRlcjogdHJ1ZSxcbiAgICAgIHByZXZpZXc6IDEwMCxcbiAgICAgIGNvbXBsZXRlOiAocmVzdWx0cykgPT4ge1xuICAgICAgICBjb25zdCB2YWxpZGF0aW9uID0gcGVyZm9ybVZhbGlkYXRpb24ocGxhdGZvcm0sIHJlc3VsdHMuZGF0YSwgcmVzdWx0cy5tZXRhLmZpZWxkcyB8fCBbXSlcbiAgICAgICAgcmVzb2x2ZSh2YWxpZGF0aW9uKVxuICAgICAgfSxcbiAgICAgIGVycm9yOiAoZXJyb3IpID0+IHtcbiAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICAgICAgaGFzRXJyb3JzOiB0cnVlLFxuICAgICAgICAgIGhhc1dhcm5pbmdzOiBmYWxzZSxcbiAgICAgICAgICBuZWVkc0NvcnJlY3Rpb246IGZhbHNlLFxuICAgICAgICAgIGVycm9yczogW3sgdHlwZTogJ3BhcnNlX2Vycm9yJywgbWVzc2FnZTogZXJyb3IubWVzc2FnZSB9XSxcbiAgICAgICAgICB3YXJuaW5nczogW10sXG4gICAgICAgICAgcm93Q291bnQ6IDAsXG4gICAgICAgICAgY29sdW1uQ291bnQ6IDAsXG4gICAgICAgICAgZGF0ZVJhbmdlOiBudWxsXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gcGVyZm9ybVZhbGlkYXRpb24ocGxhdGZvcm06IFBsYXRmb3JtLCBkYXRhOiBhbnlbXSwgaGVhZGVyczogc3RyaW5nW10pOiBWYWxpZGF0aW9uUmVzdWx0IHtcbiAgY29uc3Qgc2NoZW1hID0gUExBVEZPUk1fU0NIRU1BU1twbGF0Zm9ybV1cbiAgY29uc3QgZXJyb3JzOiBWYWxpZGF0aW9uRXJyb3JbXSA9IFtdXG4gIGNvbnN0IHdhcm5pbmdzOiBWYWxpZGF0aW9uV2FybmluZ1tdID0gW11cblxuICAvLyBDbGVhbiBoZWFkZXJzIChyZW1vdmUgQk9NLCB0cmltIHdoaXRlc3BhY2UpXG4gIGNvbnN0IGNsZWFuSGVhZGVycyA9IGhlYWRlcnMubWFwKGggPT4gaC5yZXBsYWNlKC9eXFx1ZmVmZi8sICcnKS50cmltKCkpXG4gIFxuICAvLyBDaGVjayBmb3IgY2FzZS1zZW5zaXRpdmUgY29sdW1uIG1hdGNoaW5nIGlzc3Vlc1xuICBjb25zdCBjb2x1bW5NYXBwaW5nSXNzdWVzOiBBcnJheTx7cmVxdWlyZWQ6IHN0cmluZywgZm91bmQ/OiBzdHJpbmcsIGlzc3VlOiBzdHJpbmd9PiA9IFtdXG4gIFxuICBmb3IgKGNvbnN0IHJlcXVpcmVkQ29sIG9mIHNjaGVtYS5yZXF1aXJlZCkge1xuICAgIC8vIFRyeSBleGFjdCBtYXRjaCBmaXJzdFxuICAgIGNvbnN0IGV4YWN0TWF0Y2ggPSBjbGVhbkhlYWRlcnMuZmluZChoID0+IGggPT09IHJlcXVpcmVkQ29sKVxuICAgIGlmIChleGFjdE1hdGNoKSBjb250aW51ZVxuICAgIFxuICAgIC8vIFRyeSBjYXNlLWluc2Vuc2l0aXZlIG1hdGNoXG4gICAgY29uc3QgY2FzZUluc2Vuc2l0aXZlTWF0Y2ggPSBjbGVhbkhlYWRlcnMuZmluZChoID0+IFxuICAgICAgaC50b0xvd2VyQ2FzZSgpID09PSByZXF1aXJlZENvbC50b0xvd2VyQ2FzZSgpXG4gICAgKVxuICAgIFxuICAgIGlmIChjYXNlSW5zZW5zaXRpdmVNYXRjaCkge1xuICAgICAgY29sdW1uTWFwcGluZ0lzc3Vlcy5wdXNoKHtcbiAgICAgICAgcmVxdWlyZWQ6IHJlcXVpcmVkQ29sLFxuICAgICAgICBmb3VuZDogY2FzZUluc2Vuc2l0aXZlTWF0Y2gsXG4gICAgICAgIGlzc3VlOiAnY2FzZV9taXNtYXRjaCdcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRyeSBmdXp6eSBtYXRjaCAoc2ltaWxhciBuYW1lcylcbiAgICAgIGNvbnN0IGZ1enp5TWF0Y2ggPSBjbGVhbkhlYWRlcnMuZmluZChoID0+IFxuICAgICAgICBub3JtYWxpemVDb2x1bW5OYW1lKGgpID09PSBub3JtYWxpemVDb2x1bW5OYW1lKHJlcXVpcmVkQ29sKVxuICAgICAgKVxuICAgICAgXG4gICAgICBpZiAoZnV6enlNYXRjaCkge1xuICAgICAgICBjb2x1bW5NYXBwaW5nSXNzdWVzLnB1c2goe1xuICAgICAgICAgIHJlcXVpcmVkOiByZXF1aXJlZENvbCxcbiAgICAgICAgICBmb3VuZDogZnV6enlNYXRjaCxcbiAgICAgICAgICBpc3N1ZTogJ25hbWVfdmFyaWF0aW9uJ1xuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29sdW1uTWFwcGluZ0lzc3Vlcy5wdXNoKHtcbiAgICAgICAgICByZXF1aXJlZDogcmVxdWlyZWRDb2wsXG4gICAgICAgICAgaXNzdWU6ICdtaXNzaW5nJ1xuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFJlcG9ydCBjb2x1bW4gaXNzdWVzXG4gIGNvbnN0IG1pc3NpbmdDb2x1bW5zID0gY29sdW1uTWFwcGluZ0lzc3Vlcy5maWx0ZXIoaXNzdWUgPT4gaXNzdWUuaXNzdWUgPT09ICdtaXNzaW5nJylcbiAgY29uc3QgY2FzZU1pc21hdGNoQ29sdW1ucyA9IGNvbHVtbk1hcHBpbmdJc3N1ZXMuZmlsdGVyKGlzc3VlID0+IGlzc3VlLmlzc3VlID09PSAnY2FzZV9taXNtYXRjaCcpXG4gIGNvbnN0IG5hbWVWYXJpYXRpb25Db2x1bW5zID0gY29sdW1uTWFwcGluZ0lzc3Vlcy5maWx0ZXIoaXNzdWUgPT4gaXNzdWUuaXNzdWUgPT09ICduYW1lX3ZhcmlhdGlvbicpXG4gIFxuICBpZiAobWlzc2luZ0NvbHVtbnMubGVuZ3RoID4gMCkge1xuICAgIGVycm9ycy5wdXNoKHtcbiAgICAgIHR5cGU6ICdtaXNzaW5nX2NvbHVtbnMnLFxuICAgICAgbWVzc2FnZTogYE1pc3NpbmcgcmVxdWlyZWQgY29sdW1uczogJHttaXNzaW5nQ29sdW1ucy5tYXAoYyA9PiBjLnJlcXVpcmVkKS5qb2luKCcsICcpfWAsXG4gICAgICBob3dUb0ZpeDogJ0FkZCB0aGUgbWlzc2luZyBjb2x1bW5zIHRvIHlvdXIgQ1NWIGZpbGUgd2l0aCB0aGUgZXhhY3QgbmFtZXMgc2hvd24gYWJvdmUnLFxuICAgICAgZXhhbXBsZXM6IFtcbiAgICAgICAgJ09wZW4geW91ciBDU1YgaW4gRXhjZWwvR29vZ2xlIFNoZWV0cycsXG4gICAgICAgICdBZGQgbmV3IGNvbHVtbnMgd2l0aCBoZWFkZXJzOiAnICsgbWlzc2luZ0NvbHVtbnMubWFwKGMgPT4gYFwiJHtjLnJlcXVpcmVkfVwiYCkuam9pbignLCAnKSxcbiAgICAgICAgJ0ZpbGwgd2l0aCBhcHByb3ByaWF0ZSBkYXRhIG9yIGxlYXZlIGVtcHR5IGlmIG5vIGRhdGEgYXZhaWxhYmxlJ1xuICAgICAgXSxcbiAgICAgIGNvbHVtbnM6IG1pc3NpbmdDb2x1bW5zLm1hcChjID0+IGMucmVxdWlyZWQpXG4gICAgfSlcbiAgfVxuXG4gIGlmIChjYXNlTWlzbWF0Y2hDb2x1bW5zLmxlbmd0aCA+IDApIHtcbiAgICBlcnJvcnMucHVzaCh7XG4gICAgICB0eXBlOiAnY29sdW1uX2Nhc2VfbWlzbWF0Y2gnLFxuICAgICAgbWVzc2FnZTogYENvbHVtbiBjYXNlIG1pc21hdGNoIGZvdW5kOiAke2Nhc2VNaXNtYXRjaENvbHVtbnMubWFwKGMgPT4gYFwiJHtjLmZvdW5kfVwiIHNob3VsZCBiZSBcIiR7Yy5yZXF1aXJlZH1cImApLmpvaW4oJywgJyl9YCxcbiAgICAgIGhvd1RvRml4OiAnVXBkYXRlIGNvbHVtbiBoZWFkZXJzIHRvIG1hdGNoIHRoZSBleGFjdCBjYXNlICh1cHBlcmNhc2UvbG93ZXJjYXNlKSByZXF1aXJlZCcsXG4gICAgICBleGFtcGxlczogW1xuICAgICAgICAnT3BlbiB5b3VyIENTViBmaWxlIGluIEV4Y2VsL0dvb2dsZSBTaGVldHMnLFxuICAgICAgICAuLi5jYXNlTWlzbWF0Y2hDb2x1bW5zLm1hcChjID0+IGBSZW5hbWUgXCIke2MuZm91bmR9XCIgdG8gXCIke2MucmVxdWlyZWR9XCJgKSxcbiAgICAgICAgJ1NhdmUgdGhlIGZpbGUgYW5kIHJlLXVwbG9hZCdcbiAgICAgIF0sXG4gICAgICBjb2x1bW5zOiBjYXNlTWlzbWF0Y2hDb2x1bW5zLm1hcChjID0+IGMucmVxdWlyZWQpXG4gICAgfSlcbiAgfVxuXG4gIGlmIChuYW1lVmFyaWF0aW9uQ29sdW1ucy5sZW5ndGggPiAwKSB7XG4gICAgd2FybmluZ3MucHVzaCh7XG4gICAgICB0eXBlOiAnY29sdW1uX25hbWVfdmFyaWF0aW9ucycsXG4gICAgICBtZXNzYWdlOiBgQ29sdW1uIG5hbWUgdmFyaWF0aW9ucyBkZXRlY3RlZDogJHtuYW1lVmFyaWF0aW9uQ29sdW1ucy5tYXAoYyA9PiBgXCIke2MuZm91bmR9XCIgbWlnaHQgYmUgXCIke2MucmVxdWlyZWR9XCJgKS5qb2luKCcsICcpfWAsXG4gICAgICBob3dUb0ZpeDogJ1ZlcmlmeSBhbmQgcmVuYW1lIGNvbHVtbnMgdG8gbWF0Y2ggZXhhY3QgcmVxdWlyZWQgbmFtZXMnLFxuICAgICAgZXhhbXBsZXM6IFtcbiAgICAgICAgJ0NoZWNrIGlmIHRoZXNlIGNvbHVtbiBtYXBwaW5ncyBhcmUgY29ycmVjdDonLFxuICAgICAgICAuLi5uYW1lVmFyaWF0aW9uQ29sdW1ucy5tYXAoYyA9PiBgXCIke2MuZm91bmR9XCIg4oaSIFwiJHtjLnJlcXVpcmVkfVwiYCksXG4gICAgICAgICdSZW5hbWUgY29sdW1ucyBpZiBuZWVkZWQgYW5kIHJlLXVwbG9hZCdcbiAgICAgIF0sXG4gICAgICBkZXRhaWxzOiBuYW1lVmFyaWF0aW9uQ29sdW1uc1xuICAgIH0pXG4gIH1cblxuICAvLyBDaGVjayBmb3IgdW5leHBlY3RlZCBjb2x1bW5zIHRoYXQgbWlnaHQgaW5kaWNhdGUgd3JvbmcgcGxhdGZvcm1cbiAgY29uc3QgdW5leHBlY3RlZENvbHVtbnMgPSBjbGVhbkhlYWRlcnMuZmlsdGVyKGhlYWRlciA9PiBcbiAgICAhc2NoZW1hLnJlcXVpcmVkLnNvbWUocmVxID0+IG5vcm1hbGl6ZUNvbHVtbk5hbWUoaGVhZGVyKSA9PT0gbm9ybWFsaXplQ29sdW1uTmFtZShyZXEpKVxuICApXG4gIFxuICBpZiAodW5leHBlY3RlZENvbHVtbnMubGVuZ3RoID4gMCAmJiB1bmV4cGVjdGVkQ29sdW1ucy5sZW5ndGggPiAzKSB7XG4gICAgd2FybmluZ3MucHVzaCh7XG4gICAgICB0eXBlOiAndW5leHBlY3RlZF9jb2x1bW5zJyxcbiAgICAgIG1lc3NhZ2U6IGBNYW55IHVuZXhwZWN0ZWQgY29sdW1ucyBmb3VuZCAoJHt1bmV4cGVjdGVkQ29sdW1ucy5sZW5ndGh9KS4gVmVyaWZ5IHRoaXMgaXMgdGhlIGNvcnJlY3QgcGxhdGZvcm0uYCxcbiAgICAgIGRldGFpbHM6IHsgdW5leHBlY3RlZENvbHVtbnM6IHVuZXhwZWN0ZWRDb2x1bW5zLnNsaWNlKDAsIDUpIH1cbiAgICB9KVxuICB9XG5cbiAgLy8gQ2hlY2sgZm9yIGNvbW1vbiBDU1YgZm9ybWF0dGluZyBpc3N1ZXNcbiAgaWYgKGhlYWRlcnMuc29tZShoID0+IGguaW5jbHVkZXMoJ1xcdWZlZmYnKSkpIHtcbiAgICB3YXJuaW5ncy5wdXNoKHtcbiAgICAgIHR5cGU6ICdib21fZGV0ZWN0ZWQnLFxuICAgICAgbWVzc2FnZTogJ0JPTSAoQnl0ZSBPcmRlciBNYXJrKSBkZXRlY3RlZCBpbiBDU1YgaGVhZGVycy4gVGhpcyBtYXkgY2F1c2UgcGFyc2luZyBpc3N1ZXMuJyxcbiAgICAgIGRldGFpbHM6IHsgbm90ZTogJ1NhdmUgZmlsZSBhcyBVVEYtOCB3aXRob3V0IEJPTScgfVxuICAgIH0pXG4gIH1cblxuICAvLyBDaGVjayBmb3IgZW1wdHkgaGVhZGVyc1xuICBjb25zdCBlbXB0eUhlYWRlcnMgPSBjbGVhbkhlYWRlcnMuZmlsdGVyKGggPT4gIWggfHwgaC50cmltKCkgPT09ICcnKVxuICBpZiAoZW1wdHlIZWFkZXJzLmxlbmd0aCA+IDApIHtcbiAgICBlcnJvcnMucHVzaCh7XG4gICAgICB0eXBlOiAnZW1wdHlfaGVhZGVycycsXG4gICAgICBtZXNzYWdlOiBgRm91bmQgJHtlbXB0eUhlYWRlcnMubGVuZ3RofSBlbXB0eSBjb2x1bW4gaGVhZGVycy4gQWxsIGNvbHVtbnMgbXVzdCBoYXZlIG5hbWVzLmAsXG4gICAgICBjb2x1bW5zOiBbYCR7ZW1wdHlIZWFkZXJzLmxlbmd0aH0gZW1wdHkgaGVhZGVyc2BdXG4gICAgfSlcbiAgfVxuXG4gIC8vIENoZWNrIGZvciBkdXBsaWNhdGUgaGVhZGVyc1xuICBjb25zdCBkdXBsaWNhdGVIZWFkZXJzID0gY2xlYW5IZWFkZXJzLmZpbHRlcigoaGVhZGVyLCBpbmRleCkgPT4gXG4gICAgY2xlYW5IZWFkZXJzLmluZGV4T2YoaGVhZGVyKSAhPT0gaW5kZXhcbiAgKVxuICBpZiAoZHVwbGljYXRlSGVhZGVycy5sZW5ndGggPiAwKSB7XG4gICAgZXJyb3JzLnB1c2goe1xuICAgICAgdHlwZTogJ2R1cGxpY2F0ZV9oZWFkZXJzJyxcbiAgICAgIG1lc3NhZ2U6IGBEdXBsaWNhdGUgY29sdW1uIGhlYWRlcnMgZm91bmQ6ICR7Wy4uLm5ldyBTZXQoZHVwbGljYXRlSGVhZGVycyldLmpvaW4oJywgJyl9YCxcbiAgICAgIGNvbHVtbnM6IGR1cGxpY2F0ZUhlYWRlcnNcbiAgICB9KVxuICB9XG5cbiAgLy8gVmFsaWRhdGUgZGF0ZSBmb3JtYXRzIChTVFJJQ1QgLSBtdXN0IGJlIFlZWVktTU0tREQpXG4gIGNvbnN0IGRhdGVDb2x1bW4gPSBmaW5kQ29sdW1uQnlOYW1lKGNsZWFuSGVhZGVycywgc2NoZW1hLmRhdGVDb2x1bW4pXG4gIGlmIChkYXRlQ29sdW1uKSB7XG4gICAgY29uc3QgZGF0ZVZhbGlkYXRpb24gPSB2YWxpZGF0ZURhdGVGb3JtYXRzKGRhdGEsIGRhdGVDb2x1bW4pXG4gICAgXG4gICAgLy8gQ2hlY2sgZm9yIHdyb25nIGRhdGUgZm9ybWF0cyAtIG1ha2UgdGhpcyBhbiBFUlJPUiBub3Qgd2FybmluZ1xuICAgIGNvbnN0IGFsbG93ZWRGb3JtYXRzID0gc2NoZW1hLmFjY2VwdGVkRm9ybWF0c1xuICAgIGNvbnN0IG5vblN0YW5kYXJkRm9ybWF0cyA9IGRhdGVWYWxpZGF0aW9uLmRldGVjdGVkRm9ybWF0cy5maWx0ZXIoZm9ybWF0ID0+ICFhbGxvd2VkRm9ybWF0cy5pbmNsdWRlcyhmb3JtYXQpKVxuICAgIGlmIChub25TdGFuZGFyZEZvcm1hdHMubGVuZ3RoID4gMCkge1xuICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICB0eXBlOiAnaW52YWxpZF9kYXRlX2Zvcm1hdCcsXG4gICAgICAgIG1lc3NhZ2U6IGBEYXRlIGNvbHVtbiAnJHtkYXRlQ29sdW1ufScgbXVzdCB1c2UgJHtzY2hlbWEucmVxdWlyZWREYXRlRm9ybWF0fSBmb3JtYXQuIEZvdW5kOiAke25vblN0YW5kYXJkRm9ybWF0cy5qb2luKCcsICcpfWAsXG4gICAgICAgIGhvd1RvRml4OiBgQ29udmVydCBhbGwgZGF0ZXMgaW4gJyR7ZGF0ZUNvbHVtbn0nIGNvbHVtbiB0byBZWVlZLU1NLUREIGZvcm1hdGAsXG4gICAgICAgIGV4YW1wbGVzOiBbXG4gICAgICAgICAgJ09wZW4gQ1NWIGluIEV4Y2VsL0dvb2dsZSBTaGVldHMnLFxuICAgICAgICAgICdTZWxlY3QgdGhlIGVudGlyZSBEYXRlIGNvbHVtbicsXG4gICAgICAgICAgJ0Zvcm1hdCBjZWxscyBhcyBDdXN0b206IFlZWVktTU0tREQgKGUuZy4sIDIwMjUtMTEtMTApJyxcbiAgICAgICAgICAnT3IgdXNlIGZpbmQvcmVwbGFjZTogMTAvMTEvMjAyNSDihpIgMjAyNS0xMS0xMCcsXG4gICAgICAgICAgJ1NhdmUgYXMgQ1NWIGFuZCByZS11cGxvYWQnXG4gICAgICAgIF0sXG4gICAgICAgIGNvbHVtbnM6IFtkYXRlQ29sdW1uXVxuICAgICAgfSlcbiAgICB9XG4gICAgXG4gICAgLy8gQ2hlY2sgZm9yIGludmFsaWQvdW5wYXJzZWFibGUgZGF0ZXNcbiAgICBpZiAoZGF0ZVZhbGlkYXRpb24uaW52YWxpZERhdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2ludmFsaWRfZGF0ZV92YWx1ZXMnLFxuICAgICAgICBtZXNzYWdlOiBgSW52YWxpZCBkYXRlIHZhbHVlcyBmb3VuZCBpbiAnJHtkYXRlQ29sdW1ufSc6ICR7ZGF0ZVZhbGlkYXRpb24uaW52YWxpZERhdGVzLnNsaWNlKDAsIDMpLm1hcChkID0+IGQudmFsdWUpLmpvaW4oJywgJyl9YCxcbiAgICAgICAgY29sdW1uczogW2RhdGVDb2x1bW5dXG4gICAgICB9KVxuICAgIH1cbiAgICBcbiAgICAvLyBPbmx5IGFkZCB3YXJuaW5ncyBmb3IgbWlub3IgaXNzdWVzIGlmIG5vIGVycm9yc1xuICAgIGlmIChub25TdGFuZGFyZEZvcm1hdHMubGVuZ3RoID09PSAwICYmIGRhdGVWYWxpZGF0aW9uLmludmFsaWREYXRlcy5sZW5ndGggPT09IDAgJiYgZGF0ZVZhbGlkYXRpb24uZGV0ZWN0ZWRGb3JtYXRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHdhcm5pbmdzLnB1c2goe1xuICAgICAgICB0eXBlOiAnZGF0ZV9mb3JtYXRfaW5jb25zaXN0ZW5jeScsXG4gICAgICAgIG1lc3NhZ2U6IGBNdWx0aXBsZSBkYXRlIGZvcm1hdHMgZGV0ZWN0ZWQgaW4gJHtkYXRlQ29sdW1ufWAsXG4gICAgICAgIGRldGFpbHM6IGRhdGVWYWxpZGF0aW9uXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIC8vIFZhbGlkYXRlIG51bWVyaWMgY29sdW1uc1xuICBjb25zdCBudW1lcmljVmFsaWRhdGlvbiA9IHZhbGlkYXRlTnVtZXJpY0NvbHVtbnMocGxhdGZvcm0sIGRhdGEsIGNsZWFuSGVhZGVycylcbiAgd2FybmluZ3MucHVzaCguLi5udW1lcmljVmFsaWRhdGlvbilcblxuICByZXR1cm4ge1xuICAgIGlzVmFsaWQ6IGVycm9ycy5sZW5ndGggPT09IDAsXG4gICAgaGFzRXJyb3JzOiBlcnJvcnMubGVuZ3RoID4gMCxcbiAgICBoYXNXYXJuaW5nczogd2FybmluZ3MubGVuZ3RoID4gMCxcbiAgICBuZWVkc0NvcnJlY3Rpb246IHdhcm5pbmdzLmxlbmd0aCA+IDAsXG4gICAgZXJyb3JzLFxuICAgIHdhcm5pbmdzLFxuICAgIHJvd0NvdW50OiBkYXRhLmxlbmd0aCxcbiAgICBjb2x1bW5Db3VudDogaGVhZGVycy5sZW5ndGgsXG4gICAgZGF0ZVJhbmdlOiBkZXRlY3REYXRlUmFuZ2UoZGF0YSwgZGF0ZUNvbHVtbilcbiAgfVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVDb2x1bW5OYW1lKG5hbWU6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBuYW1lLnRvTG93ZXJDYXNlKCkudHJpbSgpLnJlcGxhY2UoL1teXFx3XS9nLCAnXycpXG59XG5cbmZ1bmN0aW9uIGZpbmRDb2x1bW5CeU5hbWUoaGVhZGVyczogc3RyaW5nW10sIHRhcmdldE5hbWU6IHN0cmluZyk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gIHJldHVybiBoZWFkZXJzLmZpbmQoaGVhZGVyID0+IFxuICAgIG5vcm1hbGl6ZUNvbHVtbk5hbWUoaGVhZGVyKSA9PT0gbm9ybWFsaXplQ29sdW1uTmFtZSh0YXJnZXROYW1lKVxuICApXG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRGF0ZUZvcm1hdHMoZGF0YTogYW55W10sIGRhdGVDb2x1bW46IHN0cmluZyk6IHsgaGFzSXNzdWVzOiBib29sZWFuOyBkZXRlY3RlZEZvcm1hdHM6IHN0cmluZ1tdOyBpbnZhbGlkRGF0ZXM6IGFueVtdOyByZWNvbW1lbmRlZEZvcm1hdDogc3RyaW5nIH0ge1xuICBjb25zdCBmb3JtYXRzID0gbmV3IFNldDxzdHJpbmc+KClcbiAgY29uc3QgaW52YWxpZERhdGVzOiBhbnlbXSA9IFtdXG4gIFxuICBkYXRhLnNsaWNlKDAsIDUwKS5mb3JFYWNoKChyb3csIGluZGV4KSA9PiB7XG4gICAgY29uc3QgZGF0ZVZhbHVlID0gcm93W2RhdGVDb2x1bW5dXG4gICAgaWYgKGRhdGVWYWx1ZSkge1xuICAgICAgY29uc3QgZGV0ZWN0ZWRGb3JtYXQgPSBkZXRlY3REYXRlRm9ybWF0KGRhdGVWYWx1ZSlcbiAgICAgIGlmIChkZXRlY3RlZEZvcm1hdCkge1xuICAgICAgICBmb3JtYXRzLmFkZChkZXRlY3RlZEZvcm1hdClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludmFsaWREYXRlcy5wdXNoKHsgcm93OiBpbmRleCwgdmFsdWU6IGRhdGVWYWx1ZSB9KVxuICAgICAgfVxuICAgIH1cbiAgfSlcblxuICByZXR1cm4ge1xuICAgIGhhc0lzc3VlczogZm9ybWF0cy5zaXplID4gMSB8fCBpbnZhbGlkRGF0ZXMubGVuZ3RoID4gMCxcbiAgICBkZXRlY3RlZEZvcm1hdHM6IEFycmF5LmZyb20oZm9ybWF0cyksXG4gICAgaW52YWxpZERhdGVzLFxuICAgIHJlY29tbWVuZGVkRm9ybWF0OiAnWVlZWS1NTS1ERCdcbiAgfVxufVxuXG5mdW5jdGlvbiBkZXRlY3REYXRlRm9ybWF0KGRhdGVTdHJpbmc6IHN0cmluZyk6IHN0cmluZyB8IG51bGwge1xuICBjb25zdCB0cmltbWVkID0gZGF0ZVN0cmluZy50cmltKClcbiAgXG4gIGNvbnN0IHBhdHRlcm5zID0gW1xuICAgIHsgcmVnZXg6IC9eXFxkezR9LVxcZHsyfS1cXGR7Mn0kLywgZm9ybWF0OiAnWVlZWS1NTS1ERCcgfSxcbiAgICB7IHJlZ2V4OiAvXlxcZHsyfS1cXGR7Mn0tXFxkezR9JC8sIGZvcm1hdDogJ0RELU1NLVlZWVknIH0sXG4gICAgeyByZWdleDogL15cXGR7MSwyfVxcL1xcZHsxLDJ9XFwvXFxkezR9JC8sIGZvcm1hdDogJ0REL01NL1lZWVknIH0sIC8vIE1vcmUgc3BlY2lmaWMgZm9yIHlvdXIgR29vZ2xlIGRhdGFcbiAgICB7IHJlZ2V4OiAvXlxcZHsyfVxcL1xcZHsyfVxcL1xcZHs0fSQvLCBmb3JtYXQ6ICdERC9NTS9ZWVlZJyB9LFxuICAgIHsgcmVnZXg6IC9eXFxkezR9XFwvXFxkezJ9XFwvXFxkezJ9JC8sIGZvcm1hdDogJ1lZWVkvTU0vREQnIH0sXG4gICAgeyByZWdleDogL15cXGR7Mn1cXC5cXGR7Mn1cXC5cXGR7NH0kLywgZm9ybWF0OiAnREQuTU0uWVlZWScgfVxuICBdXG5cbiAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIHBhdHRlcm5zKSB7XG4gICAgaWYgKHBhdHRlcm4ucmVnZXgudGVzdCh0cmltbWVkKSkge1xuICAgICAgcmV0dXJuIHBhdHRlcm4uZm9ybWF0XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsXG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTnVtZXJpY0NvbHVtbnMocGxhdGZvcm06IFBsYXRmb3JtLCBkYXRhOiBhbnlbXSwgaGVhZGVyczogc3RyaW5nW10pOiBWYWxpZGF0aW9uV2FybmluZ1tdIHtcbiAgY29uc3Qgd2FybmluZ3M6IFZhbGlkYXRpb25XYXJuaW5nW10gPSBbXVxuICBjb25zdCBudW1lcmljQ29sdW1ucyA9IGdldE51bWVyaWNDb2x1bW5zKHBsYXRmb3JtLCBoZWFkZXJzKVxuICBcbiAgbnVtZXJpY0NvbHVtbnMuZm9yRWFjaChjb2x1bW4gPT4ge1xuICAgIGNvbnN0IG5vbk51bWVyaWNWYWx1ZXMgPSBkYXRhLnNsaWNlKDAsIDUwKVxuICAgICAgLm1hcCgocm93LCBpbmRleCkgPT4gKHsgaW5kZXgsIHZhbHVlOiByb3dbY29sdW1uXSB9KSlcbiAgICAgIC5maWx0ZXIoaXRlbSA9PiBpdGVtLnZhbHVlICYmIGlzTmFOKHBhcnNlRmxvYXQoaXRlbS52YWx1ZS50b1N0cmluZygpLnJlcGxhY2UoL1ssJV0vZywgJycpKSkpXG4gICAgXG4gICAgaWYgKG5vbk51bWVyaWNWYWx1ZXMubGVuZ3RoID4gMCkge1xuICAgICAgd2FybmluZ3MucHVzaCh7XG4gICAgICAgIHR5cGU6ICdub25fbnVtZXJpY192YWx1ZXMnLFxuICAgICAgICBtZXNzYWdlOiBgTm9uLW51bWVyaWMgdmFsdWVzIGRldGVjdGVkIGluICR7Y29sdW1ufWAsXG4gICAgICAgIGNvbHVtbixcbiAgICAgICAgc2FtcGxlczogbm9uTnVtZXJpY1ZhbHVlcy5zbGljZSgwLCA1KVxuICAgICAgfSlcbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIHdhcm5pbmdzXG59XG5cbmZ1bmN0aW9uIGdldE51bWVyaWNDb2x1bW5zKHBsYXRmb3JtOiBQbGF0Zm9ybSwgaGVhZGVyczogc3RyaW5nW10pOiBzdHJpbmdbXSB7XG4gIGNvbnN0IG51bWVyaWNQYXR0ZXJuczogUmVjb3JkPFBsYXRmb3JtLCBzdHJpbmdbXT4gPSB7XG4gICAgbWV0YTogWydhbW91bnQnLCAnc3BlbnQnLCAnY29zdCcsICdjdHInLCAnY3BtJ10sXG4gICAgZ29vZ2xlOiBbJ2Nvc3QnLCAnY3RyJywgJ2NwbSddLFxuICAgIHNob3BpZnk6IFsndmlzaXRvcnMnLCAnc2Vzc2lvbnMnLCAnY2hlY2tvdXQnLCAnZHVyYXRpb24nLCAncGFnZXZpZXdzJ11cbiAgfVxuXG4gIHJldHVybiBoZWFkZXJzLmZpbHRlcihoZWFkZXIgPT4ge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVDb2x1bW5OYW1lKGhlYWRlcilcbiAgICByZXR1cm4gbnVtZXJpY1BhdHRlcm5zW3BsYXRmb3JtXS5zb21lKHBhdHRlcm4gPT4gbm9ybWFsaXplZC5pbmNsdWRlcyhwYXR0ZXJuKSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gZGV0ZWN0RGF0ZVJhbmdlKGRhdGE6IGFueVtdLCBkYXRlQ29sdW1uOiBzdHJpbmcgfCB1bmRlZmluZWQpOiBEYXRlUmFuZ2UgfCBudWxsIHtcbiAgaWYgKCFkYXRlQ29sdW1uIHx8IGRhdGEubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbFxuICBcbiAgY29uc3QgZGF0ZXMgPSBkYXRhXG4gICAgLm1hcChyb3cgPT4gcm93W2RhdGVDb2x1bW5dKVxuICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAubWFwKGRhdGVTdHIgPT4gbmV3IERhdGUoZGF0ZVN0cikpXG4gICAgLmZpbHRlcihkYXRlID0+ICFpc05hTihkYXRlLmdldFRpbWUoKSkpXG4gICAgLnNvcnQoKVxuXG4gIGlmIChkYXRlcy5sZW5ndGggPT09IDApIHJldHVybiBudWxsXG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydDogZGF0ZXNbMF0udG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdLFxuICAgIGVuZDogZGF0ZXNbZGF0ZXMubGVuZ3RoIC0gMV0udG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdLFxuICAgIHRvdGFsRGF5czogTWF0aC5jZWlsKChkYXRlc1tkYXRlcy5sZW5ndGggLSAxXS5nZXRUaW1lKCkgLSBkYXRlc1swXS5nZXRUaW1lKCkpIC8gKDEwMDAgKiA2MCAqIDYwICogMjQpKSArIDFcbiAgfVxufSJdLCJuYW1lcyI6WyJQYXBhIiwiUExBVEZPUk1fU0NIRU1BUyIsIm1ldGEiLCJyZXF1aXJlZCIsImRhdGVDb2x1bW4iLCJyZXF1aXJlZERhdGVGb3JtYXQiLCJhY2NlcHRlZEZvcm1hdHMiLCJvcmRlck1hdHRlcnMiLCJnb29nbGUiLCJzaG9waWZ5IiwidmFsaWRhdGVDU1YiLCJwbGF0Zm9ybSIsImZpbGUiLCJQcm9taXNlIiwicmVzb2x2ZSIsInBhcnNlIiwiaGVhZGVyIiwicHJldmlldyIsImNvbXBsZXRlIiwicmVzdWx0cyIsInZhbGlkYXRpb24iLCJwZXJmb3JtVmFsaWRhdGlvbiIsImRhdGEiLCJmaWVsZHMiLCJlcnJvciIsImlzVmFsaWQiLCJoYXNFcnJvcnMiLCJoYXNXYXJuaW5ncyIsIm5lZWRzQ29ycmVjdGlvbiIsImVycm9ycyIsInR5cGUiLCJtZXNzYWdlIiwid2FybmluZ3MiLCJyb3dDb3VudCIsImNvbHVtbkNvdW50IiwiZGF0ZVJhbmdlIiwiaGVhZGVycyIsInNjaGVtYSIsImNsZWFuSGVhZGVycyIsIm1hcCIsImgiLCJyZXBsYWNlIiwidHJpbSIsImNvbHVtbk1hcHBpbmdJc3N1ZXMiLCJyZXF1aXJlZENvbCIsImV4YWN0TWF0Y2giLCJmaW5kIiwiY2FzZUluc2Vuc2l0aXZlTWF0Y2giLCJ0b0xvd2VyQ2FzZSIsInB1c2giLCJmb3VuZCIsImlzc3VlIiwiZnV6enlNYXRjaCIsIm5vcm1hbGl6ZUNvbHVtbk5hbWUiLCJtaXNzaW5nQ29sdW1ucyIsImZpbHRlciIsImNhc2VNaXNtYXRjaENvbHVtbnMiLCJuYW1lVmFyaWF0aW9uQ29sdW1ucyIsImxlbmd0aCIsImMiLCJqb2luIiwiaG93VG9GaXgiLCJleGFtcGxlcyIsImNvbHVtbnMiLCJkZXRhaWxzIiwidW5leHBlY3RlZENvbHVtbnMiLCJzb21lIiwicmVxIiwic2xpY2UiLCJpbmNsdWRlcyIsIm5vdGUiLCJlbXB0eUhlYWRlcnMiLCJkdXBsaWNhdGVIZWFkZXJzIiwiaW5kZXgiLCJpbmRleE9mIiwiU2V0IiwiZmluZENvbHVtbkJ5TmFtZSIsImRhdGVWYWxpZGF0aW9uIiwidmFsaWRhdGVEYXRlRm9ybWF0cyIsImFsbG93ZWRGb3JtYXRzIiwibm9uU3RhbmRhcmRGb3JtYXRzIiwiZGV0ZWN0ZWRGb3JtYXRzIiwiZm9ybWF0IiwiaW52YWxpZERhdGVzIiwiZCIsInZhbHVlIiwibnVtZXJpY1ZhbGlkYXRpb24iLCJ2YWxpZGF0ZU51bWVyaWNDb2x1bW5zIiwiZGV0ZWN0RGF0ZVJhbmdlIiwibmFtZSIsInRhcmdldE5hbWUiLCJmb3JtYXRzIiwiZm9yRWFjaCIsInJvdyIsImRhdGVWYWx1ZSIsImRldGVjdGVkRm9ybWF0IiwiZGV0ZWN0RGF0ZUZvcm1hdCIsImFkZCIsImhhc0lzc3VlcyIsInNpemUiLCJBcnJheSIsImZyb20iLCJyZWNvbW1lbmRlZEZvcm1hdCIsImRhdGVTdHJpbmciLCJ0cmltbWVkIiwicGF0dGVybnMiLCJyZWdleCIsInBhdHRlcm4iLCJ0ZXN0IiwibnVtZXJpY0NvbHVtbnMiLCJnZXROdW1lcmljQ29sdW1ucyIsImNvbHVtbiIsIm5vbk51bWVyaWNWYWx1ZXMiLCJpdGVtIiwiaXNOYU4iLCJwYXJzZUZsb2F0IiwidG9TdHJpbmciLCJzYW1wbGVzIiwibnVtZXJpY1BhdHRlcm5zIiwibm9ybWFsaXplZCIsImRhdGVzIiwiQm9vbGVhbiIsImRhdGVTdHIiLCJEYXRlIiwiZGF0ZSIsImdldFRpbWUiLCJzb3J0Iiwic3RhcnQiLCJ0b0lTT1N0cmluZyIsInNwbGl0IiwiZW5kIiwidG90YWxEYXlzIiwiTWF0aCIsImNlaWwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/validators.ts\n"));

/***/ })

});