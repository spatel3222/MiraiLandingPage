"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/upload",{

/***/ "./lib/validators.ts":
/*!***************************!*\
  !*** ./lib/validators.ts ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PLATFORM_SCHEMAS: function() { return /* binding */ PLATFORM_SCHEMAS; },\n/* harmony export */   validateCSV: function() { return /* binding */ validateCSV; }\n/* harmony export */ });\n/* harmony import */ var papaparse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! papaparse */ \"./node_modules/papaparse/papaparse.min.js\");\n/* harmony import */ var papaparse__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(papaparse__WEBPACK_IMPORTED_MODULE_0__);\n\nconst PLATFORM_SCHEMAS = {\n    meta: {\n        required: [\n            \"Day\",\n            \"Campaign name\",\n            \"Ad set name\",\n            \"Ad name\",\n            \"Amount spent (INR)\",\n            \"CTR (link click-through rate)\",\n            \"CPM (cost per 1,000 impressions)\"\n        ],\n        dateColumn: \"Day\",\n        requiredDateFormat: \"YYYY-MM-DD\",\n        acceptedFormats: [\n            \"YYYY-MM-DD\"\n        ] // Only accept standard format\n    },\n    google: {\n        required: [\n            \"Day\",\n            \"Campaign\",\n            \"Cost\",\n            \"CTR\",\n            \"Avg. CPM\"\n        ],\n        dateColumn: \"Day\",\n        requiredDateFormat: \"YYYY-MM-DD\",\n        acceptedFormats: [\n            \"YYYY-MM-DD\"\n        ] // Only accept standard format\n    },\n    shopify: {\n        required: [\n            \"Day\",\n            \"UTM campaign\",\n            \"UTM term\",\n            \"UTM content\",\n            \"Online store visitors\",\n            \"Sessions that completed checkout\"\n        ],\n        dateColumn: \"Day\",\n        requiredDateFormat: \"YYYY-MM-DD\",\n        acceptedFormats: [\n            \"YYYY-MM-DD\"\n        ] // Only accept standard format\n    }\n};\nasync function validateCSV(platform, file) {\n    return new Promise((resolve)=>{\n        papaparse__WEBPACK_IMPORTED_MODULE_0___default().parse(file, {\n            header: true,\n            preview: 100,\n            complete: (results)=>{\n                const validation = performValidation(platform, results.data, results.meta.fields || []);\n                resolve(validation);\n            },\n            error: (error)=>{\n                resolve({\n                    isValid: false,\n                    hasErrors: true,\n                    hasWarnings: false,\n                    needsCorrection: false,\n                    errors: [\n                        {\n                            type: \"parse_error\",\n                            message: error.message\n                        }\n                    ],\n                    warnings: [],\n                    rowCount: 0,\n                    columnCount: 0,\n                    dateRange: null\n                });\n            }\n        });\n    });\n}\nfunction performValidation(platform, data, headers) {\n    const schema = PLATFORM_SCHEMAS[platform];\n    const errors = [];\n    const warnings = [];\n    // Clean headers (remove BOM, trim whitespace)\n    const cleanHeaders = headers.map((h)=>h.replace(/^\\ufeff/, \"\").trim());\n    // Check for case-sensitive column matching issues\n    const columnMappingIssues = [];\n    for (const requiredCol of schema.required){\n        // Try exact match first\n        const exactMatch = cleanHeaders.find((h)=>h === requiredCol);\n        if (exactMatch) continue;\n        // Try case-insensitive match\n        const caseInsensitiveMatch = cleanHeaders.find((h)=>h.toLowerCase() === requiredCol.toLowerCase());\n        if (caseInsensitiveMatch) {\n            columnMappingIssues.push({\n                required: requiredCol,\n                found: caseInsensitiveMatch,\n                issue: \"case_mismatch\"\n            });\n        } else {\n            // Try fuzzy match (similar names)\n            const fuzzyMatch = cleanHeaders.find((h)=>normalizeColumnName(h) === normalizeColumnName(requiredCol));\n            if (fuzzyMatch) {\n                columnMappingIssues.push({\n                    required: requiredCol,\n                    found: fuzzyMatch,\n                    issue: \"name_variation\"\n                });\n            } else {\n                columnMappingIssues.push({\n                    required: requiredCol,\n                    issue: \"missing\"\n                });\n            }\n        }\n    }\n    // Report column issues\n    const missingColumns = columnMappingIssues.filter((issue)=>issue.issue === \"missing\");\n    const caseMismatchColumns = columnMappingIssues.filter((issue)=>issue.issue === \"case_mismatch\");\n    const nameVariationColumns = columnMappingIssues.filter((issue)=>issue.issue === \"name_variation\");\n    if (missingColumns.length > 0) {\n        errors.push({\n            type: \"missing_columns\",\n            message: \"Missing required columns: \".concat(missingColumns.map((c)=>c.required).join(\", \")),\n            columns: missingColumns.map((c)=>c.required)\n        });\n    }\n    if (caseMismatchColumns.length > 0) {\n        errors.push({\n            type: \"column_case_mismatch\",\n            message: \"Column case mismatch found: \".concat(caseMismatchColumns.map((c)=>'\"'.concat(c.found, '\" should be \"').concat(c.required, '\"')).join(\", \")),\n            columns: caseMismatchColumns.map((c)=>c.required)\n        });\n    }\n    if (nameVariationColumns.length > 0) {\n        warnings.push({\n            type: \"column_name_variations\",\n            message: \"Column name variations detected: \".concat(nameVariationColumns.map((c)=>'\"'.concat(c.found, '\" might be \"').concat(c.required, '\"')).join(\", \")),\n            details: nameVariationColumns\n        });\n    }\n    // Check for unexpected columns that might indicate wrong platform\n    const unexpectedColumns = cleanHeaders.filter((header)=>!schema.required.some((req)=>normalizeColumnName(header) === normalizeColumnName(req)));\n    if (unexpectedColumns.length > 0 && unexpectedColumns.length > 3) {\n        warnings.push({\n            type: \"unexpected_columns\",\n            message: \"Many unexpected columns found (\".concat(unexpectedColumns.length, \"). Verify this is the correct platform.\"),\n            details: {\n                unexpectedColumns: unexpectedColumns.slice(0, 5)\n            }\n        });\n    }\n    // Validate date formats (STRICT - must be YYYY-MM-DD)\n    const dateColumn = findColumnByName(cleanHeaders, schema.dateColumn);\n    if (dateColumn) {\n        const dateValidation = validateDateFormats(data, dateColumn);\n        // Check for wrong date formats - make this an ERROR not warning\n        const allowedFormats = schema.acceptedFormats;\n        const nonStandardFormats = dateValidation.detectedFormats.filter((format)=>!allowedFormats.includes(format));\n        if (nonStandardFormats.length > 0) {\n            errors.push({\n                type: \"invalid_date_format\",\n                message: \"Date column '\".concat(dateColumn, \"' must use \").concat(schema.requiredDateFormat, \" format. Found: \").concat(nonStandardFormats.join(\", \"), \". Example: 2025-11-10\"),\n                columns: [\n                    dateColumn\n                ]\n            });\n        }\n        // Check for invalid/unparseable dates\n        if (dateValidation.invalidDates.length > 0) {\n            errors.push({\n                type: \"invalid_date_values\",\n                message: \"Invalid date values found in '\".concat(dateColumn, \"': \").concat(dateValidation.invalidDates.slice(0, 3).map((d)=>d.value).join(\", \")),\n                columns: [\n                    dateColumn\n                ]\n            });\n        }\n        // Only add warnings for minor issues if no errors\n        if (nonStandardFormats.length === 0 && dateValidation.invalidDates.length === 0 && dateValidation.detectedFormats.length > 1) {\n            warnings.push({\n                type: \"date_format_inconsistency\",\n                message: \"Multiple date formats detected in \".concat(dateColumn),\n                details: dateValidation\n            });\n        }\n    }\n    // Validate numeric columns\n    const numericValidation = validateNumericColumns(platform, data, cleanHeaders);\n    warnings.push(...numericValidation);\n    return {\n        isValid: errors.length === 0,\n        hasErrors: errors.length > 0,\n        hasWarnings: warnings.length > 0,\n        needsCorrection: warnings.length > 0,\n        errors,\n        warnings,\n        rowCount: data.length,\n        columnCount: headers.length,\n        dateRange: detectDateRange(data, dateColumn)\n    };\n}\nfunction normalizeColumnName(name) {\n    return name.toLowerCase().trim().replace(/[^\\w]/g, \"_\");\n}\nfunction findColumnByName(headers, targetName) {\n    return headers.find((header)=>normalizeColumnName(header) === normalizeColumnName(targetName));\n}\nfunction validateDateFormats(data, dateColumn) {\n    const formats = new Set();\n    const invalidDates = [];\n    data.slice(0, 50).forEach((row, index)=>{\n        const dateValue = row[dateColumn];\n        if (dateValue) {\n            const detectedFormat = detectDateFormat(dateValue);\n            if (detectedFormat) {\n                formats.add(detectedFormat);\n            } else {\n                invalidDates.push({\n                    row: index,\n                    value: dateValue\n                });\n            }\n        }\n    });\n    return {\n        hasIssues: formats.size > 1 || invalidDates.length > 0,\n        detectedFormats: Array.from(formats),\n        invalidDates,\n        recommendedFormat: \"YYYY-MM-DD\"\n    };\n}\nfunction detectDateFormat(dateString) {\n    const trimmed = dateString.trim();\n    const patterns = [\n        {\n            regex: /^\\d{4}-\\d{2}-\\d{2}$/,\n            format: \"YYYY-MM-DD\"\n        },\n        {\n            regex: /^\\d{2}-\\d{2}-\\d{4}$/,\n            format: \"DD-MM-YYYY\"\n        },\n        {\n            regex: /^\\d{1,2}\\/\\d{1,2}\\/\\d{4}$/,\n            format: \"DD/MM/YYYY\"\n        },\n        {\n            regex: /^\\d{2}\\/\\d{2}\\/\\d{4}$/,\n            format: \"DD/MM/YYYY\"\n        },\n        {\n            regex: /^\\d{4}\\/\\d{2}\\/\\d{2}$/,\n            format: \"YYYY/MM/DD\"\n        },\n        {\n            regex: /^\\d{2}\\.\\d{2}\\.\\d{4}$/,\n            format: \"DD.MM.YYYY\"\n        }\n    ];\n    for (const pattern of patterns){\n        if (pattern.regex.test(trimmed)) {\n            return pattern.format;\n        }\n    }\n    return null;\n}\nfunction validateNumericColumns(platform, data, headers) {\n    const warnings = [];\n    const numericColumns = getNumericColumns(platform, headers);\n    numericColumns.forEach((column)=>{\n        const nonNumericValues = data.slice(0, 50).map((row, index)=>({\n                index,\n                value: row[column]\n            })).filter((item)=>item.value && isNaN(parseFloat(item.value.toString().replace(/[,%]/g, \"\"))));\n        if (nonNumericValues.length > 0) {\n            warnings.push({\n                type: \"non_numeric_values\",\n                message: \"Non-numeric values detected in \".concat(column),\n                column,\n                samples: nonNumericValues.slice(0, 5)\n            });\n        }\n    });\n    return warnings;\n}\nfunction getNumericColumns(platform, headers) {\n    const numericPatterns = {\n        meta: [\n            \"amount\",\n            \"spent\",\n            \"cost\",\n            \"ctr\",\n            \"cpm\"\n        ],\n        google: [\n            \"cost\",\n            \"ctr\",\n            \"cpm\"\n        ],\n        shopify: [\n            \"visitors\",\n            \"sessions\",\n            \"checkout\",\n            \"duration\",\n            \"pageviews\"\n        ]\n    };\n    return headers.filter((header)=>{\n        const normalized = normalizeColumnName(header);\n        return numericPatterns[platform].some((pattern)=>normalized.includes(pattern));\n    });\n}\nfunction detectDateRange(data, dateColumn) {\n    if (!dateColumn || data.length === 0) return null;\n    const dates = data.map((row)=>row[dateColumn]).filter(Boolean).map((dateStr)=>new Date(dateStr)).filter((date)=>!isNaN(date.getTime())).sort();\n    if (dates.length === 0) return null;\n    return {\n        start: dates[0].toISOString().split(\"T\")[0],\n        end: dates[dates.length - 1].toISOString().split(\"T\")[0],\n        totalDays: Math.ceil((dates[dates.length - 1].getTime() - dates[0].getTime()) / (1000 * 60 * 60 * 24)) + 1\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFnQjFELElBQVcsRUFBRWpCLFVBQThCO0lBQ2xFLElBQUksQ0FBQ0EsY0FBY2lCLEtBQUtvQyxNQUFNLEtBQUssR0FBRyxPQUFPO0lBRTdDLE1BQU13RCxRQUFRNUYsS0FDWGlCLEdBQUcsQ0FBQytDLENBQUFBLE1BQU9BLEdBQUcsQ0FBQ2pGLFdBQVcsRUFDMUJrRCxNQUFNLENBQUM0RCxTQUNQNUUsR0FBRyxDQUFDNkUsQ0FBQUEsVUFBVyxJQUFJQyxLQUFLRCxVQUN4QjdELE1BQU0sQ0FBQytELENBQUFBLE9BQVEsQ0FBQ1YsTUFBTVUsS0FBS0MsT0FBTyxLQUNsQ0MsSUFBSTtJQUVQLElBQUlOLE1BQU14RCxNQUFNLEtBQUssR0FBRyxPQUFPO0lBRS9CLE9BQU87UUFDTCtELE9BQU9QLEtBQUssQ0FBQyxFQUFFLENBQUNRLFdBQVcsR0FBR0MsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFO1FBQzNDQyxLQUFLVixLQUFLLENBQUNBLE1BQU14RCxNQUFNLEdBQUcsRUFBRSxDQUFDZ0UsV0FBVyxHQUFHQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7UUFDeERFLFdBQVdDLEtBQUtDLElBQUksQ0FBQyxDQUFDYixLQUFLLENBQUNBLE1BQU14RCxNQUFNLEdBQUcsRUFBRSxDQUFDNkQsT0FBTyxLQUFLTCxLQUFLLENBQUMsRUFBRSxDQUFDSyxPQUFPLEVBQUMsSUFBTSxRQUFPLEtBQUssS0FBSyxFQUFDLEtBQU07SUFDM0c7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvdmFsaWRhdG9ycy50cz81NmIwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBQYXBhIGZyb20gJ3BhcGFwYXJzZSdcbmltcG9ydCB7IFBsYXRmb3JtIH0gZnJvbSAnLi9zdXBhYmFzZSdcblxuZXhwb3J0IGludGVyZmFjZSBWYWxpZGF0aW9uUmVzdWx0IHtcbiAgaXNWYWxpZDogYm9vbGVhblxuICBoYXNFcnJvcnM6IGJvb2xlYW5cbiAgaGFzV2FybmluZ3M6IGJvb2xlYW5cbiAgbmVlZHNDb3JyZWN0aW9uOiBib29sZWFuXG4gIGVycm9yczogVmFsaWRhdGlvbkVycm9yW11cbiAgd2FybmluZ3M6IFZhbGlkYXRpb25XYXJuaW5nW11cbiAgcm93Q291bnQ6IG51bWJlclxuICBjb2x1bW5Db3VudDogbnVtYmVyXG4gIGRhdGVSYW5nZTogRGF0ZVJhbmdlIHwgbnVsbFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFZhbGlkYXRpb25FcnJvciB7XG4gIHR5cGU6IHN0cmluZ1xuICBtZXNzYWdlOiBzdHJpbmdcbiAgY29sdW1ucz86IHN0cmluZ1tdXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmFsaWRhdGlvbldhcm5pbmcge1xuICB0eXBlOiBzdHJpbmdcbiAgbWVzc2FnZTogc3RyaW5nXG4gIGNvbHVtbj86IHN0cmluZ1xuICBzYW1wbGVzPzogYW55W11cbiAgZGV0YWlscz86IGFueVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIERhdGVSYW5nZSB7XG4gIHN0YXJ0OiBzdHJpbmdcbiAgZW5kOiBzdHJpbmdcbiAgdG90YWxEYXlzOiBudW1iZXJcbn1cblxuZXhwb3J0IGNvbnN0IFBMQVRGT1JNX1NDSEVNQVM6IFJlY29yZDxQbGF0Zm9ybSwge1xuICByZXF1aXJlZDogc3RyaW5nW11cbiAgZGF0ZUNvbHVtbjogc3RyaW5nXG4gIHJlcXVpcmVkRGF0ZUZvcm1hdDogc3RyaW5nXG4gIGFjY2VwdGVkRm9ybWF0czogc3RyaW5nW11cbiAgb3JkZXJNYXR0ZXJzOiBib29sZWFuXG4gIGV4cGVjdGVkT3JkZXI/OiBzdHJpbmdbXVxufT4gPSB7XG4gIG1ldGE6IHtcbiAgICByZXF1aXJlZDogW1xuICAgICAgJ0RheScsXG4gICAgICAnQ2FtcGFpZ24gbmFtZScsXG4gICAgICAnQWQgc2V0IG5hbWUnLCBcbiAgICAgICdBZCBuYW1lJyxcbiAgICAgICdBbW91bnQgc3BlbnQgKElOUiknLFxuICAgICAgJ0NUUiAobGluayBjbGljay10aHJvdWdoIHJhdGUpJyxcbiAgICAgICdDUE0gKGNvc3QgcGVyIDEsMDAwIGltcHJlc3Npb25zKSdcbiAgICBdLFxuICAgIGRhdGVDb2x1bW46ICdEYXknLFxuICAgIHJlcXVpcmVkRGF0ZUZvcm1hdDogJ1lZWVktTU0tREQnLFxuICAgIGFjY2VwdGVkRm9ybWF0czogWydZWVlZLU1NLUREJ10gLy8gT25seSBhY2NlcHQgc3RhbmRhcmQgZm9ybWF0XG4gIH0sXG4gIGdvb2dsZToge1xuICAgIHJlcXVpcmVkOiBbXG4gICAgICAnRGF5JyxcbiAgICAgICdDYW1wYWlnbicsXG4gICAgICAnQ29zdCcsXG4gICAgICAnQ1RSJyxcbiAgICAgICdBdmcuIENQTSdcbiAgICBdLFxuICAgIGRhdGVDb2x1bW46ICdEYXknLFxuICAgIHJlcXVpcmVkRGF0ZUZvcm1hdDogJ1lZWVktTU0tREQnLFxuICAgIGFjY2VwdGVkRm9ybWF0czogWydZWVlZLU1NLUREJ10gLy8gT25seSBhY2NlcHQgc3RhbmRhcmQgZm9ybWF0XG4gIH0sXG4gIHNob3BpZnk6IHtcbiAgICByZXF1aXJlZDogW1xuICAgICAgJ0RheScsXG4gICAgICAnVVRNIGNhbXBhaWduJyxcbiAgICAgICdVVE0gdGVybScsXG4gICAgICAnVVRNIGNvbnRlbnQnLFxuICAgICAgJ09ubGluZSBzdG9yZSB2aXNpdG9ycycsXG4gICAgICAnU2Vzc2lvbnMgdGhhdCBjb21wbGV0ZWQgY2hlY2tvdXQnXG4gICAgXSxcbiAgICBkYXRlQ29sdW1uOiAnRGF5JyxcbiAgICByZXF1aXJlZERhdGVGb3JtYXQ6ICdZWVlZLU1NLUREJyxcbiAgICBhY2NlcHRlZEZvcm1hdHM6IFsnWVlZWS1NTS1ERCddIC8vIE9ubHkgYWNjZXB0IHN0YW5kYXJkIGZvcm1hdFxuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB2YWxpZGF0ZUNTVihwbGF0Zm9ybTogUGxhdGZvcm0sIGZpbGU6IEZpbGUpOiBQcm9taXNlPFZhbGlkYXRpb25SZXN1bHQ+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgUGFwYS5wYXJzZShmaWxlLCB7XG4gICAgICBoZWFkZXI6IHRydWUsXG4gICAgICBwcmV2aWV3OiAxMDAsXG4gICAgICBjb21wbGV0ZTogKHJlc3VsdHMpID0+IHtcbiAgICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IHBlcmZvcm1WYWxpZGF0aW9uKHBsYXRmb3JtLCByZXN1bHRzLmRhdGEsIHJlc3VsdHMubWV0YS5maWVsZHMgfHwgW10pXG4gICAgICAgIHJlc29sdmUodmFsaWRhdGlvbilcbiAgICAgIH0sXG4gICAgICBlcnJvcjogKGVycm9yKSA9PiB7XG4gICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgICAgIGhhc0Vycm9yczogdHJ1ZSxcbiAgICAgICAgICBoYXNXYXJuaW5nczogZmFsc2UsXG4gICAgICAgICAgbmVlZHNDb3JyZWN0aW9uOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcnM6IFt7IHR5cGU6ICdwYXJzZV9lcnJvcicsIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UgfV0sXG4gICAgICAgICAgd2FybmluZ3M6IFtdLFxuICAgICAgICAgIHJvd0NvdW50OiAwLFxuICAgICAgICAgIGNvbHVtbkNvdW50OiAwLFxuICAgICAgICAgIGRhdGVSYW5nZTogbnVsbFxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0pXG4gIH0pXG59XG5cbmZ1bmN0aW9uIHBlcmZvcm1WYWxpZGF0aW9uKHBsYXRmb3JtOiBQbGF0Zm9ybSwgZGF0YTogYW55W10sIGhlYWRlcnM6IHN0cmluZ1tdKTogVmFsaWRhdGlvblJlc3VsdCB7XG4gIGNvbnN0IHNjaGVtYSA9IFBMQVRGT1JNX1NDSEVNQVNbcGxhdGZvcm1dXG4gIGNvbnN0IGVycm9yczogVmFsaWRhdGlvbkVycm9yW10gPSBbXVxuICBjb25zdCB3YXJuaW5nczogVmFsaWRhdGlvbldhcm5pbmdbXSA9IFtdXG5cbiAgLy8gQ2xlYW4gaGVhZGVycyAocmVtb3ZlIEJPTSwgdHJpbSB3aGl0ZXNwYWNlKVxuICBjb25zdCBjbGVhbkhlYWRlcnMgPSBoZWFkZXJzLm1hcChoID0+IGgucmVwbGFjZSgvXlxcdWZlZmYvLCAnJykudHJpbSgpKVxuICBcbiAgLy8gQ2hlY2sgZm9yIGNhc2Utc2Vuc2l0aXZlIGNvbHVtbiBtYXRjaGluZyBpc3N1ZXNcbiAgY29uc3QgY29sdW1uTWFwcGluZ0lzc3VlczogQXJyYXk8e3JlcXVpcmVkOiBzdHJpbmcsIGZvdW5kPzogc3RyaW5nLCBpc3N1ZTogc3RyaW5nfT4gPSBbXVxuICBcbiAgZm9yIChjb25zdCByZXF1aXJlZENvbCBvZiBzY2hlbWEucmVxdWlyZWQpIHtcbiAgICAvLyBUcnkgZXhhY3QgbWF0Y2ggZmlyc3RcbiAgICBjb25zdCBleGFjdE1hdGNoID0gY2xlYW5IZWFkZXJzLmZpbmQoaCA9PiBoID09PSByZXF1aXJlZENvbClcbiAgICBpZiAoZXhhY3RNYXRjaCkgY29udGludWVcbiAgICBcbiAgICAvLyBUcnkgY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaFxuICAgIGNvbnN0IGNhc2VJbnNlbnNpdGl2ZU1hdGNoID0gY2xlYW5IZWFkZXJzLmZpbmQoaCA9PiBcbiAgICAgIGgudG9Mb3dlckNhc2UoKSA9PT0gcmVxdWlyZWRDb2wudG9Mb3dlckNhc2UoKVxuICAgIClcbiAgICBcbiAgICBpZiAoY2FzZUluc2Vuc2l0aXZlTWF0Y2gpIHtcbiAgICAgIGNvbHVtbk1hcHBpbmdJc3N1ZXMucHVzaCh7XG4gICAgICAgIHJlcXVpcmVkOiByZXF1aXJlZENvbCxcbiAgICAgICAgZm91bmQ6IGNhc2VJbnNlbnNpdGl2ZU1hdGNoLFxuICAgICAgICBpc3N1ZTogJ2Nhc2VfbWlzbWF0Y2gnXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUcnkgZnV6enkgbWF0Y2ggKHNpbWlsYXIgbmFtZXMpXG4gICAgICBjb25zdCBmdXp6eU1hdGNoID0gY2xlYW5IZWFkZXJzLmZpbmQoaCA9PiBcbiAgICAgICAgbm9ybWFsaXplQ29sdW1uTmFtZShoKSA9PT0gbm9ybWFsaXplQ29sdW1uTmFtZShyZXF1aXJlZENvbClcbiAgICAgIClcbiAgICAgIFxuICAgICAgaWYgKGZ1enp5TWF0Y2gpIHtcbiAgICAgICAgY29sdW1uTWFwcGluZ0lzc3Vlcy5wdXNoKHtcbiAgICAgICAgICByZXF1aXJlZDogcmVxdWlyZWRDb2wsXG4gICAgICAgICAgZm91bmQ6IGZ1enp5TWF0Y2gsXG4gICAgICAgICAgaXNzdWU6ICduYW1lX3ZhcmlhdGlvbidcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbHVtbk1hcHBpbmdJc3N1ZXMucHVzaCh7XG4gICAgICAgICAgcmVxdWlyZWQ6IHJlcXVpcmVkQ29sLFxuICAgICAgICAgIGlzc3VlOiAnbWlzc2luZydcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBSZXBvcnQgY29sdW1uIGlzc3Vlc1xuICBjb25zdCBtaXNzaW5nQ29sdW1ucyA9IGNvbHVtbk1hcHBpbmdJc3N1ZXMuZmlsdGVyKGlzc3VlID0+IGlzc3VlLmlzc3VlID09PSAnbWlzc2luZycpXG4gIGNvbnN0IGNhc2VNaXNtYXRjaENvbHVtbnMgPSBjb2x1bW5NYXBwaW5nSXNzdWVzLmZpbHRlcihpc3N1ZSA9PiBpc3N1ZS5pc3N1ZSA9PT0gJ2Nhc2VfbWlzbWF0Y2gnKVxuICBjb25zdCBuYW1lVmFyaWF0aW9uQ29sdW1ucyA9IGNvbHVtbk1hcHBpbmdJc3N1ZXMuZmlsdGVyKGlzc3VlID0+IGlzc3VlLmlzc3VlID09PSAnbmFtZV92YXJpYXRpb24nKVxuICBcbiAgaWYgKG1pc3NpbmdDb2x1bW5zLmxlbmd0aCA+IDApIHtcbiAgICBlcnJvcnMucHVzaCh7XG4gICAgICB0eXBlOiAnbWlzc2luZ19jb2x1bW5zJyxcbiAgICAgIG1lc3NhZ2U6IGBNaXNzaW5nIHJlcXVpcmVkIGNvbHVtbnM6ICR7bWlzc2luZ0NvbHVtbnMubWFwKGMgPT4gYy5yZXF1aXJlZCkuam9pbignLCAnKX1gLFxuICAgICAgY29sdW1uczogbWlzc2luZ0NvbHVtbnMubWFwKGMgPT4gYy5yZXF1aXJlZClcbiAgICB9KVxuICB9XG5cbiAgaWYgKGNhc2VNaXNtYXRjaENvbHVtbnMubGVuZ3RoID4gMCkge1xuICAgIGVycm9ycy5wdXNoKHtcbiAgICAgIHR5cGU6ICdjb2x1bW5fY2FzZV9taXNtYXRjaCcsXG4gICAgICBtZXNzYWdlOiBgQ29sdW1uIGNhc2UgbWlzbWF0Y2ggZm91bmQ6ICR7Y2FzZU1pc21hdGNoQ29sdW1ucy5tYXAoYyA9PiBgXCIke2MuZm91bmR9XCIgc2hvdWxkIGJlIFwiJHtjLnJlcXVpcmVkfVwiYCkuam9pbignLCAnKX1gLFxuICAgICAgY29sdW1uczogY2FzZU1pc21hdGNoQ29sdW1ucy5tYXAoYyA9PiBjLnJlcXVpcmVkKVxuICAgIH0pXG4gIH1cblxuICBpZiAobmFtZVZhcmlhdGlvbkNvbHVtbnMubGVuZ3RoID4gMCkge1xuICAgIHdhcm5pbmdzLnB1c2goe1xuICAgICAgdHlwZTogJ2NvbHVtbl9uYW1lX3ZhcmlhdGlvbnMnLFxuICAgICAgbWVzc2FnZTogYENvbHVtbiBuYW1lIHZhcmlhdGlvbnMgZGV0ZWN0ZWQ6ICR7bmFtZVZhcmlhdGlvbkNvbHVtbnMubWFwKGMgPT4gYFwiJHtjLmZvdW5kfVwiIG1pZ2h0IGJlIFwiJHtjLnJlcXVpcmVkfVwiYCkuam9pbignLCAnKX1gLFxuICAgICAgZGV0YWlsczogbmFtZVZhcmlhdGlvbkNvbHVtbnNcbiAgICB9KVxuICB9XG5cbiAgLy8gQ2hlY2sgZm9yIHVuZXhwZWN0ZWQgY29sdW1ucyB0aGF0IG1pZ2h0IGluZGljYXRlIHdyb25nIHBsYXRmb3JtXG4gIGNvbnN0IHVuZXhwZWN0ZWRDb2x1bW5zID0gY2xlYW5IZWFkZXJzLmZpbHRlcihoZWFkZXIgPT4gXG4gICAgIXNjaGVtYS5yZXF1aXJlZC5zb21lKHJlcSA9PiBub3JtYWxpemVDb2x1bW5OYW1lKGhlYWRlcikgPT09IG5vcm1hbGl6ZUNvbHVtbk5hbWUocmVxKSlcbiAgKVxuICBcbiAgaWYgKHVuZXhwZWN0ZWRDb2x1bW5zLmxlbmd0aCA+IDAgJiYgdW5leHBlY3RlZENvbHVtbnMubGVuZ3RoID4gMykge1xuICAgIHdhcm5pbmdzLnB1c2goe1xuICAgICAgdHlwZTogJ3VuZXhwZWN0ZWRfY29sdW1ucycsXG4gICAgICBtZXNzYWdlOiBgTWFueSB1bmV4cGVjdGVkIGNvbHVtbnMgZm91bmQgKCR7dW5leHBlY3RlZENvbHVtbnMubGVuZ3RofSkuIFZlcmlmeSB0aGlzIGlzIHRoZSBjb3JyZWN0IHBsYXRmb3JtLmAsXG4gICAgICBkZXRhaWxzOiB7IHVuZXhwZWN0ZWRDb2x1bW5zOiB1bmV4cGVjdGVkQ29sdW1ucy5zbGljZSgwLCA1KSB9XG4gICAgfSlcbiAgfVxuXG4gIC8vIFZhbGlkYXRlIGRhdGUgZm9ybWF0cyAoU1RSSUNUIC0gbXVzdCBiZSBZWVlZLU1NLUREKVxuICBjb25zdCBkYXRlQ29sdW1uID0gZmluZENvbHVtbkJ5TmFtZShjbGVhbkhlYWRlcnMsIHNjaGVtYS5kYXRlQ29sdW1uKVxuICBpZiAoZGF0ZUNvbHVtbikge1xuICAgIGNvbnN0IGRhdGVWYWxpZGF0aW9uID0gdmFsaWRhdGVEYXRlRm9ybWF0cyhkYXRhLCBkYXRlQ29sdW1uKVxuICAgIFxuICAgIC8vIENoZWNrIGZvciB3cm9uZyBkYXRlIGZvcm1hdHMgLSBtYWtlIHRoaXMgYW4gRVJST1Igbm90IHdhcm5pbmdcbiAgICBjb25zdCBhbGxvd2VkRm9ybWF0cyA9IHNjaGVtYS5hY2NlcHRlZEZvcm1hdHNcbiAgICBjb25zdCBub25TdGFuZGFyZEZvcm1hdHMgPSBkYXRlVmFsaWRhdGlvbi5kZXRlY3RlZEZvcm1hdHMuZmlsdGVyKGZvcm1hdCA9PiAhYWxsb3dlZEZvcm1hdHMuaW5jbHVkZXMoZm9ybWF0KSlcbiAgICBpZiAobm9uU3RhbmRhcmRGb3JtYXRzLmxlbmd0aCA+IDApIHtcbiAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2ludmFsaWRfZGF0ZV9mb3JtYXQnLFxuICAgICAgICBtZXNzYWdlOiBgRGF0ZSBjb2x1bW4gJyR7ZGF0ZUNvbHVtbn0nIG11c3QgdXNlICR7c2NoZW1hLnJlcXVpcmVkRGF0ZUZvcm1hdH0gZm9ybWF0LiBGb3VuZDogJHtub25TdGFuZGFyZEZvcm1hdHMuam9pbignLCAnKX0uIEV4YW1wbGU6IDIwMjUtMTEtMTBgLFxuICAgICAgICBjb2x1bW5zOiBbZGF0ZUNvbHVtbl1cbiAgICAgIH0pXG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIGZvciBpbnZhbGlkL3VucGFyc2VhYmxlIGRhdGVzXG4gICAgaWYgKGRhdGVWYWxpZGF0aW9uLmludmFsaWREYXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdpbnZhbGlkX2RhdGVfdmFsdWVzJyxcbiAgICAgICAgbWVzc2FnZTogYEludmFsaWQgZGF0ZSB2YWx1ZXMgZm91bmQgaW4gJyR7ZGF0ZUNvbHVtbn0nOiAke2RhdGVWYWxpZGF0aW9uLmludmFsaWREYXRlcy5zbGljZSgwLCAzKS5tYXAoZCA9PiBkLnZhbHVlKS5qb2luKCcsICcpfWAsXG4gICAgICAgIGNvbHVtbnM6IFtkYXRlQ29sdW1uXVxuICAgICAgfSlcbiAgICB9XG4gICAgXG4gICAgLy8gT25seSBhZGQgd2FybmluZ3MgZm9yIG1pbm9yIGlzc3VlcyBpZiBubyBlcnJvcnNcbiAgICBpZiAobm9uU3RhbmRhcmRGb3JtYXRzLmxlbmd0aCA9PT0gMCAmJiBkYXRlVmFsaWRhdGlvbi5pbnZhbGlkRGF0ZXMubGVuZ3RoID09PSAwICYmIGRhdGVWYWxpZGF0aW9uLmRldGVjdGVkRm9ybWF0cy5sZW5ndGggPiAxKSB7XG4gICAgICB3YXJuaW5ncy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2RhdGVfZm9ybWF0X2luY29uc2lzdGVuY3knLFxuICAgICAgICBtZXNzYWdlOiBgTXVsdGlwbGUgZGF0ZSBmb3JtYXRzIGRldGVjdGVkIGluICR7ZGF0ZUNvbHVtbn1gLFxuICAgICAgICBkZXRhaWxzOiBkYXRlVmFsaWRhdGlvblxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICAvLyBWYWxpZGF0ZSBudW1lcmljIGNvbHVtbnNcbiAgY29uc3QgbnVtZXJpY1ZhbGlkYXRpb24gPSB2YWxpZGF0ZU51bWVyaWNDb2x1bW5zKHBsYXRmb3JtLCBkYXRhLCBjbGVhbkhlYWRlcnMpXG4gIHdhcm5pbmdzLnB1c2goLi4ubnVtZXJpY1ZhbGlkYXRpb24pXG5cbiAgcmV0dXJuIHtcbiAgICBpc1ZhbGlkOiBlcnJvcnMubGVuZ3RoID09PSAwLFxuICAgIGhhc0Vycm9yczogZXJyb3JzLmxlbmd0aCA+IDAsXG4gICAgaGFzV2FybmluZ3M6IHdhcm5pbmdzLmxlbmd0aCA+IDAsXG4gICAgbmVlZHNDb3JyZWN0aW9uOiB3YXJuaW5ncy5sZW5ndGggPiAwLFxuICAgIGVycm9ycyxcbiAgICB3YXJuaW5ncyxcbiAgICByb3dDb3VudDogZGF0YS5sZW5ndGgsXG4gICAgY29sdW1uQ291bnQ6IGhlYWRlcnMubGVuZ3RoLFxuICAgIGRhdGVSYW5nZTogZGV0ZWN0RGF0ZVJhbmdlKGRhdGEsIGRhdGVDb2x1bW4pXG4gIH1cbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplQ29sdW1uTmFtZShuYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gbmFtZS50b0xvd2VyQ2FzZSgpLnRyaW0oKS5yZXBsYWNlKC9bXlxcd10vZywgJ18nKVxufVxuXG5mdW5jdGlvbiBmaW5kQ29sdW1uQnlOYW1lKGhlYWRlcnM6IHN0cmluZ1tdLCB0YXJnZXROYW1lOiBzdHJpbmcpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICByZXR1cm4gaGVhZGVycy5maW5kKGhlYWRlciA9PiBcbiAgICBub3JtYWxpemVDb2x1bW5OYW1lKGhlYWRlcikgPT09IG5vcm1hbGl6ZUNvbHVtbk5hbWUodGFyZ2V0TmFtZSlcbiAgKVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZURhdGVGb3JtYXRzKGRhdGE6IGFueVtdLCBkYXRlQ29sdW1uOiBzdHJpbmcpOiB7IGhhc0lzc3VlczogYm9vbGVhbjsgZGV0ZWN0ZWRGb3JtYXRzOiBzdHJpbmdbXTsgaW52YWxpZERhdGVzOiBhbnlbXTsgcmVjb21tZW5kZWRGb3JtYXQ6IHN0cmluZyB9IHtcbiAgY29uc3QgZm9ybWF0cyA9IG5ldyBTZXQ8c3RyaW5nPigpXG4gIGNvbnN0IGludmFsaWREYXRlczogYW55W10gPSBbXVxuICBcbiAgZGF0YS5zbGljZSgwLCA1MCkuZm9yRWFjaCgocm93LCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IGRhdGVWYWx1ZSA9IHJvd1tkYXRlQ29sdW1uXVxuICAgIGlmIChkYXRlVmFsdWUpIHtcbiAgICAgIGNvbnN0IGRldGVjdGVkRm9ybWF0ID0gZGV0ZWN0RGF0ZUZvcm1hdChkYXRlVmFsdWUpXG4gICAgICBpZiAoZGV0ZWN0ZWRGb3JtYXQpIHtcbiAgICAgICAgZm9ybWF0cy5hZGQoZGV0ZWN0ZWRGb3JtYXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnZhbGlkRGF0ZXMucHVzaCh7IHJvdzogaW5kZXgsIHZhbHVlOiBkYXRlVmFsdWUgfSlcbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIHtcbiAgICBoYXNJc3N1ZXM6IGZvcm1hdHMuc2l6ZSA+IDEgfHwgaW52YWxpZERhdGVzLmxlbmd0aCA+IDAsXG4gICAgZGV0ZWN0ZWRGb3JtYXRzOiBBcnJheS5mcm9tKGZvcm1hdHMpLFxuICAgIGludmFsaWREYXRlcyxcbiAgICByZWNvbW1lbmRlZEZvcm1hdDogJ1lZWVktTU0tREQnXG4gIH1cbn1cblxuZnVuY3Rpb24gZGV0ZWN0RGF0ZUZvcm1hdChkYXRlU3RyaW5nOiBzdHJpbmcpOiBzdHJpbmcgfCBudWxsIHtcbiAgY29uc3QgdHJpbW1lZCA9IGRhdGVTdHJpbmcudHJpbSgpXG4gIFxuICBjb25zdCBwYXR0ZXJucyA9IFtcbiAgICB7IHJlZ2V4OiAvXlxcZHs0fS1cXGR7Mn0tXFxkezJ9JC8sIGZvcm1hdDogJ1lZWVktTU0tREQnIH0sXG4gICAgeyByZWdleDogL15cXGR7Mn0tXFxkezJ9LVxcZHs0fSQvLCBmb3JtYXQ6ICdERC1NTS1ZWVlZJyB9LFxuICAgIHsgcmVnZXg6IC9eXFxkezEsMn1cXC9cXGR7MSwyfVxcL1xcZHs0fSQvLCBmb3JtYXQ6ICdERC9NTS9ZWVlZJyB9LCAvLyBNb3JlIHNwZWNpZmljIGZvciB5b3VyIEdvb2dsZSBkYXRhXG4gICAgeyByZWdleDogL15cXGR7Mn1cXC9cXGR7Mn1cXC9cXGR7NH0kLywgZm9ybWF0OiAnREQvTU0vWVlZWScgfSxcbiAgICB7IHJlZ2V4OiAvXlxcZHs0fVxcL1xcZHsyfVxcL1xcZHsyfSQvLCBmb3JtYXQ6ICdZWVlZL01NL0REJyB9LFxuICAgIHsgcmVnZXg6IC9eXFxkezJ9XFwuXFxkezJ9XFwuXFxkezR9JC8sIGZvcm1hdDogJ0RELk1NLllZWVknIH1cbiAgXVxuXG4gIGZvciAoY29uc3QgcGF0dGVybiBvZiBwYXR0ZXJucykge1xuICAgIGlmIChwYXR0ZXJuLnJlZ2V4LnRlc3QodHJpbW1lZCkpIHtcbiAgICAgIHJldHVybiBwYXR0ZXJuLmZvcm1hdFxuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbFxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZU51bWVyaWNDb2x1bW5zKHBsYXRmb3JtOiBQbGF0Zm9ybSwgZGF0YTogYW55W10sIGhlYWRlcnM6IHN0cmluZ1tdKTogVmFsaWRhdGlvbldhcm5pbmdbXSB7XG4gIGNvbnN0IHdhcm5pbmdzOiBWYWxpZGF0aW9uV2FybmluZ1tdID0gW11cbiAgY29uc3QgbnVtZXJpY0NvbHVtbnMgPSBnZXROdW1lcmljQ29sdW1ucyhwbGF0Zm9ybSwgaGVhZGVycylcbiAgXG4gIG51bWVyaWNDb2x1bW5zLmZvckVhY2goY29sdW1uID0+IHtcbiAgICBjb25zdCBub25OdW1lcmljVmFsdWVzID0gZGF0YS5zbGljZSgwLCA1MClcbiAgICAgIC5tYXAoKHJvdywgaW5kZXgpID0+ICh7IGluZGV4LCB2YWx1ZTogcm93W2NvbHVtbl0gfSkpXG4gICAgICAuZmlsdGVyKGl0ZW0gPT4gaXRlbS52YWx1ZSAmJiBpc05hTihwYXJzZUZsb2F0KGl0ZW0udmFsdWUudG9TdHJpbmcoKS5yZXBsYWNlKC9bLCVdL2csICcnKSkpKVxuICAgIFxuICAgIGlmIChub25OdW1lcmljVmFsdWVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHdhcm5pbmdzLnB1c2goe1xuICAgICAgICB0eXBlOiAnbm9uX251bWVyaWNfdmFsdWVzJyxcbiAgICAgICAgbWVzc2FnZTogYE5vbi1udW1lcmljIHZhbHVlcyBkZXRlY3RlZCBpbiAke2NvbHVtbn1gLFxuICAgICAgICBjb2x1bW4sXG4gICAgICAgIHNhbXBsZXM6IG5vbk51bWVyaWNWYWx1ZXMuc2xpY2UoMCwgNSlcbiAgICAgIH0pXG4gICAgfVxuICB9KVxuXG4gIHJldHVybiB3YXJuaW5nc1xufVxuXG5mdW5jdGlvbiBnZXROdW1lcmljQ29sdW1ucyhwbGF0Zm9ybTogUGxhdGZvcm0sIGhlYWRlcnM6IHN0cmluZ1tdKTogc3RyaW5nW10ge1xuICBjb25zdCBudW1lcmljUGF0dGVybnM6IFJlY29yZDxQbGF0Zm9ybSwgc3RyaW5nW10+ID0ge1xuICAgIG1ldGE6IFsnYW1vdW50JywgJ3NwZW50JywgJ2Nvc3QnLCAnY3RyJywgJ2NwbSddLFxuICAgIGdvb2dsZTogWydjb3N0JywgJ2N0cicsICdjcG0nXSxcbiAgICBzaG9waWZ5OiBbJ3Zpc2l0b3JzJywgJ3Nlc3Npb25zJywgJ2NoZWNrb3V0JywgJ2R1cmF0aW9uJywgJ3BhZ2V2aWV3cyddXG4gIH1cblxuICByZXR1cm4gaGVhZGVycy5maWx0ZXIoaGVhZGVyID0+IHtcbiAgICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplQ29sdW1uTmFtZShoZWFkZXIpXG4gICAgcmV0dXJuIG51bWVyaWNQYXR0ZXJuc1twbGF0Zm9ybV0uc29tZShwYXR0ZXJuID0+IG5vcm1hbGl6ZWQuaW5jbHVkZXMocGF0dGVybikpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGRldGVjdERhdGVSYW5nZShkYXRhOiBhbnlbXSwgZGF0ZUNvbHVtbjogc3RyaW5nIHwgdW5kZWZpbmVkKTogRGF0ZVJhbmdlIHwgbnVsbCB7XG4gIGlmICghZGF0ZUNvbHVtbiB8fCBkYXRhLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGxcbiAgXG4gIGNvbnN0IGRhdGVzID0gZGF0YVxuICAgIC5tYXAocm93ID0+IHJvd1tkYXRlQ29sdW1uXSlcbiAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgLm1hcChkYXRlU3RyID0+IG5ldyBEYXRlKGRhdGVTdHIpKVxuICAgIC5maWx0ZXIoZGF0ZSA9PiAhaXNOYU4oZGF0ZS5nZXRUaW1lKCkpKVxuICAgIC5zb3J0KClcblxuICBpZiAoZGF0ZXMubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbFxuXG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IGRhdGVzWzBdLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXSxcbiAgICBlbmQ6IGRhdGVzW2RhdGVzLmxlbmd0aCAtIDFdLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXSxcbiAgICB0b3RhbERheXM6IE1hdGguY2VpbCgoZGF0ZXNbZGF0ZXMubGVuZ3RoIC0gMV0uZ2V0VGltZSgpIC0gZGF0ZXNbMF0uZ2V0VGltZSgpKSAvICgxMDAwICogNjAgKiA2MCAqIDI0KSkgKyAxXG4gIH1cbn0iXSwibmFtZXMiOlsiUGFwYSIsIlBMQVRGT1JNX1NDSEVNQVMiLCJtZXRhIiwicmVxdWlyZWQiLCJkYXRlQ29sdW1uIiwicmVxdWlyZWREYXRlRm9ybWF0IiwiYWNjZXB0ZWRGb3JtYXRzIiwiZ29vZ2xlIiwic2hvcGlmeSIsInZhbGlkYXRlQ1NWIiwicGxhdGZvcm0iLCJmaWxlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJwYXJzZSIsImhlYWRlciIsInByZXZpZXciLCJjb21wbGV0ZSIsInJlc3VsdHMiLCJ2YWxpZGF0aW9uIiwicGVyZm9ybVZhbGlkYXRpb24iLCJkYXRhIiwiZmllbGRzIiwiZXJyb3IiLCJpc1ZhbGlkIiwiaGFzRXJyb3JzIiwiaGFzV2FybmluZ3MiLCJuZWVkc0NvcnJlY3Rpb24iLCJlcnJvcnMiLCJ0eXBlIiwibWVzc2FnZSIsIndhcm5pbmdzIiwicm93Q291bnQiLCJjb2x1bW5Db3VudCIsImRhdGVSYW5nZSIsImhlYWRlcnMiLCJzY2hlbWEiLCJjbGVhbkhlYWRlcnMiLCJtYXAiLCJoIiwicmVwbGFjZSIsInRyaW0iLCJjb2x1bW5NYXBwaW5nSXNzdWVzIiwicmVxdWlyZWRDb2wiLCJleGFjdE1hdGNoIiwiZmluZCIsImNhc2VJbnNlbnNpdGl2ZU1hdGNoIiwidG9Mb3dlckNhc2UiLCJwdXNoIiwiZm91bmQiLCJpc3N1ZSIsImZ1enp5TWF0Y2giLCJub3JtYWxpemVDb2x1bW5OYW1lIiwibWlzc2luZ0NvbHVtbnMiLCJmaWx0ZXIiLCJjYXNlTWlzbWF0Y2hDb2x1bW5zIiwibmFtZVZhcmlhdGlvbkNvbHVtbnMiLCJsZW5ndGgiLCJjIiwiam9pbiIsImNvbHVtbnMiLCJkZXRhaWxzIiwidW5leHBlY3RlZENvbHVtbnMiLCJzb21lIiwicmVxIiwic2xpY2UiLCJmaW5kQ29sdW1uQnlOYW1lIiwiZGF0ZVZhbGlkYXRpb24iLCJ2YWxpZGF0ZURhdGVGb3JtYXRzIiwiYWxsb3dlZEZvcm1hdHMiLCJub25TdGFuZGFyZEZvcm1hdHMiLCJkZXRlY3RlZEZvcm1hdHMiLCJmb3JtYXQiLCJpbmNsdWRlcyIsImludmFsaWREYXRlcyIsImQiLCJ2YWx1ZSIsIm51bWVyaWNWYWxpZGF0aW9uIiwidmFsaWRhdGVOdW1lcmljQ29sdW1ucyIsImRldGVjdERhdGVSYW5nZSIsIm5hbWUiLCJ0YXJnZXROYW1lIiwiZm9ybWF0cyIsIlNldCIsImZvckVhY2giLCJyb3ciLCJpbmRleCIsImRhdGVWYWx1ZSIsImRldGVjdGVkRm9ybWF0IiwiZGV0ZWN0RGF0ZUZvcm1hdCIsImFkZCIsImhhc0lzc3VlcyIsInNpemUiLCJBcnJheSIsImZyb20iLCJyZWNvbW1lbmRlZEZvcm1hdCIsImRhdGVTdHJpbmciLCJ0cmltbWVkIiwicGF0dGVybnMiLCJyZWdleCIsInBhdHRlcm4iLCJ0ZXN0IiwibnVtZXJpY0NvbHVtbnMiLCJnZXROdW1lcmljQ29sdW1ucyIsImNvbHVtbiIsIm5vbk51bWVyaWNWYWx1ZXMiLCJpdGVtIiwiaXNOYU4iLCJwYXJzZUZsb2F0IiwidG9TdHJpbmciLCJzYW1wbGVzIiwibnVtZXJpY1BhdHRlcm5zIiwibm9ybWFsaXplZCIsImRhdGVzIiwiQm9vbGVhbiIsImRhdGVTdHIiLCJEYXRlIiwiZGF0ZSIsImdldFRpbWUiLCJzb3J0Iiwic3RhcnQiLCJ0b0lTT1N0cmluZyIsInNwbGl0IiwiZW5kIiwidG90YWxEYXlzIiwiTWF0aCIsImNlaWwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/validators.ts\n"));

/***/ })

});