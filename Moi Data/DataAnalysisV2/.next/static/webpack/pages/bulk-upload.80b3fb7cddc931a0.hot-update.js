"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/bulk-upload",{

/***/ "./lib/validators.ts":
/*!***************************!*\
  !*** ./lib/validators.ts ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PLATFORM_SCHEMAS: function() { return /* binding */ PLATFORM_SCHEMAS; },\n/* harmony export */   validateCSV: function() { return /* binding */ validateCSV; }\n/* harmony export */ });\n/* harmony import */ var papaparse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! papaparse */ \"./node_modules/papaparse/papaparse.min.js\");\n/* harmony import */ var papaparse__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(papaparse__WEBPACK_IMPORTED_MODULE_0__);\n\nconst PLATFORM_SCHEMAS = {\n    meta: {\n        required: [\n            \"Day\",\n            \"Campaign name\",\n            \"Ad set name\",\n            \"Ad name\",\n            \"Amount spent (INR)\",\n            \"CTR (link click-through rate)\",\n            \"CPM (cost per 1,000 impressions)\"\n        ],\n        dateColumn: \"Day\",\n        requiredDateFormat: \"YYYY-MM-DD\",\n        acceptedFormats: [\n            \"YYYY-MM-DD\"\n        ] // Only accept standard format\n    },\n    google: {\n        required: [\n            \"Day\",\n            \"Campaign\",\n            \"Cost\",\n            \"CTR\",\n            \"Avg. CPM\"\n        ],\n        dateColumn: \"Day\",\n        requiredDateFormat: \"YYYY-MM-DD\",\n        acceptedFormats: [\n            \"YYYY-MM-DD\"\n        ] // Only accept standard format\n    },\n    shopify: {\n        required: [\n            \"Day\",\n            \"UTM campaign\",\n            \"UTM term\",\n            \"UTM content\",\n            \"Online store visitors\",\n            \"Sessions that completed checkout\"\n        ],\n        dateColumn: \"Day\",\n        requiredDateFormat: \"YYYY-MM-DD\",\n        acceptedFormats: [\n            \"YYYY-MM-DD\"\n        ] // Only accept standard format\n    }\n};\nasync function validateCSV(platform, file) {\n    return new Promise((resolve)=>{\n        papaparse__WEBPACK_IMPORTED_MODULE_0___default().parse(file, {\n            header: true,\n            preview: 100,\n            complete: (results)=>{\n                const validation = performValidation(platform, results.data, results.meta.fields || []);\n                resolve(validation);\n            },\n            error: (error)=>{\n                resolve({\n                    isValid: false,\n                    hasErrors: true,\n                    hasWarnings: false,\n                    needsCorrection: false,\n                    errors: [\n                        {\n                            type: \"parse_error\",\n                            message: error.message\n                        }\n                    ],\n                    warnings: [],\n                    rowCount: 0,\n                    columnCount: 0,\n                    dateRange: null\n                });\n            }\n        });\n    });\n}\nfunction performValidation(platform, data, headers) {\n    const schema = PLATFORM_SCHEMAS[platform];\n    const errors = [];\n    const warnings = [];\n    // Check required columns\n    const missingColumns = schema.required.filter((col)=>!headers.some((header)=>normalizeColumnName(header) === normalizeColumnName(col)));\n    if (missingColumns.length > 0) {\n        errors.push({\n            type: \"missing_columns\",\n            message: \"Missing required columns: \".concat(missingColumns.join(\", \")),\n            columns: missingColumns\n        });\n    }\n    // Validate date formats (STRICT - must be YYYY-MM-DD)\n    const dateColumn = findColumnByName(headers, schema.dateColumn);\n    if (dateColumn) {\n        const dateValidation = validateDateFormats(data, dateColumn);\n        // Check for wrong date formats - make this an ERROR not warning\n        const allowedFormats = schema.acceptedFormats;\n        const nonStandardFormats = dateValidation.detectedFormats.filter((format)=>!allowedFormats.includes(format));\n        if (nonStandardFormats.length > 0) {\n            errors.push({\n                type: \"invalid_date_format\",\n                message: \"Date column '\".concat(dateColumn, \"' must use \").concat(schema.requiredDateFormat, \" format. Found: \").concat(nonStandardFormats.join(\", \"), \". Example: 2025-11-10\"),\n                columns: [\n                    dateColumn\n                ]\n            });\n        }\n        // Check for invalid/unparseable dates\n        if (dateValidation.invalidDates.length > 0) {\n            errors.push({\n                type: \"invalid_date_values\",\n                message: \"Invalid date values found in '\".concat(dateColumn, \"': \").concat(dateValidation.invalidDates.slice(0, 3).map((d)=>d.value).join(\", \")),\n                columns: [\n                    dateColumn\n                ]\n            });\n        }\n        // Only add warnings for minor issues if no errors\n        if (nonStandardFormats.length === 0 && dateValidation.invalidDates.length === 0 && dateValidation.detectedFormats.length > 1) {\n            warnings.push({\n                type: \"date_format_inconsistency\",\n                message: \"Multiple date formats detected in \".concat(dateColumn),\n                details: dateValidation\n            });\n        }\n    }\n    // Validate numeric columns\n    const numericValidation = validateNumericColumns(platform, data, headers);\n    warnings.push(...numericValidation);\n    return {\n        isValid: errors.length === 0,\n        hasErrors: errors.length > 0,\n        hasWarnings: warnings.length > 0,\n        needsCorrection: warnings.length > 0,\n        errors,\n        warnings,\n        rowCount: data.length,\n        columnCount: headers.length,\n        dateRange: detectDateRange(data, dateColumn)\n    };\n}\nfunction normalizeColumnName(name) {\n    return name.toLowerCase().trim().replace(/[^\\w]/g, \"_\");\n}\nfunction findColumnByName(headers, targetName) {\n    return headers.find((header)=>normalizeColumnName(header) === normalizeColumnName(targetName));\n}\nfunction validateDateFormats(data, dateColumn) {\n    const formats = new Set();\n    const invalidDates = [];\n    data.slice(0, 50).forEach((row, index)=>{\n        const dateValue = row[dateColumn];\n        if (dateValue) {\n            const detectedFormat = detectDateFormat(dateValue);\n            if (detectedFormat) {\n                formats.add(detectedFormat);\n            } else {\n                invalidDates.push({\n                    row: index,\n                    value: dateValue\n                });\n            }\n        }\n    });\n    return {\n        hasIssues: formats.size > 1 || invalidDates.length > 0,\n        detectedFormats: Array.from(formats),\n        invalidDates,\n        recommendedFormat: \"YYYY-MM-DD\"\n    };\n}\nfunction detectDateFormat(dateString) {\n    const trimmed = dateString.trim();\n    const patterns = [\n        {\n            regex: /^\\d{4}-\\d{2}-\\d{2}$/,\n            format: \"YYYY-MM-DD\"\n        },\n        {\n            regex: /^\\d{2}-\\d{2}-\\d{4}$/,\n            format: \"DD-MM-YYYY\"\n        },\n        {\n            regex: /^\\d{1,2}\\/\\d{1,2}\\/\\d{4}$/,\n            format: \"DD/MM/YYYY\"\n        },\n        {\n            regex: /^\\d{2}\\/\\d{2}\\/\\d{4}$/,\n            format: \"DD/MM/YYYY\"\n        },\n        {\n            regex: /^\\d{4}\\/\\d{2}\\/\\d{2}$/,\n            format: \"YYYY/MM/DD\"\n        },\n        {\n            regex: /^\\d{2}\\.\\d{2}\\.\\d{4}$/,\n            format: \"DD.MM.YYYY\"\n        }\n    ];\n    for (const pattern of patterns){\n        if (pattern.regex.test(trimmed)) {\n            return pattern.format;\n        }\n    }\n    return null;\n}\nfunction validateNumericColumns(platform, data, headers) {\n    const warnings = [];\n    const numericColumns = getNumericColumns(platform, headers);\n    numericColumns.forEach((column)=>{\n        const nonNumericValues = data.slice(0, 50).map((row, index)=>({\n                index,\n                value: row[column]\n            })).filter((item)=>item.value && isNaN(parseFloat(item.value.toString().replace(/[,%]/g, \"\"))));\n        if (nonNumericValues.length > 0) {\n            warnings.push({\n                type: \"non_numeric_values\",\n                message: \"Non-numeric values detected in \".concat(column),\n                column,\n                samples: nonNumericValues.slice(0, 5)\n            });\n        }\n    });\n    return warnings;\n}\nfunction getNumericColumns(platform, headers) {\n    const numericPatterns = {\n        meta: [\n            \"amount\",\n            \"spent\",\n            \"cost\",\n            \"ctr\",\n            \"cpm\"\n        ],\n        google: [\n            \"cost\",\n            \"ctr\",\n            \"cpm\"\n        ],\n        shopify: [\n            \"visitors\",\n            \"sessions\",\n            \"checkout\",\n            \"duration\",\n            \"pageviews\"\n        ]\n    };\n    return headers.filter((header)=>{\n        const normalized = normalizeColumnName(header);\n        return numericPatterns[platform].some((pattern)=>normalized.includes(pattern));\n    });\n}\nfunction detectDateRange(data, dateColumn) {\n    if (!dateColumn || data.length === 0) return null;\n    const dates = data.map((row)=>row[dateColumn]).filter(Boolean).map((dateStr)=>new Date(dateStr)).filter((date)=>!isNaN(date.getTime())).sort();\n    if (dates.length === 0) return null;\n    return {\n        start: dates[0].toISOString().split(\"T\")[0],\n        end: dates[dates.length - 1].toISOString().split(\"T\")[0],\n        totalDays: Math.ceil((dates[dates.length - 1].getTime() - dates[0].getTime()) / (1000 * 60 * 60 * 24)) + 1\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LFVBQVdZLFdBQVc5QyxRQUFRLENBQUNrQztJQUN2RTtBQUNGO0FBRUEsU0FBU3pCLGdCQUFnQnpDLElBQVcsRUFBRWpCLFVBQThCO0lBQ2xFLElBQUksQ0FBQ0EsY0FBY2lCLEtBQUtxQixNQUFNLEtBQUssR0FBRyxPQUFPO0lBRTdDLE1BQU0wRCxRQUFRL0UsS0FDWG1DLEdBQUcsQ0FBQ2dCLENBQUFBLE1BQU9BLEdBQUcsQ0FBQ3BFLFdBQVcsRUFDMUJrQyxNQUFNLENBQUMrRCxTQUNQN0MsR0FBRyxDQUFDOEMsQ0FBQUEsVUFBVyxJQUFJQyxLQUFLRCxVQUN4QmhFLE1BQU0sQ0FBQ2tFLENBQUFBLE9BQVEsQ0FBQ1YsTUFBTVUsS0FBS0MsT0FBTyxLQUNsQ0MsSUFBSTtJQUVQLElBQUlOLE1BQU0xRCxNQUFNLEtBQUssR0FBRyxPQUFPO0lBRS9CLE9BQU87UUFDTGlFLE9BQU9QLEtBQUssQ0FBQyxFQUFFLENBQUNRLFdBQVcsR0FBR0MsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFO1FBQzNDQyxLQUFLVixLQUFLLENBQUNBLE1BQU0xRCxNQUFNLEdBQUcsRUFBRSxDQUFDa0UsV0FBVyxHQUFHQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7UUFDeERFLFdBQVdDLEtBQUtDLElBQUksQ0FBQyxDQUFDYixLQUFLLENBQUNBLE1BQU0xRCxNQUFNLEdBQUcsRUFBRSxDQUFDK0QsT0FBTyxLQUFLTCxLQUFLLENBQUMsRUFBRSxDQUFDSyxPQUFPLEVBQUMsSUFBTSxRQUFPLEtBQUssS0FBSyxFQUFDLEtBQU07SUFDM0c7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvdmFsaWRhdG9ycy50cz81NmIwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBQYXBhIGZyb20gJ3BhcGFwYXJzZSdcbmltcG9ydCB7IFBsYXRmb3JtIH0gZnJvbSAnLi9zdXBhYmFzZSdcblxuZXhwb3J0IGludGVyZmFjZSBWYWxpZGF0aW9uUmVzdWx0IHtcbiAgaXNWYWxpZDogYm9vbGVhblxuICBoYXNFcnJvcnM6IGJvb2xlYW5cbiAgaGFzV2FybmluZ3M6IGJvb2xlYW5cbiAgbmVlZHNDb3JyZWN0aW9uOiBib29sZWFuXG4gIGVycm9yczogVmFsaWRhdGlvbkVycm9yW11cbiAgd2FybmluZ3M6IFZhbGlkYXRpb25XYXJuaW5nW11cbiAgcm93Q291bnQ6IG51bWJlclxuICBjb2x1bW5Db3VudDogbnVtYmVyXG4gIGRhdGVSYW5nZTogRGF0ZVJhbmdlIHwgbnVsbFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFZhbGlkYXRpb25FcnJvciB7XG4gIHR5cGU6IHN0cmluZ1xuICBtZXNzYWdlOiBzdHJpbmdcbiAgY29sdW1ucz86IHN0cmluZ1tdXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmFsaWRhdGlvbldhcm5pbmcge1xuICB0eXBlOiBzdHJpbmdcbiAgbWVzc2FnZTogc3RyaW5nXG4gIGNvbHVtbj86IHN0cmluZ1xuICBzYW1wbGVzPzogYW55W11cbiAgZGV0YWlscz86IGFueVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIERhdGVSYW5nZSB7XG4gIHN0YXJ0OiBzdHJpbmdcbiAgZW5kOiBzdHJpbmdcbiAgdG90YWxEYXlzOiBudW1iZXJcbn1cblxuZXhwb3J0IGNvbnN0IFBMQVRGT1JNX1NDSEVNQVM6IFJlY29yZDxQbGF0Zm9ybSwge1xuICByZXF1aXJlZDogc3RyaW5nW11cbiAgZGF0ZUNvbHVtbjogc3RyaW5nXG4gIHJlcXVpcmVkRGF0ZUZvcm1hdDogc3RyaW5nXG4gIGFjY2VwdGVkRm9ybWF0czogc3RyaW5nW11cbn0+ID0ge1xuICBtZXRhOiB7XG4gICAgcmVxdWlyZWQ6IFtcbiAgICAgICdEYXknLFxuICAgICAgJ0NhbXBhaWduIG5hbWUnLFxuICAgICAgJ0FkIHNldCBuYW1lJywgXG4gICAgICAnQWQgbmFtZScsXG4gICAgICAnQW1vdW50IHNwZW50IChJTlIpJyxcbiAgICAgICdDVFIgKGxpbmsgY2xpY2stdGhyb3VnaCByYXRlKScsXG4gICAgICAnQ1BNIChjb3N0IHBlciAxLDAwMCBpbXByZXNzaW9ucyknXG4gICAgXSxcbiAgICBkYXRlQ29sdW1uOiAnRGF5JyxcbiAgICByZXF1aXJlZERhdGVGb3JtYXQ6ICdZWVlZLU1NLUREJyxcbiAgICBhY2NlcHRlZEZvcm1hdHM6IFsnWVlZWS1NTS1ERCddIC8vIE9ubHkgYWNjZXB0IHN0YW5kYXJkIGZvcm1hdFxuICB9LFxuICBnb29nbGU6IHtcbiAgICByZXF1aXJlZDogW1xuICAgICAgJ0RheScsXG4gICAgICAnQ2FtcGFpZ24nLFxuICAgICAgJ0Nvc3QnLFxuICAgICAgJ0NUUicsXG4gICAgICAnQXZnLiBDUE0nXG4gICAgXSxcbiAgICBkYXRlQ29sdW1uOiAnRGF5JyxcbiAgICByZXF1aXJlZERhdGVGb3JtYXQ6ICdZWVlZLU1NLUREJyxcbiAgICBhY2NlcHRlZEZvcm1hdHM6IFsnWVlZWS1NTS1ERCddIC8vIE9ubHkgYWNjZXB0IHN0YW5kYXJkIGZvcm1hdFxuICB9LFxuICBzaG9waWZ5OiB7XG4gICAgcmVxdWlyZWQ6IFtcbiAgICAgICdEYXknLFxuICAgICAgJ1VUTSBjYW1wYWlnbicsXG4gICAgICAnVVRNIHRlcm0nLFxuICAgICAgJ1VUTSBjb250ZW50JyxcbiAgICAgICdPbmxpbmUgc3RvcmUgdmlzaXRvcnMnLFxuICAgICAgJ1Nlc3Npb25zIHRoYXQgY29tcGxldGVkIGNoZWNrb3V0J1xuICAgIF0sXG4gICAgZGF0ZUNvbHVtbjogJ0RheScsXG4gICAgcmVxdWlyZWREYXRlRm9ybWF0OiAnWVlZWS1NTS1ERCcsXG4gICAgYWNjZXB0ZWRGb3JtYXRzOiBbJ1lZWVktTU0tREQnXSAvLyBPbmx5IGFjY2VwdCBzdGFuZGFyZCBmb3JtYXRcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVDU1YocGxhdGZvcm06IFBsYXRmb3JtLCBmaWxlOiBGaWxlKTogUHJvbWlzZTxWYWxpZGF0aW9uUmVzdWx0PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIFBhcGEucGFyc2UoZmlsZSwge1xuICAgICAgaGVhZGVyOiB0cnVlLFxuICAgICAgcHJldmlldzogMTAwLFxuICAgICAgY29tcGxldGU6IChyZXN1bHRzKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBwZXJmb3JtVmFsaWRhdGlvbihwbGF0Zm9ybSwgcmVzdWx0cy5kYXRhLCByZXN1bHRzLm1ldGEuZmllbGRzIHx8IFtdKVxuICAgICAgICByZXNvbHZlKHZhbGlkYXRpb24pXG4gICAgICB9LFxuICAgICAgZXJyb3I6IChlcnJvcikgPT4ge1xuICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgICAgICBoYXNFcnJvcnM6IHRydWUsXG4gICAgICAgICAgaGFzV2FybmluZ3M6IGZhbHNlLFxuICAgICAgICAgIG5lZWRzQ29ycmVjdGlvbjogZmFsc2UsXG4gICAgICAgICAgZXJyb3JzOiBbeyB0eXBlOiAncGFyc2VfZXJyb3InLCBtZXNzYWdlOiBlcnJvci5tZXNzYWdlIH1dLFxuICAgICAgICAgIHdhcm5pbmdzOiBbXSxcbiAgICAgICAgICByb3dDb3VudDogMCxcbiAgICAgICAgICBjb2x1bW5Db3VudDogMCxcbiAgICAgICAgICBkYXRlUmFuZ2U6IG51bGxcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9KVxuICB9KVxufVxuXG5mdW5jdGlvbiBwZXJmb3JtVmFsaWRhdGlvbihwbGF0Zm9ybTogUGxhdGZvcm0sIGRhdGE6IGFueVtdLCBoZWFkZXJzOiBzdHJpbmdbXSk6IFZhbGlkYXRpb25SZXN1bHQge1xuICBjb25zdCBzY2hlbWEgPSBQTEFURk9STV9TQ0hFTUFTW3BsYXRmb3JtXVxuICBjb25zdCBlcnJvcnM6IFZhbGlkYXRpb25FcnJvcltdID0gW11cbiAgY29uc3Qgd2FybmluZ3M6IFZhbGlkYXRpb25XYXJuaW5nW10gPSBbXVxuXG4gIC8vIENoZWNrIHJlcXVpcmVkIGNvbHVtbnNcbiAgY29uc3QgbWlzc2luZ0NvbHVtbnMgPSBzY2hlbWEucmVxdWlyZWQuZmlsdGVyKGNvbCA9PiBcbiAgICAhaGVhZGVycy5zb21lKGhlYWRlciA9PiBub3JtYWxpemVDb2x1bW5OYW1lKGhlYWRlcikgPT09IG5vcm1hbGl6ZUNvbHVtbk5hbWUoY29sKSlcbiAgKVxuICBcbiAgaWYgKG1pc3NpbmdDb2x1bW5zLmxlbmd0aCA+IDApIHtcbiAgICBlcnJvcnMucHVzaCh7XG4gICAgICB0eXBlOiAnbWlzc2luZ19jb2x1bW5zJyxcbiAgICAgIG1lc3NhZ2U6IGBNaXNzaW5nIHJlcXVpcmVkIGNvbHVtbnM6ICR7bWlzc2luZ0NvbHVtbnMuam9pbignLCAnKX1gLFxuICAgICAgY29sdW1uczogbWlzc2luZ0NvbHVtbnNcbiAgICB9KVxuICB9XG5cbiAgLy8gVmFsaWRhdGUgZGF0ZSBmb3JtYXRzIChTVFJJQ1QgLSBtdXN0IGJlIFlZWVktTU0tREQpXG4gIGNvbnN0IGRhdGVDb2x1bW4gPSBmaW5kQ29sdW1uQnlOYW1lKGhlYWRlcnMsIHNjaGVtYS5kYXRlQ29sdW1uKVxuICBpZiAoZGF0ZUNvbHVtbikge1xuICAgIGNvbnN0IGRhdGVWYWxpZGF0aW9uID0gdmFsaWRhdGVEYXRlRm9ybWF0cyhkYXRhLCBkYXRlQ29sdW1uKVxuICAgIFxuICAgIC8vIENoZWNrIGZvciB3cm9uZyBkYXRlIGZvcm1hdHMgLSBtYWtlIHRoaXMgYW4gRVJST1Igbm90IHdhcm5pbmdcbiAgICBjb25zdCBhbGxvd2VkRm9ybWF0cyA9IHNjaGVtYS5hY2NlcHRlZEZvcm1hdHNcbiAgICBjb25zdCBub25TdGFuZGFyZEZvcm1hdHMgPSBkYXRlVmFsaWRhdGlvbi5kZXRlY3RlZEZvcm1hdHMuZmlsdGVyKGZvcm1hdCA9PiAhYWxsb3dlZEZvcm1hdHMuaW5jbHVkZXMoZm9ybWF0KSlcbiAgICBpZiAobm9uU3RhbmRhcmRGb3JtYXRzLmxlbmd0aCA+IDApIHtcbiAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2ludmFsaWRfZGF0ZV9mb3JtYXQnLFxuICAgICAgICBtZXNzYWdlOiBgRGF0ZSBjb2x1bW4gJyR7ZGF0ZUNvbHVtbn0nIG11c3QgdXNlICR7c2NoZW1hLnJlcXVpcmVkRGF0ZUZvcm1hdH0gZm9ybWF0LiBGb3VuZDogJHtub25TdGFuZGFyZEZvcm1hdHMuam9pbignLCAnKX0uIEV4YW1wbGU6IDIwMjUtMTEtMTBgLFxuICAgICAgICBjb2x1bW5zOiBbZGF0ZUNvbHVtbl1cbiAgICAgIH0pXG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIGZvciBpbnZhbGlkL3VucGFyc2VhYmxlIGRhdGVzXG4gICAgaWYgKGRhdGVWYWxpZGF0aW9uLmludmFsaWREYXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdpbnZhbGlkX2RhdGVfdmFsdWVzJyxcbiAgICAgICAgbWVzc2FnZTogYEludmFsaWQgZGF0ZSB2YWx1ZXMgZm91bmQgaW4gJyR7ZGF0ZUNvbHVtbn0nOiAke2RhdGVWYWxpZGF0aW9uLmludmFsaWREYXRlcy5zbGljZSgwLCAzKS5tYXAoZCA9PiBkLnZhbHVlKS5qb2luKCcsICcpfWAsXG4gICAgICAgIGNvbHVtbnM6IFtkYXRlQ29sdW1uXVxuICAgICAgfSlcbiAgICB9XG4gICAgXG4gICAgLy8gT25seSBhZGQgd2FybmluZ3MgZm9yIG1pbm9yIGlzc3VlcyBpZiBubyBlcnJvcnNcbiAgICBpZiAobm9uU3RhbmRhcmRGb3JtYXRzLmxlbmd0aCA9PT0gMCAmJiBkYXRlVmFsaWRhdGlvbi5pbnZhbGlkRGF0ZXMubGVuZ3RoID09PSAwICYmIGRhdGVWYWxpZGF0aW9uLmRldGVjdGVkRm9ybWF0cy5sZW5ndGggPiAxKSB7XG4gICAgICB3YXJuaW5ncy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2RhdGVfZm9ybWF0X2luY29uc2lzdGVuY3knLFxuICAgICAgICBtZXNzYWdlOiBgTXVsdGlwbGUgZGF0ZSBmb3JtYXRzIGRldGVjdGVkIGluICR7ZGF0ZUNvbHVtbn1gLFxuICAgICAgICBkZXRhaWxzOiBkYXRlVmFsaWRhdGlvblxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICAvLyBWYWxpZGF0ZSBudW1lcmljIGNvbHVtbnNcbiAgY29uc3QgbnVtZXJpY1ZhbGlkYXRpb24gPSB2YWxpZGF0ZU51bWVyaWNDb2x1bW5zKHBsYXRmb3JtLCBkYXRhLCBoZWFkZXJzKVxuICB3YXJuaW5ncy5wdXNoKC4uLm51bWVyaWNWYWxpZGF0aW9uKVxuXG4gIHJldHVybiB7XG4gICAgaXNWYWxpZDogZXJyb3JzLmxlbmd0aCA9PT0gMCxcbiAgICBoYXNFcnJvcnM6IGVycm9ycy5sZW5ndGggPiAwLFxuICAgIGhhc1dhcm5pbmdzOiB3YXJuaW5ncy5sZW5ndGggPiAwLFxuICAgIG5lZWRzQ29ycmVjdGlvbjogd2FybmluZ3MubGVuZ3RoID4gMCxcbiAgICBlcnJvcnMsXG4gICAgd2FybmluZ3MsXG4gICAgcm93Q291bnQ6IGRhdGEubGVuZ3RoLFxuICAgIGNvbHVtbkNvdW50OiBoZWFkZXJzLmxlbmd0aCxcbiAgICBkYXRlUmFuZ2U6IGRldGVjdERhdGVSYW5nZShkYXRhLCBkYXRlQ29sdW1uKVxuICB9XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNvbHVtbk5hbWUobmFtZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIG5hbWUudG9Mb3dlckNhc2UoKS50cmltKCkucmVwbGFjZSgvW15cXHddL2csICdfJylcbn1cblxuZnVuY3Rpb24gZmluZENvbHVtbkJ5TmFtZShoZWFkZXJzOiBzdHJpbmdbXSwgdGFyZ2V0TmFtZTogc3RyaW5nKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgcmV0dXJuIGhlYWRlcnMuZmluZChoZWFkZXIgPT4gXG4gICAgbm9ybWFsaXplQ29sdW1uTmFtZShoZWFkZXIpID09PSBub3JtYWxpemVDb2x1bW5OYW1lKHRhcmdldE5hbWUpXG4gIClcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVEYXRlRm9ybWF0cyhkYXRhOiBhbnlbXSwgZGF0ZUNvbHVtbjogc3RyaW5nKTogeyBoYXNJc3N1ZXM6IGJvb2xlYW47IGRldGVjdGVkRm9ybWF0czogc3RyaW5nW107IGludmFsaWREYXRlczogYW55W107IHJlY29tbWVuZGVkRm9ybWF0OiBzdHJpbmcgfSB7XG4gIGNvbnN0IGZvcm1hdHMgPSBuZXcgU2V0PHN0cmluZz4oKVxuICBjb25zdCBpbnZhbGlkRGF0ZXM6IGFueVtdID0gW11cbiAgXG4gIGRhdGEuc2xpY2UoMCwgNTApLmZvckVhY2goKHJvdywgaW5kZXgpID0+IHtcbiAgICBjb25zdCBkYXRlVmFsdWUgPSByb3dbZGF0ZUNvbHVtbl1cbiAgICBpZiAoZGF0ZVZhbHVlKSB7XG4gICAgICBjb25zdCBkZXRlY3RlZEZvcm1hdCA9IGRldGVjdERhdGVGb3JtYXQoZGF0ZVZhbHVlKVxuICAgICAgaWYgKGRldGVjdGVkRm9ybWF0KSB7XG4gICAgICAgIGZvcm1hdHMuYWRkKGRldGVjdGVkRm9ybWF0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW52YWxpZERhdGVzLnB1c2goeyByb3c6IGluZGV4LCB2YWx1ZTogZGF0ZVZhbHVlIH0pXG4gICAgICB9XG4gICAgfVxuICB9KVxuXG4gIHJldHVybiB7XG4gICAgaGFzSXNzdWVzOiBmb3JtYXRzLnNpemUgPiAxIHx8IGludmFsaWREYXRlcy5sZW5ndGggPiAwLFxuICAgIGRldGVjdGVkRm9ybWF0czogQXJyYXkuZnJvbShmb3JtYXRzKSxcbiAgICBpbnZhbGlkRGF0ZXMsXG4gICAgcmVjb21tZW5kZWRGb3JtYXQ6ICdZWVlZLU1NLUREJ1xuICB9XG59XG5cbmZ1bmN0aW9uIGRldGVjdERhdGVGb3JtYXQoZGF0ZVN0cmluZzogc3RyaW5nKTogc3RyaW5nIHwgbnVsbCB7XG4gIGNvbnN0IHRyaW1tZWQgPSBkYXRlU3RyaW5nLnRyaW0oKVxuICBcbiAgY29uc3QgcGF0dGVybnMgPSBbXG4gICAgeyByZWdleDogL15cXGR7NH0tXFxkezJ9LVxcZHsyfSQvLCBmb3JtYXQ6ICdZWVlZLU1NLUREJyB9LFxuICAgIHsgcmVnZXg6IC9eXFxkezJ9LVxcZHsyfS1cXGR7NH0kLywgZm9ybWF0OiAnREQtTU0tWVlZWScgfSxcbiAgICB7IHJlZ2V4OiAvXlxcZHsxLDJ9XFwvXFxkezEsMn1cXC9cXGR7NH0kLywgZm9ybWF0OiAnREQvTU0vWVlZWScgfSwgLy8gTW9yZSBzcGVjaWZpYyBmb3IgeW91ciBHb29nbGUgZGF0YVxuICAgIHsgcmVnZXg6IC9eXFxkezJ9XFwvXFxkezJ9XFwvXFxkezR9JC8sIGZvcm1hdDogJ0REL01NL1lZWVknIH0sXG4gICAgeyByZWdleDogL15cXGR7NH1cXC9cXGR7Mn1cXC9cXGR7Mn0kLywgZm9ybWF0OiAnWVlZWS9NTS9ERCcgfSxcbiAgICB7IHJlZ2V4OiAvXlxcZHsyfVxcLlxcZHsyfVxcLlxcZHs0fSQvLCBmb3JtYXQ6ICdERC5NTS5ZWVlZJyB9XG4gIF1cblxuICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgcGF0dGVybnMpIHtcbiAgICBpZiAocGF0dGVybi5yZWdleC50ZXN0KHRyaW1tZWQpKSB7XG4gICAgICByZXR1cm4gcGF0dGVybi5mb3JtYXRcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVOdW1lcmljQ29sdW1ucyhwbGF0Zm9ybTogUGxhdGZvcm0sIGRhdGE6IGFueVtdLCBoZWFkZXJzOiBzdHJpbmdbXSk6IFZhbGlkYXRpb25XYXJuaW5nW10ge1xuICBjb25zdCB3YXJuaW5nczogVmFsaWRhdGlvbldhcm5pbmdbXSA9IFtdXG4gIGNvbnN0IG51bWVyaWNDb2x1bW5zID0gZ2V0TnVtZXJpY0NvbHVtbnMocGxhdGZvcm0sIGhlYWRlcnMpXG4gIFxuICBudW1lcmljQ29sdW1ucy5mb3JFYWNoKGNvbHVtbiA9PiB7XG4gICAgY29uc3Qgbm9uTnVtZXJpY1ZhbHVlcyA9IGRhdGEuc2xpY2UoMCwgNTApXG4gICAgICAubWFwKChyb3csIGluZGV4KSA9PiAoeyBpbmRleCwgdmFsdWU6IHJvd1tjb2x1bW5dIH0pKVxuICAgICAgLmZpbHRlcihpdGVtID0+IGl0ZW0udmFsdWUgJiYgaXNOYU4ocGFyc2VGbG9hdChpdGVtLnZhbHVlLnRvU3RyaW5nKCkucmVwbGFjZSgvWywlXS9nLCAnJykpKSlcbiAgICBcbiAgICBpZiAobm9uTnVtZXJpY1ZhbHVlcy5sZW5ndGggPiAwKSB7XG4gICAgICB3YXJuaW5ncy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ25vbl9udW1lcmljX3ZhbHVlcycsXG4gICAgICAgIG1lc3NhZ2U6IGBOb24tbnVtZXJpYyB2YWx1ZXMgZGV0ZWN0ZWQgaW4gJHtjb2x1bW59YCxcbiAgICAgICAgY29sdW1uLFxuICAgICAgICBzYW1wbGVzOiBub25OdW1lcmljVmFsdWVzLnNsaWNlKDAsIDUpXG4gICAgICB9KVxuICAgIH1cbiAgfSlcblxuICByZXR1cm4gd2FybmluZ3Ncbn1cblxuZnVuY3Rpb24gZ2V0TnVtZXJpY0NvbHVtbnMocGxhdGZvcm06IFBsYXRmb3JtLCBoZWFkZXJzOiBzdHJpbmdbXSk6IHN0cmluZ1tdIHtcbiAgY29uc3QgbnVtZXJpY1BhdHRlcm5zOiBSZWNvcmQ8UGxhdGZvcm0sIHN0cmluZ1tdPiA9IHtcbiAgICBtZXRhOiBbJ2Ftb3VudCcsICdzcGVudCcsICdjb3N0JywgJ2N0cicsICdjcG0nXSxcbiAgICBnb29nbGU6IFsnY29zdCcsICdjdHInLCAnY3BtJ10sXG4gICAgc2hvcGlmeTogWyd2aXNpdG9ycycsICdzZXNzaW9ucycsICdjaGVja291dCcsICdkdXJhdGlvbicsICdwYWdldmlld3MnXVxuICB9XG5cbiAgcmV0dXJuIGhlYWRlcnMuZmlsdGVyKGhlYWRlciA9PiB7XG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZUNvbHVtbk5hbWUoaGVhZGVyKVxuICAgIHJldHVybiBudW1lcmljUGF0dGVybnNbcGxhdGZvcm1dLnNvbWUocGF0dGVybiA9PiBub3JtYWxpemVkLmluY2x1ZGVzKHBhdHRlcm4pKVxuICB9KVxufVxuXG5mdW5jdGlvbiBkZXRlY3REYXRlUmFuZ2UoZGF0YTogYW55W10sIGRhdGVDb2x1bW46IHN0cmluZyB8IHVuZGVmaW5lZCk6IERhdGVSYW5nZSB8IG51bGwge1xuICBpZiAoIWRhdGVDb2x1bW4gfHwgZGF0YS5sZW5ndGggPT09IDApIHJldHVybiBudWxsXG4gIFxuICBjb25zdCBkYXRlcyA9IGRhdGFcbiAgICAubWFwKHJvdyA9PiByb3dbZGF0ZUNvbHVtbl0pXG4gICAgLmZpbHRlcihCb29sZWFuKVxuICAgIC5tYXAoZGF0ZVN0ciA9PiBuZXcgRGF0ZShkYXRlU3RyKSlcbiAgICAuZmlsdGVyKGRhdGUgPT4gIWlzTmFOKGRhdGUuZ2V0VGltZSgpKSlcbiAgICAuc29ydCgpXG5cbiAgaWYgKGRhdGVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGxcblxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBkYXRlc1swXS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF0sXG4gICAgZW5kOiBkYXRlc1tkYXRlcy5sZW5ndGggLSAxXS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF0sXG4gICAgdG90YWxEYXlzOiBNYXRoLmNlaWwoKGRhdGVzW2RhdGVzLmxlbmd0aCAtIDFdLmdldFRpbWUoKSAtIGRhdGVzWzBdLmdldFRpbWUoKSkgLyAoMTAwMCAqIDYwICogNjAgKiAyNCkpICsgMVxuICB9XG59Il0sIm5hbWVzIjpbIlBhcGEiLCJQTEFURk9STV9TQ0hFTUFTIiwibWV0YSIsInJlcXVpcmVkIiwiZGF0ZUNvbHVtbiIsInJlcXVpcmVkRGF0ZUZvcm1hdCIsImFjY2VwdGVkRm9ybWF0cyIsImdvb2dsZSIsInNob3BpZnkiLCJ2YWxpZGF0ZUNTViIsInBsYXRmb3JtIiwiZmlsZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicGFyc2UiLCJoZWFkZXIiLCJwcmV2aWV3IiwiY29tcGxldGUiLCJyZXN1bHRzIiwidmFsaWRhdGlvbiIsInBlcmZvcm1WYWxpZGF0aW9uIiwiZGF0YSIsImZpZWxkcyIsImVycm9yIiwiaXNWYWxpZCIsImhhc0Vycm9ycyIsImhhc1dhcm5pbmdzIiwibmVlZHNDb3JyZWN0aW9uIiwiZXJyb3JzIiwidHlwZSIsIm1lc3NhZ2UiLCJ3YXJuaW5ncyIsInJvd0NvdW50IiwiY29sdW1uQ291bnQiLCJkYXRlUmFuZ2UiLCJoZWFkZXJzIiwic2NoZW1hIiwibWlzc2luZ0NvbHVtbnMiLCJmaWx0ZXIiLCJjb2wiLCJzb21lIiwibm9ybWFsaXplQ29sdW1uTmFtZSIsImxlbmd0aCIsInB1c2giLCJqb2luIiwiY29sdW1ucyIsImZpbmRDb2x1bW5CeU5hbWUiLCJkYXRlVmFsaWRhdGlvbiIsInZhbGlkYXRlRGF0ZUZvcm1hdHMiLCJhbGxvd2VkRm9ybWF0cyIsIm5vblN0YW5kYXJkRm9ybWF0cyIsImRldGVjdGVkRm9ybWF0cyIsImZvcm1hdCIsImluY2x1ZGVzIiwiaW52YWxpZERhdGVzIiwic2xpY2UiLCJtYXAiLCJkIiwidmFsdWUiLCJkZXRhaWxzIiwibnVtZXJpY1ZhbGlkYXRpb24iLCJ2YWxpZGF0ZU51bWVyaWNDb2x1bW5zIiwiZGV0ZWN0RGF0ZVJhbmdlIiwibmFtZSIsInRvTG93ZXJDYXNlIiwidHJpbSIsInJlcGxhY2UiLCJ0YXJnZXROYW1lIiwiZmluZCIsImZvcm1hdHMiLCJTZXQiLCJmb3JFYWNoIiwicm93IiwiaW5kZXgiLCJkYXRlVmFsdWUiLCJkZXRlY3RlZEZvcm1hdCIsImRldGVjdERhdGVGb3JtYXQiLCJhZGQiLCJoYXNJc3N1ZXMiLCJzaXplIiwiQXJyYXkiLCJmcm9tIiwicmVjb21tZW5kZWRGb3JtYXQiLCJkYXRlU3RyaW5nIiwidHJpbW1lZCIsInBhdHRlcm5zIiwicmVnZXgiLCJwYXR0ZXJuIiwidGVzdCIsIm51bWVyaWNDb2x1bW5zIiwiZ2V0TnVtZXJpY0NvbHVtbnMiLCJjb2x1bW4iLCJub25OdW1lcmljVmFsdWVzIiwiaXRlbSIsImlzTmFOIiwicGFyc2VGbG9hdCIsInRvU3RyaW5nIiwic2FtcGxlcyIsIm51bWVyaWNQYXR0ZXJucyIsIm5vcm1hbGl6ZWQiLCJkYXRlcyIsIkJvb2xlYW4iLCJkYXRlU3RyIiwiRGF0ZSIsImRhdGUiLCJnZXRUaW1lIiwic29ydCIsInN0YXJ0IiwidG9JU09TdHJpbmciLCJzcGxpdCIsImVuZCIsInRvdGFsRGF5cyIsIk1hdGgiLCJjZWlsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./lib/validators.ts\n"));

/***/ })

});