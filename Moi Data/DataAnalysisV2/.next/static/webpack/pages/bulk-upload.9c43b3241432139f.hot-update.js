"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/bulk-upload",{

/***/ "./lib/validators.ts":
/*!***************************!*\
  !*** ./lib/validators.ts ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PLATFORM_SCHEMAS: function() { return /* binding */ PLATFORM_SCHEMAS; },\n/* harmony export */   validateCSV: function() { return /* binding */ validateCSV; }\n/* harmony export */ });\n/* harmony import */ var papaparse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! papaparse */ \"./node_modules/papaparse/papaparse.min.js\");\n/* harmony import */ var papaparse__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(papaparse__WEBPACK_IMPORTED_MODULE_0__);\n\nconst PLATFORM_SCHEMAS = {\n    meta: {\n        required: [\n            \"Day\",\n            \"Campaign name\",\n            \"Ad set name\",\n            \"Ad name\",\n            \"Amount spent (INR)\",\n            \"CTR (link click-through rate)\",\n            \"CPM (cost per 1,000 impressions)\"\n        ],\n        dateColumn: \"Day\",\n        requiredDateFormat: \"YYYY-MM-DD\",\n        acceptedFormats: [\n            \"YYYY-MM-DD\"\n        ],\n        orderMatters: false // Meta exports can vary\n    },\n    google: {\n        required: [\n            \"Day\",\n            \"Campaign\",\n            \"Cost\",\n            \"CTR\",\n            \"Avg. CPM\"\n        ],\n        dateColumn: \"Day\",\n        requiredDateFormat: \"YYYY-MM-DD\",\n        acceptedFormats: [\n            \"YYYY-MM-DD\"\n        ],\n        orderMatters: false // Google Ads exports are flexible\n    },\n    shopify: {\n        required: [\n            \"Day\",\n            \"UTM campaign\",\n            \"UTM term\",\n            \"UTM content\",\n            \"Online store visitors\",\n            \"Sessions that completed checkout\"\n        ],\n        dateColumn: \"Day\",\n        requiredDateFormat: \"YYYY-MM-DD\",\n        acceptedFormats: [\n            \"YYYY-MM-DD\"\n        ],\n        orderMatters: false // Shopify reports are flexible\n    }\n};\nasync function validateCSV(platform, file) {\n    return new Promise((resolve)=>{\n        papaparse__WEBPACK_IMPORTED_MODULE_0___default().parse(file, {\n            header: true,\n            preview: 100,\n            complete: (results)=>{\n                const validation = performValidation(platform, results.data, results.meta.fields || []);\n                resolve(validation);\n            },\n            error: (error)=>{\n                resolve({\n                    isValid: false,\n                    hasErrors: true,\n                    hasWarnings: false,\n                    needsCorrection: false,\n                    errors: [\n                        {\n                            type: \"parse_error\",\n                            message: error.message\n                        }\n                    ],\n                    warnings: [],\n                    rowCount: 0,\n                    columnCount: 0,\n                    dateRange: null\n                });\n            }\n        });\n    });\n}\nfunction performValidation(platform, data, headers) {\n    const schema = PLATFORM_SCHEMAS[platform];\n    const errors = [];\n    const warnings = [];\n    // Clean headers (remove BOM, trim whitespace)\n    const cleanHeaders = headers.map((h)=>h.replace(/^\\ufeff/, \"\").trim());\n    // Check for case-sensitive column matching issues\n    const columnMappingIssues = [];\n    for (const requiredCol of schema.required){\n        // Try exact match first\n        const exactMatch = cleanHeaders.find((h)=>h === requiredCol);\n        if (exactMatch) continue;\n        // Try case-insensitive match\n        const caseInsensitiveMatch = cleanHeaders.find((h)=>h.toLowerCase() === requiredCol.toLowerCase());\n        if (caseInsensitiveMatch) {\n            columnMappingIssues.push({\n                required: requiredCol,\n                found: caseInsensitiveMatch,\n                issue: \"case_mismatch\"\n            });\n        } else {\n            // Try fuzzy match (similar names)\n            const fuzzyMatch = cleanHeaders.find((h)=>normalizeColumnName(h) === normalizeColumnName(requiredCol));\n            if (fuzzyMatch) {\n                columnMappingIssues.push({\n                    required: requiredCol,\n                    found: fuzzyMatch,\n                    issue: \"name_variation\"\n                });\n            } else {\n                columnMappingIssues.push({\n                    required: requiredCol,\n                    issue: \"missing\"\n                });\n            }\n        }\n    }\n    // Report column issues\n    const missingColumns = columnMappingIssues.filter((issue)=>issue.issue === \"missing\");\n    const caseMismatchColumns = columnMappingIssues.filter((issue)=>issue.issue === \"case_mismatch\");\n    const nameVariationColumns = columnMappingIssues.filter((issue)=>issue.issue === \"name_variation\");\n    if (missingColumns.length > 0) {\n        errors.push({\n            type: \"missing_columns\",\n            message: \"Missing required columns: \".concat(missingColumns.map((c)=>c.required).join(\", \")),\n            howToFix: \"Add the missing columns to your CSV file with the exact names shown above\",\n            examples: [\n                \"Open your CSV in Excel/Google Sheets\",\n                \"Add new columns with headers: \" + missingColumns.map((c)=>'\"'.concat(c.required, '\"')).join(\", \"),\n                \"Fill with appropriate data or leave empty if no data available\"\n            ],\n            columns: missingColumns.map((c)=>c.required)\n        });\n    }\n    if (caseMismatchColumns.length > 0) {\n        errors.push({\n            type: \"column_case_mismatch\",\n            message: \"Column case mismatch found: \".concat(caseMismatchColumns.map((c)=>'\"'.concat(c.found, '\" should be \"').concat(c.required, '\"')).join(\", \")),\n            howToFix: \"Update column headers to match the exact case (uppercase/lowercase) required\",\n            examples: [\n                \"Open your CSV file in Excel/Google Sheets\",\n                ...caseMismatchColumns.map((c)=>'Rename \"'.concat(c.found, '\" to \"').concat(c.required, '\"')),\n                \"Save the file and re-upload\"\n            ],\n            columns: caseMismatchColumns.map((c)=>c.required)\n        });\n    }\n    if (nameVariationColumns.length > 0) {\n        warnings.push({\n            type: \"column_name_variations\",\n            message: \"Column name variations detected: \".concat(nameVariationColumns.map((c)=>'\"'.concat(c.found, '\" might be \"').concat(c.required, '\"')).join(\", \")),\n            howToFix: \"Verify and rename columns to match exact required names\",\n            examples: [\n                \"Check if these column mappings are correct:\",\n                ...nameVariationColumns.map((c)=>'\"'.concat(c.found, '\" → \"').concat(c.required, '\"')),\n                \"Rename columns if needed and re-upload\"\n            ],\n            details: nameVariationColumns\n        });\n    }\n    // Check for unexpected columns that might indicate wrong platform\n    const unexpectedColumns = cleanHeaders.filter((header)=>!schema.required.some((req)=>normalizeColumnName(header) === normalizeColumnName(req)));\n    if (unexpectedColumns.length > 0 && unexpectedColumns.length > 3) {\n        warnings.push({\n            type: \"unexpected_columns\",\n            message: \"Many unexpected columns found (\".concat(unexpectedColumns.length, \"). Verify this is the correct platform.\"),\n            howToFix: \"Verify you selected the correct platform or remove unnecessary columns\",\n            examples: [\n                \"Check if this is the right platform (Meta/Google/Shopify)\",\n                \"Unexpected columns: \" + unexpectedColumns.slice(0, 5).join(\", \"),\n                \"Remove columns not needed for this platform\",\n                \"Or select different platform if this CSV is for another service\"\n            ],\n            details: {\n                unexpectedColumns: unexpectedColumns.slice(0, 5)\n            }\n        });\n    }\n    // Check for common CSV formatting issues\n    if (headers.some((h)=>h.includes(\"\\uFEFF\"))) {\n        warnings.push({\n            type: \"bom_detected\",\n            message: \"BOM (Byte Order Mark) detected in CSV headers. This may cause parsing issues.\",\n            howToFix: \"Save CSV file as UTF-8 without BOM\",\n            examples: [\n                \"Open file in Notepad++ or VS Code\",\n                \"Go to Encoding → Convert to UTF-8 (without BOM)\",\n                \"Or in Excel: File → Save As → CSV UTF-8\",\n                \"Re-upload the converted file\"\n            ],\n            details: {\n                note: \"Save file as UTF-8 without BOM\"\n            }\n        });\n    }\n    // Check for empty headers\n    const emptyHeaders = cleanHeaders.filter((h)=>!h || h.trim() === \"\");\n    if (emptyHeaders.length > 0) {\n        errors.push({\n            type: \"empty_headers\",\n            message: \"Found \".concat(emptyHeaders.length, \" empty column headers. All columns must have names.\"),\n            howToFix: \"Add names to all empty column headers\",\n            examples: [\n                \"Open your CSV file\",\n                \"Find columns with empty/blank headers\",\n                'Add descriptive names like: \"Column1\", \"Data\", \"Notes\", etc.',\n                \"Or remove empty columns if not needed\"\n            ],\n            columns: [\n                \"\".concat(emptyHeaders.length, \" empty headers\")\n            ]\n        });\n    }\n    // Check for duplicate headers\n    const duplicateHeaders = cleanHeaders.filter((header, index)=>cleanHeaders.indexOf(header) !== index);\n    if (duplicateHeaders.length > 0) {\n        errors.push({\n            type: \"duplicate_headers\",\n            message: \"Duplicate column headers found: \".concat([\n                ...new Set(duplicateHeaders)\n            ].join(\", \")),\n            howToFix: \"Rename duplicate column headers to unique names\",\n            examples: [\n                \"Find duplicate columns: \" + [\n                    ...new Set(duplicateHeaders)\n                ].join(\", \"),\n                'Rename them to unique names like: \"Campaign_1\", \"Campaign_2\"',\n                \"Or remove duplicate columns if identical data\",\n                \"Save and re-upload\"\n            ],\n            columns: duplicateHeaders\n        });\n    }\n    // Validate date formats (STRICT - must be YYYY-MM-DD)\n    const dateColumn = findColumnByName(cleanHeaders, schema.dateColumn);\n    if (dateColumn) {\n        const dateValidation = validateDateFormats(data, dateColumn);\n        // Check for wrong date formats - make this an ERROR not warning\n        const allowedFormats = schema.acceptedFormats;\n        const nonStandardFormats = dateValidation.detectedFormats.filter((format)=>!allowedFormats.includes(format));\n        if (nonStandardFormats.length > 0) {\n            errors.push({\n                type: \"invalid_date_format\",\n                message: \"Date column '\".concat(dateColumn, \"' must use \").concat(schema.requiredDateFormat, \" format. Found: \").concat(nonStandardFormats.join(\", \")),\n                howToFix: \"Convert all dates in '\".concat(dateColumn, \"' column to YYYY-MM-DD format\"),\n                examples: [\n                    \"Open CSV in Excel/Google Sheets\",\n                    \"Select the entire Date column\",\n                    \"Format cells as Custom: YYYY-MM-DD (e.g., 2025-11-10)\",\n                    \"Or use find/replace: 10/11/2025 → 2025-11-10\",\n                    \"Save as CSV and re-upload\"\n                ],\n                columns: [\n                    dateColumn\n                ]\n            });\n        }\n        // Check for invalid/unparseable dates\n        if (dateValidation.invalidDates.length > 0) {\n            errors.push({\n                type: \"invalid_date_values\",\n                message: \"Invalid date values found in '\".concat(dateColumn, \"': \").concat(dateValidation.invalidDates.slice(0, 3).map((d)=>d.value).join(\", \")),\n                howToFix: \"Fix or remove invalid date entries\",\n                examples: [\n                    \"Check these invalid dates: \" + dateValidation.invalidDates.slice(0, 3).map((d)=>'\"'.concat(d.value, '\"')).join(\", \"),\n                    \"Replace with valid dates in YYYY-MM-DD format\",\n                    \"Or remove rows with invalid dates if not needed\",\n                    \"Common valid formats: 2025-11-10, 2025-01-01\"\n                ],\n                columns: [\n                    dateColumn\n                ]\n            });\n        }\n        // Only add warnings for minor issues if no errors\n        if (nonStandardFormats.length === 0 && dateValidation.invalidDates.length === 0 && dateValidation.detectedFormats.length > 1) {\n            warnings.push({\n                type: \"date_format_inconsistency\",\n                message: \"Multiple date formats detected in \".concat(dateColumn),\n                details: dateValidation\n            });\n        }\n    }\n    // Validate numeric columns\n    const numericValidation = validateNumericColumns(platform, data, cleanHeaders);\n    warnings.push(...numericValidation);\n    return {\n        isValid: errors.length === 0,\n        hasErrors: errors.length > 0,\n        hasWarnings: warnings.length > 0,\n        needsCorrection: warnings.length > 0,\n        errors,\n        warnings,\n        rowCount: data.length,\n        columnCount: headers.length,\n        dateRange: detectDateRange(data, dateColumn)\n    };\n}\nfunction normalizeColumnName(name) {\n    return name.toLowerCase().trim().replace(/[^\\w]/g, \"_\");\n}\nfunction findColumnByName(headers, targetName) {\n    return headers.find((header)=>normalizeColumnName(header) === normalizeColumnName(targetName));\n}\nfunction validateDateFormats(data, dateColumn) {\n    const formats = new Set();\n    const invalidDates = [];\n    data.slice(0, 50).forEach((row, index)=>{\n        const dateValue = row[dateColumn];\n        if (dateValue) {\n            const detectedFormat = detectDateFormat(dateValue);\n            if (detectedFormat) {\n                formats.add(detectedFormat);\n            } else {\n                invalidDates.push({\n                    row: index,\n                    value: dateValue\n                });\n            }\n        }\n    });\n    return {\n        hasIssues: formats.size > 1 || invalidDates.length > 0,\n        detectedFormats: Array.from(formats),\n        invalidDates,\n        recommendedFormat: \"YYYY-MM-DD\"\n    };\n}\nfunction detectDateFormat(dateString) {\n    const trimmed = dateString.trim();\n    const patterns = [\n        {\n            regex: /^\\d{4}-\\d{2}-\\d{2}$/,\n            format: \"YYYY-MM-DD\"\n        },\n        {\n            regex: /^\\d{2}-\\d{2}-\\d{4}$/,\n            format: \"DD-MM-YYYY\"\n        },\n        {\n            regex: /^\\d{1,2}\\/\\d{1,2}\\/\\d{4}$/,\n            format: \"DD/MM/YYYY\"\n        },\n        {\n            regex: /^\\d{2}\\/\\d{2}\\/\\d{4}$/,\n            format: \"DD/MM/YYYY\"\n        },\n        {\n            regex: /^\\d{4}\\/\\d{2}\\/\\d{2}$/,\n            format: \"YYYY/MM/DD\"\n        },\n        {\n            regex: /^\\d{2}\\.\\d{2}\\.\\d{4}$/,\n            format: \"DD.MM.YYYY\"\n        }\n    ];\n    for (const pattern of patterns){\n        if (pattern.regex.test(trimmed)) {\n            return pattern.format;\n        }\n    }\n    return null;\n}\nfunction validateNumericColumns(platform, data, headers) {\n    const warnings = [];\n    const numericColumns = getNumericColumns(platform, headers);\n    numericColumns.forEach((column)=>{\n        const nonNumericValues = data.slice(0, 50).map((row, index)=>({\n                index,\n                value: row[column]\n            })).filter((item)=>item.value && isNaN(parseFloat(item.value.toString().replace(/[,%]/g, \"\"))));\n        if (nonNumericValues.length > 0) {\n            warnings.push({\n                type: \"non_numeric_values\",\n                message: \"Non-numeric values detected in \".concat(column),\n                howToFix: \"Clean numeric data in '\".concat(column, \"' column\"),\n                examples: [\n                    \"Remove currency symbols: $1,234.56 → 1234.56\",\n                    \"Remove percentage signs: 24.78% → 24.78\",\n                    \"Remove commas: 1,234 → 1234\",\n                    \"Replace text with numbers or leave empty\",\n                    \"Examples found: \" + nonNumericValues.slice(0, 3).map((v)=>'\"'.concat(v.value, '\"')).join(\", \")\n                ],\n                column,\n                samples: nonNumericValues.slice(0, 5)\n            });\n        }\n    });\n    return warnings;\n}\nfunction getNumericColumns(platform, headers) {\n    const numericPatterns = {\n        meta: [\n            \"amount\",\n            \"spent\",\n            \"cost\",\n            \"ctr\",\n            \"cpm\"\n        ],\n        google: [\n            \"cost\",\n            \"ctr\",\n            \"cpm\"\n        ],\n        shopify: [\n            \"visitors\",\n            \"sessions\",\n            \"checkout\",\n            \"duration\",\n            \"pageviews\"\n        ]\n    };\n    return headers.filter((header)=>{\n        const normalized = normalizeColumnName(header);\n        return numericPatterns[platform].some((pattern)=>normalized.includes(pattern));\n    });\n}\nfunction detectDateRange(data, dateColumn) {\n    if (!dateColumn || data.length === 0) return null;\n    const dates = data.map((row)=>row[dateColumn]).filter(Boolean).map((dateStr)=>new Date(dateStr)).filter((date)=>!isNaN(date.getTime())).sort();\n    if (dates.length === 0) return null;\n    return {\n        start: dates[0].toISOString().split(\"T\")[0],\n        end: dates[dates.length - 1].toISOString().split(\"T\")[0],\n        totalDays: Math.ceil((dates[dates.length - 1].getTime() - dates[0].getTime()) / (1000 * 60 * 60 * 24)) + 1\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvdmFsaWRhdG9ycy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTRCO0FBdUNyQixNQUFNQyxtQkFPUjtJQUNIQyxNQUFNO1FBQ0pDLFVBQVU7WUFDUjtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtTQUNEO1FBQ0RDLFlBQVk7UUFDWkMsb0JBQW9CO1FBQ3BCQyxpQkFBaUI7WUFBQztTQUFhO1FBQy9CQyxjQUFjLE1BQU0sd0JBQXdCO0lBQzlDO0lBQ0FDLFFBQVE7UUFDTkwsVUFBVTtZQUNSO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7U0FDRDtRQUNEQyxZQUFZO1FBQ1pDLG9CQUFvQjtRQUNwQkMsaUJBQWlCO1lBQUM7U0FBYTtRQUMvQkMsY0FBYyxNQUFNLGtDQUFrQztJQUN4RDtJQUNBRSxTQUFTO1FBQ1BOLFVBQVU7WUFDUjtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7U0FDRDtRQUNEQyxZQUFZO1FBQ1pDLG9CQUFvQjtRQUNwQkMsaUJBQWlCO1lBQUM7U0FBYTtRQUMvQkMsY0FBYyxNQUFNLCtCQUErQjtJQUNyRDtBQUNGLEVBQUM7QUFFTSxlQUFlRyxZQUFZQyxRQUFrQixFQUFFQyxJQUFVO0lBQzlELE9BQU8sSUFBSUMsUUFBUSxDQUFDQztRQUNsQmQsc0RBQVUsQ0FBQ1ksTUFBTTtZQUNmSSxRQUFRO1lBQ1JDLFNBQVM7WUFDVEMsVUFBVSxDQUFDQztnQkFDVCxNQUFNQyxhQUFhQyxrQkFBa0JWLFVBQVVRLFFBQVFHLElBQUksRUFBRUgsUUFBUWpCLElBQUksQ0FBQ3FCLE1BQU0sSUFBSSxFQUFFO2dCQUN0RlQsUUFBUU07WUFDVjtZQUNBSSxPQUFPLENBQUNBO2dCQUNOVixRQUFRO29CQUNOVyxTQUFTO29CQUNUQyxXQUFXO29CQUNYQyxhQUFhO29CQUNiQyxpQkFBaUI7b0JBQ2pCQyxRQUFRO3dCQUFDOzRCQUFFQyxNQUFNOzRCQUFlQyxTQUFTUCxNQUFNTyxPQUFPO3dCQUFDO3FCQUFFO29CQUN6REMsVUFBVSxFQUFFO29CQUNaQyxVQUFVO29CQUNWQyxhQUFhO29CQUNiQyxXQUFXO2dCQUNiO1lBQ0Y7UUFDRjtJQUNGO0FBQ0Y7QUFFQSxTQUFTZCxrQkFBa0JWLFFBQWtCLEVBQUVXLElBQVcsRUFBRWMsT0FBaUI7SUFDM0UsTUFBTUMsU0FBU3BDLGdCQUFnQixDQUFDVSxTQUFTO0lBQ3pDLE1BQU1rQixTQUE0QixFQUFFO0lBQ3BDLE1BQU1HLFdBQWdDLEVBQUU7SUFFeEMsOENBQThDO0lBQzlDLE1BQU1NLGVBQWVGLFFBQVFHLEdBQUcsQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRUMsT0FBTyxDQUFDLFdBQVcsSUFBSUMsSUFBSTtJQUVuRSxrREFBa0Q7SUFDbEQsTUFBTUMsc0JBQWdGLEVBQUU7SUFFeEYsS0FBSyxNQUFNQyxlQUFlUCxPQUFPbEMsUUFBUSxDQUFFO1FBQ3pDLHdCQUF3QjtRQUN4QixNQUFNMEMsYUFBYVAsYUFBYVEsSUFBSSxDQUFDTixDQUFBQSxJQUFLQSxNQUFNSTtRQUNoRCxJQUFJQyxZQUFZO1FBRWhCLDZCQUE2QjtRQUM3QixNQUFNRSx1QkFBdUJULGFBQWFRLElBQUksQ0FBQ04sQ0FBQUEsSUFDN0NBLEVBQUVRLFdBQVcsT0FBT0osWUFBWUksV0FBVztRQUc3QyxJQUFJRCxzQkFBc0I7WUFDeEJKLG9CQUFvQk0sSUFBSSxDQUFDO2dCQUN2QjlDLFVBQVV5QztnQkFDVk0sT0FBT0g7Z0JBQ1BJLE9BQU87WUFDVDtRQUNGLE9BQU87WUFDTCxrQ0FBa0M7WUFDbEMsTUFBTUMsYUFBYWQsYUFBYVEsSUFBSSxDQUFDTixDQUFBQSxJQUNuQ2Esb0JBQW9CYixPQUFPYSxvQkFBb0JUO1lBR2pELElBQUlRLFlBQVk7Z0JBQ2RULG9CQUFvQk0sSUFBSSxDQUFDO29CQUN2QjlDLFVBQVV5QztvQkFDVk0sT0FBT0U7b0JBQ1BELE9BQU87Z0JBQ1Q7WUFDRixPQUFPO2dCQUNMUixvQkFBb0JNLElBQUksQ0FBQztvQkFDdkI5QyxVQUFVeUM7b0JBQ1ZPLE9BQU87Z0JBQ1Q7WUFDRjtRQUNGO0lBQ0Y7SUFFQSx1QkFBdUI7SUFDdkIsTUFBTUcsaUJBQWlCWCxvQkFBb0JZLE1BQU0sQ0FBQ0osQ0FBQUEsUUFBU0EsTUFBTUEsS0FBSyxLQUFLO0lBQzNFLE1BQU1LLHNCQUFzQmIsb0JBQW9CWSxNQUFNLENBQUNKLENBQUFBLFFBQVNBLE1BQU1BLEtBQUssS0FBSztJQUNoRixNQUFNTSx1QkFBdUJkLG9CQUFvQlksTUFBTSxDQUFDSixDQUFBQSxRQUFTQSxNQUFNQSxLQUFLLEtBQUs7SUFFakYsSUFBSUcsZUFBZUksTUFBTSxHQUFHLEdBQUc7UUFDN0I3QixPQUFPb0IsSUFBSSxDQUFDO1lBQ1ZuQixNQUFNO1lBQ05DLFNBQVMsNkJBQTRFLE9BQS9DdUIsZUFBZWYsR0FBRyxDQUFDb0IsQ0FBQUEsSUFBS0EsRUFBRXhELFFBQVEsRUFBRXlELElBQUksQ0FBQztZQUMvRUMsVUFBVTtZQUNWQyxVQUFVO2dCQUNSO2dCQUNBLG1DQUFtQ1IsZUFBZWYsR0FBRyxDQUFDb0IsQ0FBQUEsSUFBSyxJQUFlLE9BQVhBLEVBQUV4RCxRQUFRLEVBQUMsTUFBSXlELElBQUksQ0FBQztnQkFDbkY7YUFDRDtZQUNERyxTQUFTVCxlQUFlZixHQUFHLENBQUNvQixDQUFBQSxJQUFLQSxFQUFFeEQsUUFBUTtRQUM3QztJQUNGO0lBRUEsSUFBSXFELG9CQUFvQkUsTUFBTSxHQUFHLEdBQUc7UUFDbEM3QixPQUFPb0IsSUFBSSxDQUFDO1lBQ1ZuQixNQUFNO1lBQ05DLFNBQVMsK0JBQWlILE9BQWxGeUIsb0JBQW9CakIsR0FBRyxDQUFDb0IsQ0FBQUEsSUFBSyxJQUEyQkEsT0FBdkJBLEVBQUVULEtBQUssRUFBQyxpQkFBMEIsT0FBWFMsRUFBRXhELFFBQVEsRUFBQyxNQUFJeUQsSUFBSSxDQUFDO1lBQ3BIQyxVQUFVO1lBQ1ZDLFVBQVU7Z0JBQ1I7bUJBQ0dOLG9CQUFvQmpCLEdBQUcsQ0FBQ29CLENBQUFBLElBQUssV0FBMkJBLE9BQWhCQSxFQUFFVCxLQUFLLEVBQUMsVUFBbUIsT0FBWFMsRUFBRXhELFFBQVEsRUFBQztnQkFDdEU7YUFDRDtZQUNENEQsU0FBU1Asb0JBQW9CakIsR0FBRyxDQUFDb0IsQ0FBQUEsSUFBS0EsRUFBRXhELFFBQVE7UUFDbEQ7SUFDRjtJQUVBLElBQUlzRCxxQkFBcUJDLE1BQU0sR0FBRyxHQUFHO1FBQ25DMUIsU0FBU2lCLElBQUksQ0FBQztZQUNabkIsTUFBTTtZQUNOQyxTQUFTLG9DQUFzSCxPQUFsRjBCLHFCQUFxQmxCLEdBQUcsQ0FBQ29CLENBQUFBLElBQUssSUFBMEJBLE9BQXRCQSxFQUFFVCxLQUFLLEVBQUMsZ0JBQXlCLE9BQVhTLEVBQUV4RCxRQUFRLEVBQUMsTUFBSXlELElBQUksQ0FBQztZQUN6SEMsVUFBVTtZQUNWQyxVQUFVO2dCQUNSO21CQUNHTCxxQkFBcUJsQixHQUFHLENBQUNvQixDQUFBQSxJQUFLLElBQW1CQSxPQUFmQSxFQUFFVCxLQUFLLEVBQUMsU0FBa0IsT0FBWFMsRUFBRXhELFFBQVEsRUFBQztnQkFDL0Q7YUFDRDtZQUNENkQsU0FBU1A7UUFDWDtJQUNGO0lBRUEsa0VBQWtFO0lBQ2xFLE1BQU1RLG9CQUFvQjNCLGFBQWFpQixNQUFNLENBQUN2QyxDQUFBQSxTQUM1QyxDQUFDcUIsT0FBT2xDLFFBQVEsQ0FBQytELElBQUksQ0FBQ0MsQ0FBQUEsTUFBT2Qsb0JBQW9CckMsWUFBWXFDLG9CQUFvQmM7SUFHbkYsSUFBSUYsa0JBQWtCUCxNQUFNLEdBQUcsS0FBS08sa0JBQWtCUCxNQUFNLEdBQUcsR0FBRztRQUNoRTFCLFNBQVNpQixJQUFJLENBQUM7WUFDWm5CLE1BQU07WUFDTkMsU0FBUyxrQ0FBMkQsT0FBekJrQyxrQkFBa0JQLE1BQU0sRUFBQztZQUNwRUcsVUFBVTtZQUNWQyxVQUFVO2dCQUNSO2dCQUNBLHlCQUF5Qkcsa0JBQWtCRyxLQUFLLENBQUMsR0FBRyxHQUFHUixJQUFJLENBQUM7Z0JBQzVEO2dCQUNBO2FBQ0Q7WUFDREksU0FBUztnQkFBRUMsbUJBQW1CQSxrQkFBa0JHLEtBQUssQ0FBQyxHQUFHO1lBQUc7UUFDOUQ7SUFDRjtJQUVBLHlDQUF5QztJQUN6QyxJQUFJaEMsUUFBUThCLElBQUksQ0FBQzFCLENBQUFBLElBQUtBLEVBQUU2QixRQUFRLENBQUMsWUFBWTtRQUMzQ3JDLFNBQVNpQixJQUFJLENBQUM7WUFDWm5CLE1BQU07WUFDTkMsU0FBUztZQUNUOEIsVUFBVTtZQUNWQyxVQUFVO2dCQUNSO2dCQUNBO2dCQUNBO2dCQUNBO2FBQ0Q7WUFDREUsU0FBUztnQkFBRU0sTUFBTTtZQUFpQztRQUNwRDtJQUNGO0lBRUEsMEJBQTBCO0lBQzFCLE1BQU1DLGVBQWVqQyxhQUFhaUIsTUFBTSxDQUFDZixDQUFBQSxJQUFLLENBQUNBLEtBQUtBLEVBQUVFLElBQUksT0FBTztJQUNqRSxJQUFJNkIsYUFBYWIsTUFBTSxHQUFHLEdBQUc7UUFDM0I3QixPQUFPb0IsSUFBSSxDQUFDO1lBQ1ZuQixNQUFNO1lBQ05DLFNBQVMsU0FBNkIsT0FBcEJ3QyxhQUFhYixNQUFNLEVBQUM7WUFDdENHLFVBQVU7WUFDVkMsVUFBVTtnQkFDUjtnQkFDQTtnQkFDQTtnQkFDQTthQUNEO1lBQ0RDLFNBQVM7Z0JBQUUsR0FBc0IsT0FBcEJRLGFBQWFiLE1BQU0sRUFBQzthQUFnQjtRQUNuRDtJQUNGO0lBRUEsOEJBQThCO0lBQzlCLE1BQU1jLG1CQUFtQmxDLGFBQWFpQixNQUFNLENBQUMsQ0FBQ3ZDLFFBQVF5RCxRQUNwRG5DLGFBQWFvQyxPQUFPLENBQUMxRCxZQUFZeUQ7SUFFbkMsSUFBSUQsaUJBQWlCZCxNQUFNLEdBQUcsR0FBRztRQUMvQjdCLE9BQU9vQixJQUFJLENBQUM7WUFDVm5CLE1BQU07WUFDTkMsU0FBUyxtQ0FBNkUsT0FBMUM7bUJBQUksSUFBSTRDLElBQUlIO2FBQWtCLENBQUNaLElBQUksQ0FBQztZQUNoRkMsVUFBVTtZQUNWQyxVQUFVO2dCQUNSLDZCQUE2Qjt1QkFBSSxJQUFJYSxJQUFJSDtpQkFBa0IsQ0FBQ1osSUFBSSxDQUFDO2dCQUNqRTtnQkFDQTtnQkFDQTthQUNEO1lBQ0RHLFNBQVNTO1FBQ1g7SUFDRjtJQUVBLHNEQUFzRDtJQUN0RCxNQUFNcEUsYUFBYXdFLGlCQUFpQnRDLGNBQWNELE9BQU9qQyxVQUFVO0lBQ25FLElBQUlBLFlBQVk7UUFDZCxNQUFNeUUsaUJBQWlCQyxvQkFBb0J4RCxNQUFNbEI7UUFFakQsZ0VBQWdFO1FBQ2hFLE1BQU0yRSxpQkFBaUIxQyxPQUFPL0IsZUFBZTtRQUM3QyxNQUFNMEUscUJBQXFCSCxlQUFlSSxlQUFlLENBQUMxQixNQUFNLENBQUMyQixDQUFBQSxTQUFVLENBQUNILGVBQWVWLFFBQVEsQ0FBQ2E7UUFDcEcsSUFBSUYsbUJBQW1CdEIsTUFBTSxHQUFHLEdBQUc7WUFDakM3QixPQUFPb0IsSUFBSSxDQUFDO2dCQUNWbkIsTUFBTTtnQkFDTkMsU0FBUyxnQkFBd0NNLE9BQXhCakMsWUFBVyxlQUF5RDRFLE9BQTVDM0MsT0FBT2hDLGtCQUFrQixFQUFDLG9CQUFnRCxPQUE5QjJFLG1CQUFtQnBCLElBQUksQ0FBQztnQkFDckhDLFVBQVUseUJBQW9DLE9BQVh6RCxZQUFXO2dCQUM5QzBELFVBQVU7b0JBQ1I7b0JBQ0E7b0JBQ0E7b0JBQ0E7b0JBQ0E7aUJBQ0Q7Z0JBQ0RDLFNBQVM7b0JBQUMzRDtpQkFBVztZQUN2QjtRQUNGO1FBRUEsc0NBQXNDO1FBQ3RDLElBQUl5RSxlQUFlTSxZQUFZLENBQUN6QixNQUFNLEdBQUcsR0FBRztZQUMxQzdCLE9BQU9vQixJQUFJLENBQUM7Z0JBQ1ZuQixNQUFNO2dCQUNOQyxTQUFTLGlDQUFpRDhDLE9BQWhCekUsWUFBVyxPQUEwRSxPQUFyRXlFLGVBQWVNLFlBQVksQ0FBQ2YsS0FBSyxDQUFDLEdBQUcsR0FBRzdCLEdBQUcsQ0FBQzZDLENBQUFBLElBQUtBLEVBQUVDLEtBQUssRUFBRXpCLElBQUksQ0FBQztnQkFDekhDLFVBQVU7Z0JBQ1ZDLFVBQVU7b0JBQ1IsZ0NBQWdDZSxlQUFlTSxZQUFZLENBQUNmLEtBQUssQ0FBQyxHQUFHLEdBQUc3QixHQUFHLENBQUM2QyxDQUFBQSxJQUFLLElBQVksT0FBUkEsRUFBRUMsS0FBSyxFQUFDLE1BQUl6QixJQUFJLENBQUM7b0JBQ3RHO29CQUNBO29CQUNBO2lCQUNEO2dCQUNERyxTQUFTO29CQUFDM0Q7aUJBQVc7WUFDdkI7UUFDRjtRQUVBLGtEQUFrRDtRQUNsRCxJQUFJNEUsbUJBQW1CdEIsTUFBTSxLQUFLLEtBQUttQixlQUFlTSxZQUFZLENBQUN6QixNQUFNLEtBQUssS0FBS21CLGVBQWVJLGVBQWUsQ0FBQ3ZCLE1BQU0sR0FBRyxHQUFHO1lBQzVIMUIsU0FBU2lCLElBQUksQ0FBQztnQkFDWm5CLE1BQU07Z0JBQ05DLFNBQVMscUNBQWdELE9BQVgzQjtnQkFDOUM0RCxTQUFTYTtZQUNYO1FBQ0Y7SUFDRjtJQUVBLDJCQUEyQjtJQUMzQixNQUFNUyxvQkFBb0JDLHVCQUF1QjVFLFVBQVVXLE1BQU1nQjtJQUNqRU4sU0FBU2lCLElBQUksSUFBSXFDO0lBRWpCLE9BQU87UUFDTDdELFNBQVNJLE9BQU82QixNQUFNLEtBQUs7UUFDM0JoQyxXQUFXRyxPQUFPNkIsTUFBTSxHQUFHO1FBQzNCL0IsYUFBYUssU0FBUzBCLE1BQU0sR0FBRztRQUMvQjlCLGlCQUFpQkksU0FBUzBCLE1BQU0sR0FBRztRQUNuQzdCO1FBQ0FHO1FBQ0FDLFVBQVVYLEtBQUtvQyxNQUFNO1FBQ3JCeEIsYUFBYUUsUUFBUXNCLE1BQU07UUFDM0J2QixXQUFXcUQsZ0JBQWdCbEUsTUFBTWxCO0lBQ25DO0FBQ0Y7QUFFQSxTQUFTaUQsb0JBQW9Cb0MsSUFBWTtJQUN2QyxPQUFPQSxLQUFLekMsV0FBVyxHQUFHTixJQUFJLEdBQUdELE9BQU8sQ0FBQyxVQUFVO0FBQ3JEO0FBRUEsU0FBU21DLGlCQUFpQnhDLE9BQWlCLEVBQUVzRCxVQUFrQjtJQUM3RCxPQUFPdEQsUUFBUVUsSUFBSSxDQUFDOUIsQ0FBQUEsU0FDbEJxQyxvQkFBb0JyQyxZQUFZcUMsb0JBQW9CcUM7QUFFeEQ7QUFFQSxTQUFTWixvQkFBb0J4RCxJQUFXLEVBQUVsQixVQUFrQjtJQUMxRCxNQUFNdUYsVUFBVSxJQUFJaEI7SUFDcEIsTUFBTVEsZUFBc0IsRUFBRTtJQUU5QjdELEtBQUs4QyxLQUFLLENBQUMsR0FBRyxJQUFJd0IsT0FBTyxDQUFDLENBQUNDLEtBQUtwQjtRQUM5QixNQUFNcUIsWUFBWUQsR0FBRyxDQUFDekYsV0FBVztRQUNqQyxJQUFJMEYsV0FBVztZQUNiLE1BQU1DLGlCQUFpQkMsaUJBQWlCRjtZQUN4QyxJQUFJQyxnQkFBZ0I7Z0JBQ2xCSixRQUFRTSxHQUFHLENBQUNGO1lBQ2QsT0FBTztnQkFDTFosYUFBYWxDLElBQUksQ0FBQztvQkFBRTRDLEtBQUtwQjtvQkFBT1ksT0FBT1M7Z0JBQVU7WUFDbkQ7UUFDRjtJQUNGO0lBRUEsT0FBTztRQUNMSSxXQUFXUCxRQUFRUSxJQUFJLEdBQUcsS0FBS2hCLGFBQWF6QixNQUFNLEdBQUc7UUFDckR1QixpQkFBaUJtQixNQUFNQyxJQUFJLENBQUNWO1FBQzVCUjtRQUNBbUIsbUJBQW1CO0lBQ3JCO0FBQ0Y7QUFFQSxTQUFTTixpQkFBaUJPLFVBQWtCO0lBQzFDLE1BQU1DLFVBQVVELFdBQVc3RCxJQUFJO0lBRS9CLE1BQU0rRCxXQUFXO1FBQ2Y7WUFBRUMsT0FBTztZQUF1QnhCLFFBQVE7UUFBYTtRQUNyRDtZQUFFd0IsT0FBTztZQUF1QnhCLFFBQVE7UUFBYTtRQUNyRDtZQUFFd0IsT0FBTztZQUE2QnhCLFFBQVE7UUFBYTtRQUMzRDtZQUFFd0IsT0FBTztZQUF5QnhCLFFBQVE7UUFBYTtRQUN2RDtZQUFFd0IsT0FBTztZQUF5QnhCLFFBQVE7UUFBYTtRQUN2RDtZQUFFd0IsT0FBTztZQUF5QnhCLFFBQVE7UUFBYTtLQUN4RDtJQUVELEtBQUssTUFBTXlCLFdBQVdGLFNBQVU7UUFDOUIsSUFBSUUsUUFBUUQsS0FBSyxDQUFDRSxJQUFJLENBQUNKLFVBQVU7WUFDL0IsT0FBT0csUUFBUXpCLE1BQU07UUFDdkI7SUFDRjtJQUNBLE9BQU87QUFDVDtBQUVBLFNBQVNLLHVCQUF1QjVFLFFBQWtCLEVBQUVXLElBQVcsRUFBRWMsT0FBaUI7SUFDaEYsTUFBTUosV0FBZ0MsRUFBRTtJQUN4QyxNQUFNNkUsaUJBQWlCQyxrQkFBa0JuRyxVQUFVeUI7SUFFbkR5RSxlQUFlakIsT0FBTyxDQUFDbUIsQ0FBQUE7UUFDckIsTUFBTUMsbUJBQW1CMUYsS0FBSzhDLEtBQUssQ0FBQyxHQUFHLElBQ3BDN0IsR0FBRyxDQUFDLENBQUNzRCxLQUFLcEIsUUFBVztnQkFBRUE7Z0JBQU9ZLE9BQU9RLEdBQUcsQ0FBQ2tCLE9BQU87WUFBQyxJQUNqRHhELE1BQU0sQ0FBQzBELENBQUFBLE9BQVFBLEtBQUs1QixLQUFLLElBQUk2QixNQUFNQyxXQUFXRixLQUFLNUIsS0FBSyxDQUFDK0IsUUFBUSxHQUFHM0UsT0FBTyxDQUFDLFNBQVM7UUFFeEYsSUFBSXVFLGlCQUFpQnRELE1BQU0sR0FBRyxHQUFHO1lBQy9CMUIsU0FBU2lCLElBQUksQ0FBQztnQkFDWm5CLE1BQU07Z0JBQ05DLFNBQVMsa0NBQXlDLE9BQVBnRjtnQkFDM0NsRCxVQUFVLDBCQUFpQyxPQUFQa0QsUUFBTztnQkFDM0NqRCxVQUFVO29CQUNSO29CQUNBO29CQUNBO29CQUNBO29CQUNBLHFCQUFxQmtELGlCQUFpQjVDLEtBQUssQ0FBQyxHQUFHLEdBQUc3QixHQUFHLENBQUM4RSxDQUFBQSxJQUFLLElBQVksT0FBUkEsRUFBRWhDLEtBQUssRUFBQyxNQUFJekIsSUFBSSxDQUFDO2lCQUNqRjtnQkFDRG1EO2dCQUNBTyxTQUFTTixpQkFBaUI1QyxLQUFLLENBQUMsR0FBRztZQUNyQztRQUNGO0lBQ0Y7SUFFQSxPQUFPcEM7QUFDVDtBQUVBLFNBQVM4RSxrQkFBa0JuRyxRQUFrQixFQUFFeUIsT0FBaUI7SUFDOUQsTUFBTW1GLGtCQUE4QztRQUNsRHJILE1BQU07WUFBQztZQUFVO1lBQVM7WUFBUTtZQUFPO1NBQU07UUFDL0NNLFFBQVE7WUFBQztZQUFRO1lBQU87U0FBTTtRQUM5QkMsU0FBUztZQUFDO1lBQVk7WUFBWTtZQUFZO1lBQVk7U0FBWTtJQUN4RTtJQUVBLE9BQU8yQixRQUFRbUIsTUFBTSxDQUFDdkMsQ0FBQUE7UUFDcEIsTUFBTXdHLGFBQWFuRSxvQkFBb0JyQztRQUN2QyxPQUFPdUcsZUFBZSxDQUFDNUcsU0FBUyxDQUFDdUQsSUFBSSxDQUFDeUMsQ0FBQUEsVUFBV2EsV0FBV25ELFFBQVEsQ0FBQ3NDO0lBQ3ZFO0FBQ0Y7QUFFQSxTQUFTbkIsZ0JBQWdCbEUsSUFBVyxFQUFFbEIsVUFBOEI7SUFDbEUsSUFBSSxDQUFDQSxjQUFja0IsS0FBS29DLE1BQU0sS0FBSyxHQUFHLE9BQU87SUFFN0MsTUFBTStELFFBQVFuRyxLQUNYaUIsR0FBRyxDQUFDc0QsQ0FBQUEsTUFBT0EsR0FBRyxDQUFDekYsV0FBVyxFQUMxQm1ELE1BQU0sQ0FBQ21FLFNBQ1BuRixHQUFHLENBQUNvRixDQUFBQSxVQUFXLElBQUlDLEtBQUtELFVBQ3hCcEUsTUFBTSxDQUFDc0UsQ0FBQUEsT0FBUSxDQUFDWCxNQUFNVyxLQUFLQyxPQUFPLEtBQ2xDQyxJQUFJO0lBRVAsSUFBSU4sTUFBTS9ELE1BQU0sS0FBSyxHQUFHLE9BQU87SUFFL0IsT0FBTztRQUNMc0UsT0FBT1AsS0FBSyxDQUFDLEVBQUUsQ0FBQ1EsV0FBVyxHQUFHQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7UUFDM0NDLEtBQUtWLEtBQUssQ0FBQ0EsTUFBTS9ELE1BQU0sR0FBRyxFQUFFLENBQUN1RSxXQUFXLEdBQUdDLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRTtRQUN4REUsV0FBV0MsS0FBS0MsSUFBSSxDQUFDLENBQUNiLEtBQUssQ0FBQ0EsTUFBTS9ELE1BQU0sR0FBRyxFQUFFLENBQUNvRSxPQUFPLEtBQUtMLEtBQUssQ0FBQyxFQUFFLENBQUNLLE9BQU8sRUFBQyxJQUFNLFFBQU8sS0FBSyxLQUFLLEVBQUMsS0FBTTtJQUMzRztBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi92YWxpZGF0b3JzLnRzPzU2YjAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFBhcGEgZnJvbSAncGFwYXBhcnNlJ1xuaW1wb3J0IHsgUGxhdGZvcm0gfSBmcm9tICcuL3N1cGFiYXNlJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFZhbGlkYXRpb25SZXN1bHQge1xuICBpc1ZhbGlkOiBib29sZWFuXG4gIGhhc0Vycm9yczogYm9vbGVhblxuICBoYXNXYXJuaW5nczogYm9vbGVhblxuICBuZWVkc0NvcnJlY3Rpb246IGJvb2xlYW5cbiAgZXJyb3JzOiBWYWxpZGF0aW9uRXJyb3JbXVxuICB3YXJuaW5nczogVmFsaWRhdGlvbldhcm5pbmdbXVxuICByb3dDb3VudDogbnVtYmVyXG4gIGNvbHVtbkNvdW50OiBudW1iZXJcbiAgZGF0ZVJhbmdlOiBEYXRlUmFuZ2UgfCBudWxsXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmFsaWRhdGlvbkVycm9yIHtcbiAgdHlwZTogc3RyaW5nXG4gIG1lc3NhZ2U6IHN0cmluZ1xuICBob3dUb0ZpeDogc3RyaW5nXG4gIGV4YW1wbGVzPzogc3RyaW5nW11cbiAgY29sdW1ucz86IHN0cmluZ1tdXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmFsaWRhdGlvbldhcm5pbmcge1xuICB0eXBlOiBzdHJpbmdcbiAgbWVzc2FnZTogc3RyaW5nXG4gIGhvd1RvRml4Pzogc3RyaW5nXG4gIGV4YW1wbGVzPzogc3RyaW5nW11cbiAgY29sdW1uPzogc3RyaW5nXG4gIHNhbXBsZXM/OiBhbnlbXVxuICBkZXRhaWxzPzogYW55XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF0ZVJhbmdlIHtcbiAgc3RhcnQ6IHN0cmluZ1xuICBlbmQ6IHN0cmluZ1xuICB0b3RhbERheXM6IG51bWJlclxufVxuXG5leHBvcnQgY29uc3QgUExBVEZPUk1fU0NIRU1BUzogUmVjb3JkPFBsYXRmb3JtLCB7XG4gIHJlcXVpcmVkOiBzdHJpbmdbXVxuICBkYXRlQ29sdW1uOiBzdHJpbmdcbiAgcmVxdWlyZWREYXRlRm9ybWF0OiBzdHJpbmdcbiAgYWNjZXB0ZWRGb3JtYXRzOiBzdHJpbmdbXVxuICBvcmRlck1hdHRlcnM6IGJvb2xlYW5cbiAgZXhwZWN0ZWRPcmRlcj86IHN0cmluZ1tdXG59PiA9IHtcbiAgbWV0YToge1xuICAgIHJlcXVpcmVkOiBbXG4gICAgICAnRGF5JyxcbiAgICAgICdDYW1wYWlnbiBuYW1lJyxcbiAgICAgICdBZCBzZXQgbmFtZScsIFxuICAgICAgJ0FkIG5hbWUnLFxuICAgICAgJ0Ftb3VudCBzcGVudCAoSU5SKScsXG4gICAgICAnQ1RSIChsaW5rIGNsaWNrLXRocm91Z2ggcmF0ZSknLFxuICAgICAgJ0NQTSAoY29zdCBwZXIgMSwwMDAgaW1wcmVzc2lvbnMpJ1xuICAgIF0sXG4gICAgZGF0ZUNvbHVtbjogJ0RheScsXG4gICAgcmVxdWlyZWREYXRlRm9ybWF0OiAnWVlZWS1NTS1ERCcsXG4gICAgYWNjZXB0ZWRGb3JtYXRzOiBbJ1lZWVktTU0tREQnXSxcbiAgICBvcmRlck1hdHRlcnM6IGZhbHNlIC8vIE1ldGEgZXhwb3J0cyBjYW4gdmFyeVxuICB9LFxuICBnb29nbGU6IHtcbiAgICByZXF1aXJlZDogW1xuICAgICAgJ0RheScsXG4gICAgICAnQ2FtcGFpZ24nLFxuICAgICAgJ0Nvc3QnLFxuICAgICAgJ0NUUicsXG4gICAgICAnQXZnLiBDUE0nXG4gICAgXSxcbiAgICBkYXRlQ29sdW1uOiAnRGF5JyxcbiAgICByZXF1aXJlZERhdGVGb3JtYXQ6ICdZWVlZLU1NLUREJyxcbiAgICBhY2NlcHRlZEZvcm1hdHM6IFsnWVlZWS1NTS1ERCddLFxuICAgIG9yZGVyTWF0dGVyczogZmFsc2UgLy8gR29vZ2xlIEFkcyBleHBvcnRzIGFyZSBmbGV4aWJsZVxuICB9LFxuICBzaG9waWZ5OiB7XG4gICAgcmVxdWlyZWQ6IFtcbiAgICAgICdEYXknLFxuICAgICAgJ1VUTSBjYW1wYWlnbicsXG4gICAgICAnVVRNIHRlcm0nLFxuICAgICAgJ1VUTSBjb250ZW50JyxcbiAgICAgICdPbmxpbmUgc3RvcmUgdmlzaXRvcnMnLFxuICAgICAgJ1Nlc3Npb25zIHRoYXQgY29tcGxldGVkIGNoZWNrb3V0J1xuICAgIF0sXG4gICAgZGF0ZUNvbHVtbjogJ0RheScsXG4gICAgcmVxdWlyZWREYXRlRm9ybWF0OiAnWVlZWS1NTS1ERCcsXG4gICAgYWNjZXB0ZWRGb3JtYXRzOiBbJ1lZWVktTU0tREQnXSxcbiAgICBvcmRlck1hdHRlcnM6IGZhbHNlIC8vIFNob3BpZnkgcmVwb3J0cyBhcmUgZmxleGlibGVcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVDU1YocGxhdGZvcm06IFBsYXRmb3JtLCBmaWxlOiBGaWxlKTogUHJvbWlzZTxWYWxpZGF0aW9uUmVzdWx0PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIFBhcGEucGFyc2UoZmlsZSwge1xuICAgICAgaGVhZGVyOiB0cnVlLFxuICAgICAgcHJldmlldzogMTAwLFxuICAgICAgY29tcGxldGU6IChyZXN1bHRzKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBwZXJmb3JtVmFsaWRhdGlvbihwbGF0Zm9ybSwgcmVzdWx0cy5kYXRhLCByZXN1bHRzLm1ldGEuZmllbGRzIHx8IFtdKVxuICAgICAgICByZXNvbHZlKHZhbGlkYXRpb24pXG4gICAgICB9LFxuICAgICAgZXJyb3I6IChlcnJvcikgPT4ge1xuICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgICAgICBoYXNFcnJvcnM6IHRydWUsXG4gICAgICAgICAgaGFzV2FybmluZ3M6IGZhbHNlLFxuICAgICAgICAgIG5lZWRzQ29ycmVjdGlvbjogZmFsc2UsXG4gICAgICAgICAgZXJyb3JzOiBbeyB0eXBlOiAncGFyc2VfZXJyb3InLCBtZXNzYWdlOiBlcnJvci5tZXNzYWdlIH1dLFxuICAgICAgICAgIHdhcm5pbmdzOiBbXSxcbiAgICAgICAgICByb3dDb3VudDogMCxcbiAgICAgICAgICBjb2x1bW5Db3VudDogMCxcbiAgICAgICAgICBkYXRlUmFuZ2U6IG51bGxcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9KVxuICB9KVxufVxuXG5mdW5jdGlvbiBwZXJmb3JtVmFsaWRhdGlvbihwbGF0Zm9ybTogUGxhdGZvcm0sIGRhdGE6IGFueVtdLCBoZWFkZXJzOiBzdHJpbmdbXSk6IFZhbGlkYXRpb25SZXN1bHQge1xuICBjb25zdCBzY2hlbWEgPSBQTEFURk9STV9TQ0hFTUFTW3BsYXRmb3JtXVxuICBjb25zdCBlcnJvcnM6IFZhbGlkYXRpb25FcnJvcltdID0gW11cbiAgY29uc3Qgd2FybmluZ3M6IFZhbGlkYXRpb25XYXJuaW5nW10gPSBbXVxuXG4gIC8vIENsZWFuIGhlYWRlcnMgKHJlbW92ZSBCT00sIHRyaW0gd2hpdGVzcGFjZSlcbiAgY29uc3QgY2xlYW5IZWFkZXJzID0gaGVhZGVycy5tYXAoaCA9PiBoLnJlcGxhY2UoL15cXHVmZWZmLywgJycpLnRyaW0oKSlcbiAgXG4gIC8vIENoZWNrIGZvciBjYXNlLXNlbnNpdGl2ZSBjb2x1bW4gbWF0Y2hpbmcgaXNzdWVzXG4gIGNvbnN0IGNvbHVtbk1hcHBpbmdJc3N1ZXM6IEFycmF5PHtyZXF1aXJlZDogc3RyaW5nLCBmb3VuZD86IHN0cmluZywgaXNzdWU6IHN0cmluZ30+ID0gW11cbiAgXG4gIGZvciAoY29uc3QgcmVxdWlyZWRDb2wgb2Ygc2NoZW1hLnJlcXVpcmVkKSB7XG4gICAgLy8gVHJ5IGV4YWN0IG1hdGNoIGZpcnN0XG4gICAgY29uc3QgZXhhY3RNYXRjaCA9IGNsZWFuSGVhZGVycy5maW5kKGggPT4gaCA9PT0gcmVxdWlyZWRDb2wpXG4gICAgaWYgKGV4YWN0TWF0Y2gpIGNvbnRpbnVlXG4gICAgXG4gICAgLy8gVHJ5IGNhc2UtaW5zZW5zaXRpdmUgbWF0Y2hcbiAgICBjb25zdCBjYXNlSW5zZW5zaXRpdmVNYXRjaCA9IGNsZWFuSGVhZGVycy5maW5kKGggPT4gXG4gICAgICBoLnRvTG93ZXJDYXNlKCkgPT09IHJlcXVpcmVkQ29sLnRvTG93ZXJDYXNlKClcbiAgICApXG4gICAgXG4gICAgaWYgKGNhc2VJbnNlbnNpdGl2ZU1hdGNoKSB7XG4gICAgICBjb2x1bW5NYXBwaW5nSXNzdWVzLnB1c2goe1xuICAgICAgICByZXF1aXJlZDogcmVxdWlyZWRDb2wsXG4gICAgICAgIGZvdW5kOiBjYXNlSW5zZW5zaXRpdmVNYXRjaCxcbiAgICAgICAgaXNzdWU6ICdjYXNlX21pc21hdGNoJ1xuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVHJ5IGZ1enp5IG1hdGNoIChzaW1pbGFyIG5hbWVzKVxuICAgICAgY29uc3QgZnV6enlNYXRjaCA9IGNsZWFuSGVhZGVycy5maW5kKGggPT4gXG4gICAgICAgIG5vcm1hbGl6ZUNvbHVtbk5hbWUoaCkgPT09IG5vcm1hbGl6ZUNvbHVtbk5hbWUocmVxdWlyZWRDb2wpXG4gICAgICApXG4gICAgICBcbiAgICAgIGlmIChmdXp6eU1hdGNoKSB7XG4gICAgICAgIGNvbHVtbk1hcHBpbmdJc3N1ZXMucHVzaCh7XG4gICAgICAgICAgcmVxdWlyZWQ6IHJlcXVpcmVkQ29sLFxuICAgICAgICAgIGZvdW5kOiBmdXp6eU1hdGNoLFxuICAgICAgICAgIGlzc3VlOiAnbmFtZV92YXJpYXRpb24nXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb2x1bW5NYXBwaW5nSXNzdWVzLnB1c2goe1xuICAgICAgICAgIHJlcXVpcmVkOiByZXF1aXJlZENvbCxcbiAgICAgICAgICBpc3N1ZTogJ21pc3NpbmcnXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gUmVwb3J0IGNvbHVtbiBpc3N1ZXNcbiAgY29uc3QgbWlzc2luZ0NvbHVtbnMgPSBjb2x1bW5NYXBwaW5nSXNzdWVzLmZpbHRlcihpc3N1ZSA9PiBpc3N1ZS5pc3N1ZSA9PT0gJ21pc3NpbmcnKVxuICBjb25zdCBjYXNlTWlzbWF0Y2hDb2x1bW5zID0gY29sdW1uTWFwcGluZ0lzc3Vlcy5maWx0ZXIoaXNzdWUgPT4gaXNzdWUuaXNzdWUgPT09ICdjYXNlX21pc21hdGNoJylcbiAgY29uc3QgbmFtZVZhcmlhdGlvbkNvbHVtbnMgPSBjb2x1bW5NYXBwaW5nSXNzdWVzLmZpbHRlcihpc3N1ZSA9PiBpc3N1ZS5pc3N1ZSA9PT0gJ25hbWVfdmFyaWF0aW9uJylcbiAgXG4gIGlmIChtaXNzaW5nQ29sdW1ucy5sZW5ndGggPiAwKSB7XG4gICAgZXJyb3JzLnB1c2goe1xuICAgICAgdHlwZTogJ21pc3NpbmdfY29sdW1ucycsXG4gICAgICBtZXNzYWdlOiBgTWlzc2luZyByZXF1aXJlZCBjb2x1bW5zOiAke21pc3NpbmdDb2x1bW5zLm1hcChjID0+IGMucmVxdWlyZWQpLmpvaW4oJywgJyl9YCxcbiAgICAgIGhvd1RvRml4OiAnQWRkIHRoZSBtaXNzaW5nIGNvbHVtbnMgdG8geW91ciBDU1YgZmlsZSB3aXRoIHRoZSBleGFjdCBuYW1lcyBzaG93biBhYm92ZScsXG4gICAgICBleGFtcGxlczogW1xuICAgICAgICAnT3BlbiB5b3VyIENTViBpbiBFeGNlbC9Hb29nbGUgU2hlZXRzJyxcbiAgICAgICAgJ0FkZCBuZXcgY29sdW1ucyB3aXRoIGhlYWRlcnM6ICcgKyBtaXNzaW5nQ29sdW1ucy5tYXAoYyA9PiBgXCIke2MucmVxdWlyZWR9XCJgKS5qb2luKCcsICcpLFxuICAgICAgICAnRmlsbCB3aXRoIGFwcHJvcHJpYXRlIGRhdGEgb3IgbGVhdmUgZW1wdHkgaWYgbm8gZGF0YSBhdmFpbGFibGUnXG4gICAgICBdLFxuICAgICAgY29sdW1uczogbWlzc2luZ0NvbHVtbnMubWFwKGMgPT4gYy5yZXF1aXJlZClcbiAgICB9KVxuICB9XG5cbiAgaWYgKGNhc2VNaXNtYXRjaENvbHVtbnMubGVuZ3RoID4gMCkge1xuICAgIGVycm9ycy5wdXNoKHtcbiAgICAgIHR5cGU6ICdjb2x1bW5fY2FzZV9taXNtYXRjaCcsXG4gICAgICBtZXNzYWdlOiBgQ29sdW1uIGNhc2UgbWlzbWF0Y2ggZm91bmQ6ICR7Y2FzZU1pc21hdGNoQ29sdW1ucy5tYXAoYyA9PiBgXCIke2MuZm91bmR9XCIgc2hvdWxkIGJlIFwiJHtjLnJlcXVpcmVkfVwiYCkuam9pbignLCAnKX1gLFxuICAgICAgaG93VG9GaXg6ICdVcGRhdGUgY29sdW1uIGhlYWRlcnMgdG8gbWF0Y2ggdGhlIGV4YWN0IGNhc2UgKHVwcGVyY2FzZS9sb3dlcmNhc2UpIHJlcXVpcmVkJyxcbiAgICAgIGV4YW1wbGVzOiBbXG4gICAgICAgICdPcGVuIHlvdXIgQ1NWIGZpbGUgaW4gRXhjZWwvR29vZ2xlIFNoZWV0cycsXG4gICAgICAgIC4uLmNhc2VNaXNtYXRjaENvbHVtbnMubWFwKGMgPT4gYFJlbmFtZSBcIiR7Yy5mb3VuZH1cIiB0byBcIiR7Yy5yZXF1aXJlZH1cImApLFxuICAgICAgICAnU2F2ZSB0aGUgZmlsZSBhbmQgcmUtdXBsb2FkJ1xuICAgICAgXSxcbiAgICAgIGNvbHVtbnM6IGNhc2VNaXNtYXRjaENvbHVtbnMubWFwKGMgPT4gYy5yZXF1aXJlZClcbiAgICB9KVxuICB9XG5cbiAgaWYgKG5hbWVWYXJpYXRpb25Db2x1bW5zLmxlbmd0aCA+IDApIHtcbiAgICB3YXJuaW5ncy5wdXNoKHtcbiAgICAgIHR5cGU6ICdjb2x1bW5fbmFtZV92YXJpYXRpb25zJyxcbiAgICAgIG1lc3NhZ2U6IGBDb2x1bW4gbmFtZSB2YXJpYXRpb25zIGRldGVjdGVkOiAke25hbWVWYXJpYXRpb25Db2x1bW5zLm1hcChjID0+IGBcIiR7Yy5mb3VuZH1cIiBtaWdodCBiZSBcIiR7Yy5yZXF1aXJlZH1cImApLmpvaW4oJywgJyl9YCxcbiAgICAgIGhvd1RvRml4OiAnVmVyaWZ5IGFuZCByZW5hbWUgY29sdW1ucyB0byBtYXRjaCBleGFjdCByZXF1aXJlZCBuYW1lcycsXG4gICAgICBleGFtcGxlczogW1xuICAgICAgICAnQ2hlY2sgaWYgdGhlc2UgY29sdW1uIG1hcHBpbmdzIGFyZSBjb3JyZWN0OicsXG4gICAgICAgIC4uLm5hbWVWYXJpYXRpb25Db2x1bW5zLm1hcChjID0+IGBcIiR7Yy5mb3VuZH1cIiDihpIgXCIke2MucmVxdWlyZWR9XCJgKSxcbiAgICAgICAgJ1JlbmFtZSBjb2x1bW5zIGlmIG5lZWRlZCBhbmQgcmUtdXBsb2FkJ1xuICAgICAgXSxcbiAgICAgIGRldGFpbHM6IG5hbWVWYXJpYXRpb25Db2x1bW5zXG4gICAgfSlcbiAgfVxuXG4gIC8vIENoZWNrIGZvciB1bmV4cGVjdGVkIGNvbHVtbnMgdGhhdCBtaWdodCBpbmRpY2F0ZSB3cm9uZyBwbGF0Zm9ybVxuICBjb25zdCB1bmV4cGVjdGVkQ29sdW1ucyA9IGNsZWFuSGVhZGVycy5maWx0ZXIoaGVhZGVyID0+IFxuICAgICFzY2hlbWEucmVxdWlyZWQuc29tZShyZXEgPT4gbm9ybWFsaXplQ29sdW1uTmFtZShoZWFkZXIpID09PSBub3JtYWxpemVDb2x1bW5OYW1lKHJlcSkpXG4gIClcbiAgXG4gIGlmICh1bmV4cGVjdGVkQ29sdW1ucy5sZW5ndGggPiAwICYmIHVuZXhwZWN0ZWRDb2x1bW5zLmxlbmd0aCA+IDMpIHtcbiAgICB3YXJuaW5ncy5wdXNoKHtcbiAgICAgIHR5cGU6ICd1bmV4cGVjdGVkX2NvbHVtbnMnLFxuICAgICAgbWVzc2FnZTogYE1hbnkgdW5leHBlY3RlZCBjb2x1bW5zIGZvdW5kICgke3VuZXhwZWN0ZWRDb2x1bW5zLmxlbmd0aH0pLiBWZXJpZnkgdGhpcyBpcyB0aGUgY29ycmVjdCBwbGF0Zm9ybS5gLFxuICAgICAgaG93VG9GaXg6ICdWZXJpZnkgeW91IHNlbGVjdGVkIHRoZSBjb3JyZWN0IHBsYXRmb3JtIG9yIHJlbW92ZSB1bm5lY2Vzc2FyeSBjb2x1bW5zJyxcbiAgICAgIGV4YW1wbGVzOiBbXG4gICAgICAgICdDaGVjayBpZiB0aGlzIGlzIHRoZSByaWdodCBwbGF0Zm9ybSAoTWV0YS9Hb29nbGUvU2hvcGlmeSknLFxuICAgICAgICAnVW5leHBlY3RlZCBjb2x1bW5zOiAnICsgdW5leHBlY3RlZENvbHVtbnMuc2xpY2UoMCwgNSkuam9pbignLCAnKSxcbiAgICAgICAgJ1JlbW92ZSBjb2x1bW5zIG5vdCBuZWVkZWQgZm9yIHRoaXMgcGxhdGZvcm0nLFxuICAgICAgICAnT3Igc2VsZWN0IGRpZmZlcmVudCBwbGF0Zm9ybSBpZiB0aGlzIENTViBpcyBmb3IgYW5vdGhlciBzZXJ2aWNlJ1xuICAgICAgXSxcbiAgICAgIGRldGFpbHM6IHsgdW5leHBlY3RlZENvbHVtbnM6IHVuZXhwZWN0ZWRDb2x1bW5zLnNsaWNlKDAsIDUpIH1cbiAgICB9KVxuICB9XG5cbiAgLy8gQ2hlY2sgZm9yIGNvbW1vbiBDU1YgZm9ybWF0dGluZyBpc3N1ZXNcbiAgaWYgKGhlYWRlcnMuc29tZShoID0+IGguaW5jbHVkZXMoJ1xcdWZlZmYnKSkpIHtcbiAgICB3YXJuaW5ncy5wdXNoKHtcbiAgICAgIHR5cGU6ICdib21fZGV0ZWN0ZWQnLFxuICAgICAgbWVzc2FnZTogJ0JPTSAoQnl0ZSBPcmRlciBNYXJrKSBkZXRlY3RlZCBpbiBDU1YgaGVhZGVycy4gVGhpcyBtYXkgY2F1c2UgcGFyc2luZyBpc3N1ZXMuJyxcbiAgICAgIGhvd1RvRml4OiAnU2F2ZSBDU1YgZmlsZSBhcyBVVEYtOCB3aXRob3V0IEJPTScsXG4gICAgICBleGFtcGxlczogW1xuICAgICAgICAnT3BlbiBmaWxlIGluIE5vdGVwYWQrKyBvciBWUyBDb2RlJyxcbiAgICAgICAgJ0dvIHRvIEVuY29kaW5nIOKGkiBDb252ZXJ0IHRvIFVURi04ICh3aXRob3V0IEJPTSknLFxuICAgICAgICAnT3IgaW4gRXhjZWw6IEZpbGUg4oaSIFNhdmUgQXMg4oaSIENTViBVVEYtOCcsXG4gICAgICAgICdSZS11cGxvYWQgdGhlIGNvbnZlcnRlZCBmaWxlJ1xuICAgICAgXSxcbiAgICAgIGRldGFpbHM6IHsgbm90ZTogJ1NhdmUgZmlsZSBhcyBVVEYtOCB3aXRob3V0IEJPTScgfVxuICAgIH0pXG4gIH1cblxuICAvLyBDaGVjayBmb3IgZW1wdHkgaGVhZGVyc1xuICBjb25zdCBlbXB0eUhlYWRlcnMgPSBjbGVhbkhlYWRlcnMuZmlsdGVyKGggPT4gIWggfHwgaC50cmltKCkgPT09ICcnKVxuICBpZiAoZW1wdHlIZWFkZXJzLmxlbmd0aCA+IDApIHtcbiAgICBlcnJvcnMucHVzaCh7XG4gICAgICB0eXBlOiAnZW1wdHlfaGVhZGVycycsXG4gICAgICBtZXNzYWdlOiBgRm91bmQgJHtlbXB0eUhlYWRlcnMubGVuZ3RofSBlbXB0eSBjb2x1bW4gaGVhZGVycy4gQWxsIGNvbHVtbnMgbXVzdCBoYXZlIG5hbWVzLmAsXG4gICAgICBob3dUb0ZpeDogJ0FkZCBuYW1lcyB0byBhbGwgZW1wdHkgY29sdW1uIGhlYWRlcnMnLFxuICAgICAgZXhhbXBsZXM6IFtcbiAgICAgICAgJ09wZW4geW91ciBDU1YgZmlsZScsXG4gICAgICAgICdGaW5kIGNvbHVtbnMgd2l0aCBlbXB0eS9ibGFuayBoZWFkZXJzJyxcbiAgICAgICAgJ0FkZCBkZXNjcmlwdGl2ZSBuYW1lcyBsaWtlOiBcIkNvbHVtbjFcIiwgXCJEYXRhXCIsIFwiTm90ZXNcIiwgZXRjLicsXG4gICAgICAgICdPciByZW1vdmUgZW1wdHkgY29sdW1ucyBpZiBub3QgbmVlZGVkJ1xuICAgICAgXSxcbiAgICAgIGNvbHVtbnM6IFtgJHtlbXB0eUhlYWRlcnMubGVuZ3RofSBlbXB0eSBoZWFkZXJzYF1cbiAgICB9KVxuICB9XG5cbiAgLy8gQ2hlY2sgZm9yIGR1cGxpY2F0ZSBoZWFkZXJzXG4gIGNvbnN0IGR1cGxpY2F0ZUhlYWRlcnMgPSBjbGVhbkhlYWRlcnMuZmlsdGVyKChoZWFkZXIsIGluZGV4KSA9PiBcbiAgICBjbGVhbkhlYWRlcnMuaW5kZXhPZihoZWFkZXIpICE9PSBpbmRleFxuICApXG4gIGlmIChkdXBsaWNhdGVIZWFkZXJzLmxlbmd0aCA+IDApIHtcbiAgICBlcnJvcnMucHVzaCh7XG4gICAgICB0eXBlOiAnZHVwbGljYXRlX2hlYWRlcnMnLFxuICAgICAgbWVzc2FnZTogYER1cGxpY2F0ZSBjb2x1bW4gaGVhZGVycyBmb3VuZDogJHtbLi4ubmV3IFNldChkdXBsaWNhdGVIZWFkZXJzKV0uam9pbignLCAnKX1gLFxuICAgICAgaG93VG9GaXg6ICdSZW5hbWUgZHVwbGljYXRlIGNvbHVtbiBoZWFkZXJzIHRvIHVuaXF1ZSBuYW1lcycsXG4gICAgICBleGFtcGxlczogW1xuICAgICAgICAnRmluZCBkdXBsaWNhdGUgY29sdW1uczogJyArIFsuLi5uZXcgU2V0KGR1cGxpY2F0ZUhlYWRlcnMpXS5qb2luKCcsICcpLFxuICAgICAgICAnUmVuYW1lIHRoZW0gdG8gdW5pcXVlIG5hbWVzIGxpa2U6IFwiQ2FtcGFpZ25fMVwiLCBcIkNhbXBhaWduXzJcIicsXG4gICAgICAgICdPciByZW1vdmUgZHVwbGljYXRlIGNvbHVtbnMgaWYgaWRlbnRpY2FsIGRhdGEnLFxuICAgICAgICAnU2F2ZSBhbmQgcmUtdXBsb2FkJ1xuICAgICAgXSxcbiAgICAgIGNvbHVtbnM6IGR1cGxpY2F0ZUhlYWRlcnNcbiAgICB9KVxuICB9XG5cbiAgLy8gVmFsaWRhdGUgZGF0ZSBmb3JtYXRzIChTVFJJQ1QgLSBtdXN0IGJlIFlZWVktTU0tREQpXG4gIGNvbnN0IGRhdGVDb2x1bW4gPSBmaW5kQ29sdW1uQnlOYW1lKGNsZWFuSGVhZGVycywgc2NoZW1hLmRhdGVDb2x1bW4pXG4gIGlmIChkYXRlQ29sdW1uKSB7XG4gICAgY29uc3QgZGF0ZVZhbGlkYXRpb24gPSB2YWxpZGF0ZURhdGVGb3JtYXRzKGRhdGEsIGRhdGVDb2x1bW4pXG4gICAgXG4gICAgLy8gQ2hlY2sgZm9yIHdyb25nIGRhdGUgZm9ybWF0cyAtIG1ha2UgdGhpcyBhbiBFUlJPUiBub3Qgd2FybmluZ1xuICAgIGNvbnN0IGFsbG93ZWRGb3JtYXRzID0gc2NoZW1hLmFjY2VwdGVkRm9ybWF0c1xuICAgIGNvbnN0IG5vblN0YW5kYXJkRm9ybWF0cyA9IGRhdGVWYWxpZGF0aW9uLmRldGVjdGVkRm9ybWF0cy5maWx0ZXIoZm9ybWF0ID0+ICFhbGxvd2VkRm9ybWF0cy5pbmNsdWRlcyhmb3JtYXQpKVxuICAgIGlmIChub25TdGFuZGFyZEZvcm1hdHMubGVuZ3RoID4gMCkge1xuICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICB0eXBlOiAnaW52YWxpZF9kYXRlX2Zvcm1hdCcsXG4gICAgICAgIG1lc3NhZ2U6IGBEYXRlIGNvbHVtbiAnJHtkYXRlQ29sdW1ufScgbXVzdCB1c2UgJHtzY2hlbWEucmVxdWlyZWREYXRlRm9ybWF0fSBmb3JtYXQuIEZvdW5kOiAke25vblN0YW5kYXJkRm9ybWF0cy5qb2luKCcsICcpfWAsXG4gICAgICAgIGhvd1RvRml4OiBgQ29udmVydCBhbGwgZGF0ZXMgaW4gJyR7ZGF0ZUNvbHVtbn0nIGNvbHVtbiB0byBZWVlZLU1NLUREIGZvcm1hdGAsXG4gICAgICAgIGV4YW1wbGVzOiBbXG4gICAgICAgICAgJ09wZW4gQ1NWIGluIEV4Y2VsL0dvb2dsZSBTaGVldHMnLFxuICAgICAgICAgICdTZWxlY3QgdGhlIGVudGlyZSBEYXRlIGNvbHVtbicsXG4gICAgICAgICAgJ0Zvcm1hdCBjZWxscyBhcyBDdXN0b206IFlZWVktTU0tREQgKGUuZy4sIDIwMjUtMTEtMTApJyxcbiAgICAgICAgICAnT3IgdXNlIGZpbmQvcmVwbGFjZTogMTAvMTEvMjAyNSDihpIgMjAyNS0xMS0xMCcsXG4gICAgICAgICAgJ1NhdmUgYXMgQ1NWIGFuZCByZS11cGxvYWQnXG4gICAgICAgIF0sXG4gICAgICAgIGNvbHVtbnM6IFtkYXRlQ29sdW1uXVxuICAgICAgfSlcbiAgICB9XG4gICAgXG4gICAgLy8gQ2hlY2sgZm9yIGludmFsaWQvdW5wYXJzZWFibGUgZGF0ZXNcbiAgICBpZiAoZGF0ZVZhbGlkYXRpb24uaW52YWxpZERhdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2ludmFsaWRfZGF0ZV92YWx1ZXMnLFxuICAgICAgICBtZXNzYWdlOiBgSW52YWxpZCBkYXRlIHZhbHVlcyBmb3VuZCBpbiAnJHtkYXRlQ29sdW1ufSc6ICR7ZGF0ZVZhbGlkYXRpb24uaW52YWxpZERhdGVzLnNsaWNlKDAsIDMpLm1hcChkID0+IGQudmFsdWUpLmpvaW4oJywgJyl9YCxcbiAgICAgICAgaG93VG9GaXg6ICdGaXggb3IgcmVtb3ZlIGludmFsaWQgZGF0ZSBlbnRyaWVzJyxcbiAgICAgICAgZXhhbXBsZXM6IFtcbiAgICAgICAgICAnQ2hlY2sgdGhlc2UgaW52YWxpZCBkYXRlczogJyArIGRhdGVWYWxpZGF0aW9uLmludmFsaWREYXRlcy5zbGljZSgwLCAzKS5tYXAoZCA9PiBgXCIke2QudmFsdWV9XCJgKS5qb2luKCcsICcpLFxuICAgICAgICAgICdSZXBsYWNlIHdpdGggdmFsaWQgZGF0ZXMgaW4gWVlZWS1NTS1ERCBmb3JtYXQnLFxuICAgICAgICAgICdPciByZW1vdmUgcm93cyB3aXRoIGludmFsaWQgZGF0ZXMgaWYgbm90IG5lZWRlZCcsXG4gICAgICAgICAgJ0NvbW1vbiB2YWxpZCBmb3JtYXRzOiAyMDI1LTExLTEwLCAyMDI1LTAxLTAxJ1xuICAgICAgICBdLFxuICAgICAgICBjb2x1bW5zOiBbZGF0ZUNvbHVtbl1cbiAgICAgIH0pXG4gICAgfVxuICAgIFxuICAgIC8vIE9ubHkgYWRkIHdhcm5pbmdzIGZvciBtaW5vciBpc3N1ZXMgaWYgbm8gZXJyb3JzXG4gICAgaWYgKG5vblN0YW5kYXJkRm9ybWF0cy5sZW5ndGggPT09IDAgJiYgZGF0ZVZhbGlkYXRpb24uaW52YWxpZERhdGVzLmxlbmd0aCA9PT0gMCAmJiBkYXRlVmFsaWRhdGlvbi5kZXRlY3RlZEZvcm1hdHMubGVuZ3RoID4gMSkge1xuICAgICAgd2FybmluZ3MucHVzaCh7XG4gICAgICAgIHR5cGU6ICdkYXRlX2Zvcm1hdF9pbmNvbnNpc3RlbmN5JyxcbiAgICAgICAgbWVzc2FnZTogYE11bHRpcGxlIGRhdGUgZm9ybWF0cyBkZXRlY3RlZCBpbiAke2RhdGVDb2x1bW59YCxcbiAgICAgICAgZGV0YWlsczogZGF0ZVZhbGlkYXRpb25cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgLy8gVmFsaWRhdGUgbnVtZXJpYyBjb2x1bW5zXG4gIGNvbnN0IG51bWVyaWNWYWxpZGF0aW9uID0gdmFsaWRhdGVOdW1lcmljQ29sdW1ucyhwbGF0Zm9ybSwgZGF0YSwgY2xlYW5IZWFkZXJzKVxuICB3YXJuaW5ncy5wdXNoKC4uLm51bWVyaWNWYWxpZGF0aW9uKVxuXG4gIHJldHVybiB7XG4gICAgaXNWYWxpZDogZXJyb3JzLmxlbmd0aCA9PT0gMCxcbiAgICBoYXNFcnJvcnM6IGVycm9ycy5sZW5ndGggPiAwLFxuICAgIGhhc1dhcm5pbmdzOiB3YXJuaW5ncy5sZW5ndGggPiAwLFxuICAgIG5lZWRzQ29ycmVjdGlvbjogd2FybmluZ3MubGVuZ3RoID4gMCxcbiAgICBlcnJvcnMsXG4gICAgd2FybmluZ3MsXG4gICAgcm93Q291bnQ6IGRhdGEubGVuZ3RoLFxuICAgIGNvbHVtbkNvdW50OiBoZWFkZXJzLmxlbmd0aCxcbiAgICBkYXRlUmFuZ2U6IGRldGVjdERhdGVSYW5nZShkYXRhLCBkYXRlQ29sdW1uKVxuICB9XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNvbHVtbk5hbWUobmFtZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIG5hbWUudG9Mb3dlckNhc2UoKS50cmltKCkucmVwbGFjZSgvW15cXHddL2csICdfJylcbn1cblxuZnVuY3Rpb24gZmluZENvbHVtbkJ5TmFtZShoZWFkZXJzOiBzdHJpbmdbXSwgdGFyZ2V0TmFtZTogc3RyaW5nKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgcmV0dXJuIGhlYWRlcnMuZmluZChoZWFkZXIgPT4gXG4gICAgbm9ybWFsaXplQ29sdW1uTmFtZShoZWFkZXIpID09PSBub3JtYWxpemVDb2x1bW5OYW1lKHRhcmdldE5hbWUpXG4gIClcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVEYXRlRm9ybWF0cyhkYXRhOiBhbnlbXSwgZGF0ZUNvbHVtbjogc3RyaW5nKTogeyBoYXNJc3N1ZXM6IGJvb2xlYW47IGRldGVjdGVkRm9ybWF0czogc3RyaW5nW107IGludmFsaWREYXRlczogYW55W107IHJlY29tbWVuZGVkRm9ybWF0OiBzdHJpbmcgfSB7XG4gIGNvbnN0IGZvcm1hdHMgPSBuZXcgU2V0PHN0cmluZz4oKVxuICBjb25zdCBpbnZhbGlkRGF0ZXM6IGFueVtdID0gW11cbiAgXG4gIGRhdGEuc2xpY2UoMCwgNTApLmZvckVhY2goKHJvdywgaW5kZXgpID0+IHtcbiAgICBjb25zdCBkYXRlVmFsdWUgPSByb3dbZGF0ZUNvbHVtbl1cbiAgICBpZiAoZGF0ZVZhbHVlKSB7XG4gICAgICBjb25zdCBkZXRlY3RlZEZvcm1hdCA9IGRldGVjdERhdGVGb3JtYXQoZGF0ZVZhbHVlKVxuICAgICAgaWYgKGRldGVjdGVkRm9ybWF0KSB7XG4gICAgICAgIGZvcm1hdHMuYWRkKGRldGVjdGVkRm9ybWF0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW52YWxpZERhdGVzLnB1c2goeyByb3c6IGluZGV4LCB2YWx1ZTogZGF0ZVZhbHVlIH0pXG4gICAgICB9XG4gICAgfVxuICB9KVxuXG4gIHJldHVybiB7XG4gICAgaGFzSXNzdWVzOiBmb3JtYXRzLnNpemUgPiAxIHx8IGludmFsaWREYXRlcy5sZW5ndGggPiAwLFxuICAgIGRldGVjdGVkRm9ybWF0czogQXJyYXkuZnJvbShmb3JtYXRzKSxcbiAgICBpbnZhbGlkRGF0ZXMsXG4gICAgcmVjb21tZW5kZWRGb3JtYXQ6ICdZWVlZLU1NLUREJ1xuICB9XG59XG5cbmZ1bmN0aW9uIGRldGVjdERhdGVGb3JtYXQoZGF0ZVN0cmluZzogc3RyaW5nKTogc3RyaW5nIHwgbnVsbCB7XG4gIGNvbnN0IHRyaW1tZWQgPSBkYXRlU3RyaW5nLnRyaW0oKVxuICBcbiAgY29uc3QgcGF0dGVybnMgPSBbXG4gICAgeyByZWdleDogL15cXGR7NH0tXFxkezJ9LVxcZHsyfSQvLCBmb3JtYXQ6ICdZWVlZLU1NLUREJyB9LFxuICAgIHsgcmVnZXg6IC9eXFxkezJ9LVxcZHsyfS1cXGR7NH0kLywgZm9ybWF0OiAnREQtTU0tWVlZWScgfSxcbiAgICB7IHJlZ2V4OiAvXlxcZHsxLDJ9XFwvXFxkezEsMn1cXC9cXGR7NH0kLywgZm9ybWF0OiAnREQvTU0vWVlZWScgfSwgLy8gTW9yZSBzcGVjaWZpYyBmb3IgeW91ciBHb29nbGUgZGF0YVxuICAgIHsgcmVnZXg6IC9eXFxkezJ9XFwvXFxkezJ9XFwvXFxkezR9JC8sIGZvcm1hdDogJ0REL01NL1lZWVknIH0sXG4gICAgeyByZWdleDogL15cXGR7NH1cXC9cXGR7Mn1cXC9cXGR7Mn0kLywgZm9ybWF0OiAnWVlZWS9NTS9ERCcgfSxcbiAgICB7IHJlZ2V4OiAvXlxcZHsyfVxcLlxcZHsyfVxcLlxcZHs0fSQvLCBmb3JtYXQ6ICdERC5NTS5ZWVlZJyB9XG4gIF1cblxuICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgcGF0dGVybnMpIHtcbiAgICBpZiAocGF0dGVybi5yZWdleC50ZXN0KHRyaW1tZWQpKSB7XG4gICAgICByZXR1cm4gcGF0dGVybi5mb3JtYXRcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVOdW1lcmljQ29sdW1ucyhwbGF0Zm9ybTogUGxhdGZvcm0sIGRhdGE6IGFueVtdLCBoZWFkZXJzOiBzdHJpbmdbXSk6IFZhbGlkYXRpb25XYXJuaW5nW10ge1xuICBjb25zdCB3YXJuaW5nczogVmFsaWRhdGlvbldhcm5pbmdbXSA9IFtdXG4gIGNvbnN0IG51bWVyaWNDb2x1bW5zID0gZ2V0TnVtZXJpY0NvbHVtbnMocGxhdGZvcm0sIGhlYWRlcnMpXG4gIFxuICBudW1lcmljQ29sdW1ucy5mb3JFYWNoKGNvbHVtbiA9PiB7XG4gICAgY29uc3Qgbm9uTnVtZXJpY1ZhbHVlcyA9IGRhdGEuc2xpY2UoMCwgNTApXG4gICAgICAubWFwKChyb3csIGluZGV4KSA9PiAoeyBpbmRleCwgdmFsdWU6IHJvd1tjb2x1bW5dIH0pKVxuICAgICAgLmZpbHRlcihpdGVtID0+IGl0ZW0udmFsdWUgJiYgaXNOYU4ocGFyc2VGbG9hdChpdGVtLnZhbHVlLnRvU3RyaW5nKCkucmVwbGFjZSgvWywlXS9nLCAnJykpKSlcbiAgICBcbiAgICBpZiAobm9uTnVtZXJpY1ZhbHVlcy5sZW5ndGggPiAwKSB7XG4gICAgICB3YXJuaW5ncy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ25vbl9udW1lcmljX3ZhbHVlcycsXG4gICAgICAgIG1lc3NhZ2U6IGBOb24tbnVtZXJpYyB2YWx1ZXMgZGV0ZWN0ZWQgaW4gJHtjb2x1bW59YCxcbiAgICAgICAgaG93VG9GaXg6IGBDbGVhbiBudW1lcmljIGRhdGEgaW4gJyR7Y29sdW1ufScgY29sdW1uYCxcbiAgICAgICAgZXhhbXBsZXM6IFtcbiAgICAgICAgICAnUmVtb3ZlIGN1cnJlbmN5IHN5bWJvbHM6ICQxLDIzNC41NiDihpIgMTIzNC41NicsXG4gICAgICAgICAgJ1JlbW92ZSBwZXJjZW50YWdlIHNpZ25zOiAyNC43OCUg4oaSIDI0Ljc4JyxcbiAgICAgICAgICAnUmVtb3ZlIGNvbW1hczogMSwyMzQg4oaSIDEyMzQnLFxuICAgICAgICAgICdSZXBsYWNlIHRleHQgd2l0aCBudW1iZXJzIG9yIGxlYXZlIGVtcHR5JyxcbiAgICAgICAgICAnRXhhbXBsZXMgZm91bmQ6ICcgKyBub25OdW1lcmljVmFsdWVzLnNsaWNlKDAsIDMpLm1hcCh2ID0+IGBcIiR7di52YWx1ZX1cImApLmpvaW4oJywgJylcbiAgICAgICAgXSxcbiAgICAgICAgY29sdW1uLFxuICAgICAgICBzYW1wbGVzOiBub25OdW1lcmljVmFsdWVzLnNsaWNlKDAsIDUpXG4gICAgICB9KVxuICAgIH1cbiAgfSlcblxuICByZXR1cm4gd2FybmluZ3Ncbn1cblxuZnVuY3Rpb24gZ2V0TnVtZXJpY0NvbHVtbnMocGxhdGZvcm06IFBsYXRmb3JtLCBoZWFkZXJzOiBzdHJpbmdbXSk6IHN0cmluZ1tdIHtcbiAgY29uc3QgbnVtZXJpY1BhdHRlcm5zOiBSZWNvcmQ8UGxhdGZvcm0sIHN0cmluZ1tdPiA9IHtcbiAgICBtZXRhOiBbJ2Ftb3VudCcsICdzcGVudCcsICdjb3N0JywgJ2N0cicsICdjcG0nXSxcbiAgICBnb29nbGU6IFsnY29zdCcsICdjdHInLCAnY3BtJ10sXG4gICAgc2hvcGlmeTogWyd2aXNpdG9ycycsICdzZXNzaW9ucycsICdjaGVja291dCcsICdkdXJhdGlvbicsICdwYWdldmlld3MnXVxuICB9XG5cbiAgcmV0dXJuIGhlYWRlcnMuZmlsdGVyKGhlYWRlciA9PiB7XG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZUNvbHVtbk5hbWUoaGVhZGVyKVxuICAgIHJldHVybiBudW1lcmljUGF0dGVybnNbcGxhdGZvcm1dLnNvbWUocGF0dGVybiA9PiBub3JtYWxpemVkLmluY2x1ZGVzKHBhdHRlcm4pKVxuICB9KVxufVxuXG5mdW5jdGlvbiBkZXRlY3REYXRlUmFuZ2UoZGF0YTogYW55W10sIGRhdGVDb2x1bW46IHN0cmluZyB8IHVuZGVmaW5lZCk6IERhdGVSYW5nZSB8IG51bGwge1xuICBpZiAoIWRhdGVDb2x1bW4gfHwgZGF0YS5sZW5ndGggPT09IDApIHJldHVybiBudWxsXG4gIFxuICBjb25zdCBkYXRlcyA9IGRhdGFcbiAgICAubWFwKHJvdyA9PiByb3dbZGF0ZUNvbHVtbl0pXG4gICAgLmZpbHRlcihCb29sZWFuKVxuICAgIC5tYXAoZGF0ZVN0ciA9PiBuZXcgRGF0ZShkYXRlU3RyKSlcbiAgICAuZmlsdGVyKGRhdGUgPT4gIWlzTmFOKGRhdGUuZ2V0VGltZSgpKSlcbiAgICAuc29ydCgpXG5cbiAgaWYgKGRhdGVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGxcblxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBkYXRlc1swXS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF0sXG4gICAgZW5kOiBkYXRlc1tkYXRlcy5sZW5ndGggLSAxXS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF0sXG4gICAgdG90YWxEYXlzOiBNYXRoLmNlaWwoKGRhdGVzW2RhdGVzLmxlbmd0aCAtIDFdLmdldFRpbWUoKSAtIGRhdGVzWzBdLmdldFRpbWUoKSkgLyAoMTAwMCAqIDYwICogNjAgKiAyNCkpICsgMVxuICB9XG59Il0sIm5hbWVzIjpbIlBhcGEiLCJQTEFURk9STV9TQ0hFTUFTIiwibWV0YSIsInJlcXVpcmVkIiwiZGF0ZUNvbHVtbiIsInJlcXVpcmVkRGF0ZUZvcm1hdCIsImFjY2VwdGVkRm9ybWF0cyIsIm9yZGVyTWF0dGVycyIsImdvb2dsZSIsInNob3BpZnkiLCJ2YWxpZGF0ZUNTViIsInBsYXRmb3JtIiwiZmlsZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicGFyc2UiLCJoZWFkZXIiLCJwcmV2aWV3IiwiY29tcGxldGUiLCJyZXN1bHRzIiwidmFsaWRhdGlvbiIsInBlcmZvcm1WYWxpZGF0aW9uIiwiZGF0YSIsImZpZWxkcyIsImVycm9yIiwiaXNWYWxpZCIsImhhc0Vycm9ycyIsImhhc1dhcm5pbmdzIiwibmVlZHNDb3JyZWN0aW9uIiwiZXJyb3JzIiwidHlwZSIsIm1lc3NhZ2UiLCJ3YXJuaW5ncyIsInJvd0NvdW50IiwiY29sdW1uQ291bnQiLCJkYXRlUmFuZ2UiLCJoZWFkZXJzIiwic2NoZW1hIiwiY2xlYW5IZWFkZXJzIiwibWFwIiwiaCIsInJlcGxhY2UiLCJ0cmltIiwiY29sdW1uTWFwcGluZ0lzc3VlcyIsInJlcXVpcmVkQ29sIiwiZXhhY3RNYXRjaCIsImZpbmQiLCJjYXNlSW5zZW5zaXRpdmVNYXRjaCIsInRvTG93ZXJDYXNlIiwicHVzaCIsImZvdW5kIiwiaXNzdWUiLCJmdXp6eU1hdGNoIiwibm9ybWFsaXplQ29sdW1uTmFtZSIsIm1pc3NpbmdDb2x1bW5zIiwiZmlsdGVyIiwiY2FzZU1pc21hdGNoQ29sdW1ucyIsIm5hbWVWYXJpYXRpb25Db2x1bW5zIiwibGVuZ3RoIiwiYyIsImpvaW4iLCJob3dUb0ZpeCIsImV4YW1wbGVzIiwiY29sdW1ucyIsImRldGFpbHMiLCJ1bmV4cGVjdGVkQ29sdW1ucyIsInNvbWUiLCJyZXEiLCJzbGljZSIsImluY2x1ZGVzIiwibm90ZSIsImVtcHR5SGVhZGVycyIsImR1cGxpY2F0ZUhlYWRlcnMiLCJpbmRleCIsImluZGV4T2YiLCJTZXQiLCJmaW5kQ29sdW1uQnlOYW1lIiwiZGF0ZVZhbGlkYXRpb24iLCJ2YWxpZGF0ZURhdGVGb3JtYXRzIiwiYWxsb3dlZEZvcm1hdHMiLCJub25TdGFuZGFyZEZvcm1hdHMiLCJkZXRlY3RlZEZvcm1hdHMiLCJmb3JtYXQiLCJpbnZhbGlkRGF0ZXMiLCJkIiwidmFsdWUiLCJudW1lcmljVmFsaWRhdGlvbiIsInZhbGlkYXRlTnVtZXJpY0NvbHVtbnMiLCJkZXRlY3REYXRlUmFuZ2UiLCJuYW1lIiwidGFyZ2V0TmFtZSIsImZvcm1hdHMiLCJmb3JFYWNoIiwicm93IiwiZGF0ZVZhbHVlIiwiZGV0ZWN0ZWRGb3JtYXQiLCJkZXRlY3REYXRlRm9ybWF0IiwiYWRkIiwiaGFzSXNzdWVzIiwic2l6ZSIsIkFycmF5IiwiZnJvbSIsInJlY29tbWVuZGVkRm9ybWF0IiwiZGF0ZVN0cmluZyIsInRyaW1tZWQiLCJwYXR0ZXJucyIsInJlZ2V4IiwicGF0dGVybiIsInRlc3QiLCJudW1lcmljQ29sdW1ucyIsImdldE51bWVyaWNDb2x1bW5zIiwiY29sdW1uIiwibm9uTnVtZXJpY1ZhbHVlcyIsIml0ZW0iLCJpc05hTiIsInBhcnNlRmxvYXQiLCJ0b1N0cmluZyIsInYiLCJzYW1wbGVzIiwibnVtZXJpY1BhdHRlcm5zIiwibm9ybWFsaXplZCIsImRhdGVzIiwiQm9vbGVhbiIsImRhdGVTdHIiLCJEYXRlIiwiZGF0ZSIsImdldFRpbWUiLCJzb3J0Iiwic3RhcnQiLCJ0b0lTT1N0cmluZyIsInNwbGl0IiwiZW5kIiwidG90YWxEYXlzIiwiTWF0aCIsImNlaWwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/validators.ts\n"));

/***/ })

});