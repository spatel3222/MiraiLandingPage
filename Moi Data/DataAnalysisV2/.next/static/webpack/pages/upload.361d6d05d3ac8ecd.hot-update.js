"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/upload",{

/***/ "./lib/validators.ts":
/*!***************************!*\
  !*** ./lib/validators.ts ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PLATFORM_SCHEMAS: function() { return /* binding */ PLATFORM_SCHEMAS; },\n/* harmony export */   validateCSV: function() { return /* binding */ validateCSV; }\n/* harmony export */ });\n/* harmony import */ var papaparse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! papaparse */ \"./node_modules/papaparse/papaparse.min.js\");\n/* harmony import */ var papaparse__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(papaparse__WEBPACK_IMPORTED_MODULE_0__);\n\nconst PLATFORM_SCHEMAS = {\n    meta: {\n        required: [\n            \"Day\",\n            \"Campaign name\",\n            \"Ad set name\",\n            \"Ad name\",\n            \"Amount spent (INR)\",\n            \"CTR (link click-through rate)\",\n            \"CPM (cost per 1,000 impressions)\"\n        ],\n        dateColumn: \"Day\",\n        expectedFormats: [\n            \"YYYY-MM-DD\",\n            \"DD-MM-YYYY\",\n            \"MM/DD/YYYY\"\n        ]\n    },\n    google: {\n        required: [\n            \"Day\",\n            \"Campaign\",\n            \"Cost\",\n            \"CTR\",\n            \"Avg. CPM\"\n        ],\n        dateColumn: \"Day\",\n        expectedFormats: [\n            \"YYYY-MM-DD\",\n            \"DD-MM-YYYY\",\n            \"MM/DD/YYYY\"\n        ]\n    },\n    shopify: {\n        required: [\n            \"Day\",\n            \"UTM campaign\",\n            \"UTM term\",\n            \"UTM content\",\n            \"Online store visitors\",\n            \"Sessions that completed checkout\"\n        ],\n        dateColumn: \"Day\",\n        expectedFormats: [\n            \"YYYY-MM-DD\",\n            \"DD-MM-YYYY\",\n            \"MM/DD/YYYY\"\n        ]\n    }\n};\nasync function validateCSV(platform, file) {\n    return new Promise((resolve)=>{\n        papaparse__WEBPACK_IMPORTED_MODULE_0___default().parse(file, {\n            header: true,\n            preview: 100,\n            complete: (results)=>{\n                const validation = performValidation(platform, results.data, results.meta.fields || []);\n                resolve(validation);\n            },\n            error: (error)=>{\n                resolve({\n                    isValid: false,\n                    hasErrors: true,\n                    hasWarnings: false,\n                    needsCorrection: false,\n                    errors: [\n                        {\n                            type: \"parse_error\",\n                            message: error.message\n                        }\n                    ],\n                    warnings: [],\n                    rowCount: 0,\n                    columnCount: 0,\n                    dateRange: null\n                });\n            }\n        });\n    });\n}\nfunction performValidation(platform, data, headers) {\n    const schema = PLATFORM_SCHEMAS[platform];\n    const errors = [];\n    const warnings = [];\n    // Check required columns\n    const missingColumns = schema.required.filter((col)=>!headers.some((header)=>normalizeColumnName(header) === normalizeColumnName(col)));\n    if (missingColumns.length > 0) {\n        errors.push({\n            type: \"missing_columns\",\n            message: \"Missing required columns: \".concat(missingColumns.join(\", \")),\n            columns: missingColumns\n        });\n    }\n    // Validate date formats (STRICT - must be YYYY-MM-DD)\n    const dateColumn = findColumnByName(headers, schema.dateColumn);\n    if (dateColumn) {\n        const dateValidation = validateDateFormats(data, dateColumn);\n        // Check for wrong date formats - make this an ERROR not warning\n        const nonStandardFormats = dateValidation.detectedFormats.filter((format)=>format !== \"YYYY-MM-DD\");\n        if (nonStandardFormats.length > 0) {\n            errors.push({\n                type: \"invalid_date_format\",\n                message: \"Date column '\".concat(dateColumn, \"' must use YYYY-MM-DD format. Found: \").concat(nonStandardFormats.join(\", \"), \". Example correct format: 2025-11-10\"),\n                columns: [\n                    dateColumn\n                ]\n            });\n        }\n        // Check for invalid/unparseable dates\n        if (dateValidation.invalidDates.length > 0) {\n            errors.push({\n                type: \"invalid_date_values\",\n                message: \"Invalid date values found in '\".concat(dateColumn, \"': \").concat(dateValidation.invalidDates.slice(0, 3).map((d)=>d.value).join(\", \")),\n                columns: [\n                    dateColumn\n                ]\n            });\n        }\n        // Only add warnings for minor issues if no errors\n        if (nonStandardFormats.length === 0 && dateValidation.invalidDates.length === 0 && dateValidation.detectedFormats.length > 1) {\n            warnings.push({\n                type: \"date_format_inconsistency\",\n                message: \"Multiple date formats detected in \".concat(dateColumn),\n                details: dateValidation\n            });\n        }\n    }\n    // Validate numeric columns\n    const numericValidation = validateNumericColumns(platform, data, headers);\n    warnings.push(...numericValidation);\n    return {\n        isValid: errors.length === 0,\n        hasErrors: errors.length > 0,\n        hasWarnings: warnings.length > 0,\n        needsCorrection: warnings.length > 0,\n        errors,\n        warnings,\n        rowCount: data.length,\n        columnCount: headers.length,\n        dateRange: detectDateRange(data, dateColumn)\n    };\n}\nfunction normalizeColumnName(name) {\n    return name.toLowerCase().trim().replace(/[^\\w]/g, \"_\");\n}\nfunction findColumnByName(headers, targetName) {\n    return headers.find((header)=>normalizeColumnName(header) === normalizeColumnName(targetName));\n}\nfunction validateDateFormats(data, dateColumn) {\n    const formats = new Set();\n    const invalidDates = [];\n    data.slice(0, 50).forEach((row, index)=>{\n        const dateValue = row[dateColumn];\n        if (dateValue) {\n            const detectedFormat = detectDateFormat(dateValue);\n            if (detectedFormat) {\n                formats.add(detectedFormat);\n            } else {\n                invalidDates.push({\n                    row: index,\n                    value: dateValue\n                });\n            }\n        }\n    });\n    return {\n        hasIssues: formats.size > 1 || invalidDates.length > 0,\n        detectedFormats: Array.from(formats),\n        invalidDates,\n        recommendedFormat: \"YYYY-MM-DD\"\n    };\n}\nfunction detectDateFormat(dateString) {\n    const patterns = [\n        {\n            regex: /^\\d{4}-\\d{2}-\\d{2}$/,\n            format: \"YYYY-MM-DD\"\n        },\n        {\n            regex: /^\\d{2}-\\d{2}-\\d{4}$/,\n            format: \"DD-MM-YYYY\"\n        },\n        {\n            regex: /^\\d{2}\\/\\d{2}\\/\\d{4}$/,\n            format: \"MM/DD/YYYY\"\n        },\n        {\n            regex: /^\\d{1,2}\\/\\d{1,2}\\/\\d{4}$/,\n            format: \"M/D/YYYY\"\n        }\n    ];\n    for (const pattern of patterns){\n        if (pattern.regex.test(dateString)) {\n            return pattern.format;\n        }\n    }\n    return null;\n}\nfunction validateNumericColumns(platform, data, headers) {\n    const warnings = [];\n    const numericColumns = getNumericColumns(platform, headers);\n    numericColumns.forEach((column)=>{\n        const nonNumericValues = data.slice(0, 50).map((row, index)=>({\n                index,\n                value: row[column]\n            })).filter((item)=>item.value && isNaN(parseFloat(item.value.toString().replace(/[,%]/g, \"\"))));\n        if (nonNumericValues.length > 0) {\n            warnings.push({\n                type: \"non_numeric_values\",\n                message: \"Non-numeric values detected in \".concat(column),\n                column,\n                samples: nonNumericValues.slice(0, 5)\n            });\n        }\n    });\n    return warnings;\n}\nfunction getNumericColumns(platform, headers) {\n    const numericPatterns = {\n        meta: [\n            \"amount\",\n            \"spent\",\n            \"cost\",\n            \"ctr\",\n            \"cpm\"\n        ],\n        google: [\n            \"cost\",\n            \"ctr\",\n            \"cpm\"\n        ],\n        shopify: [\n            \"visitors\",\n            \"sessions\",\n            \"checkout\",\n            \"duration\",\n            \"pageviews\"\n        ]\n    };\n    return headers.filter((header)=>{\n        const normalized = normalizeColumnName(header);\n        return numericPatterns[platform].some((pattern)=>normalized.includes(pattern));\n    });\n}\nfunction detectDateRange(data, dateColumn) {\n    if (!dateColumn || data.length === 0) return null;\n    const dates = data.map((row)=>row[dateColumn]).filter(Boolean).map((dateStr)=>new Date(dateStr)).filter((date)=>!isNaN(date.getTime())).sort();\n    if (dates.length === 0) return null;\n    return {\n        start: dates[0].toISOString().split(\"T\")[0],\n        end: dates[dates.length - 1].toISOString().split(\"T\")[0],\n        totalDays: Math.ceil((dates[dates.length - 1].getTime() - dates[0].getTime()) / (1000 * 60 * 60 * 24)) + 1\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QSxVQUFXLElBQUlDLEtBQUtELFVBQ3hCOUQsTUFBTSxDQUFDZ0UsQ0FBQUEsT0FBUSxDQUFDWCxNQUFNVyxLQUFLQyxPQUFPLEtBQ2xDQyxJQUFJO0lBRVAsSUFBSU4sTUFBTXhELE1BQU0sS0FBSyxHQUFHLE9BQU87SUFFL0IsT0FBTztRQUNMK0QsT0FBT1AsS0FBSyxDQUFDLEVBQUUsQ0FBQ1EsV0FBVyxHQUFHQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7UUFDM0NDLEtBQUtWLEtBQUssQ0FBQ0EsTUFBTXhELE1BQU0sR0FBRyxFQUFFLENBQUNnRSxXQUFXLEdBQUdDLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRTtRQUN4REUsV0FBV0MsS0FBS0MsSUFBSSxDQUFDLENBQUNiLEtBQUssQ0FBQ0EsTUFBTXhELE1BQU0sR0FBRyxFQUFFLENBQUM2RCxPQUFPLEtBQUtMLEtBQUssQ0FBQyxFQUFFLENBQUNLLE9BQU8sRUFBQyxJQUFNLFFBQU8sS0FBSyxLQUFLLEVBQUMsS0FBTTtJQUMzRztBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi92YWxpZGF0b3JzLnRzPzU2YjAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFBhcGEgZnJvbSAncGFwYXBhcnNlJ1xuaW1wb3J0IHsgUGxhdGZvcm0gfSBmcm9tICcuL3N1cGFiYXNlJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFZhbGlkYXRpb25SZXN1bHQge1xuICBpc1ZhbGlkOiBib29sZWFuXG4gIGhhc0Vycm9yczogYm9vbGVhblxuICBoYXNXYXJuaW5nczogYm9vbGVhblxuICBuZWVkc0NvcnJlY3Rpb246IGJvb2xlYW5cbiAgZXJyb3JzOiBWYWxpZGF0aW9uRXJyb3JbXVxuICB3YXJuaW5nczogVmFsaWRhdGlvbldhcm5pbmdbXVxuICByb3dDb3VudDogbnVtYmVyXG4gIGNvbHVtbkNvdW50OiBudW1iZXJcbiAgZGF0ZVJhbmdlOiBEYXRlUmFuZ2UgfCBudWxsXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmFsaWRhdGlvbkVycm9yIHtcbiAgdHlwZTogc3RyaW5nXG4gIG1lc3NhZ2U6IHN0cmluZ1xuICBjb2x1bW5zPzogc3RyaW5nW11cbn1cblxuZXhwb3J0IGludGVyZmFjZSBWYWxpZGF0aW9uV2FybmluZyB7XG4gIHR5cGU6IHN0cmluZ1xuICBtZXNzYWdlOiBzdHJpbmdcbiAgY29sdW1uPzogc3RyaW5nXG4gIHNhbXBsZXM/OiBhbnlbXVxuICBkZXRhaWxzPzogYW55XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF0ZVJhbmdlIHtcbiAgc3RhcnQ6IHN0cmluZ1xuICBlbmQ6IHN0cmluZ1xuICB0b3RhbERheXM6IG51bWJlclxufVxuXG5leHBvcnQgY29uc3QgUExBVEZPUk1fU0NIRU1BUzogUmVjb3JkPFBsYXRmb3JtLCB7XG4gIHJlcXVpcmVkOiBzdHJpbmdbXVxuICBkYXRlQ29sdW1uOiBzdHJpbmdcbiAgZXhwZWN0ZWRGb3JtYXRzOiBzdHJpbmdbXVxufT4gPSB7XG4gIG1ldGE6IHtcbiAgICByZXF1aXJlZDogW1xuICAgICAgJ0RheScsXG4gICAgICAnQ2FtcGFpZ24gbmFtZScsXG4gICAgICAnQWQgc2V0IG5hbWUnLCBcbiAgICAgICdBZCBuYW1lJyxcbiAgICAgICdBbW91bnQgc3BlbnQgKElOUiknLFxuICAgICAgJ0NUUiAobGluayBjbGljay10aHJvdWdoIHJhdGUpJyxcbiAgICAgICdDUE0gKGNvc3QgcGVyIDEsMDAwIGltcHJlc3Npb25zKSdcbiAgICBdLFxuICAgIGRhdGVDb2x1bW46ICdEYXknLFxuICAgIGV4cGVjdGVkRm9ybWF0czogWydZWVlZLU1NLUREJywgJ0RELU1NLVlZWVknLCAnTU0vREQvWVlZWSddXG4gIH0sXG4gIGdvb2dsZToge1xuICAgIHJlcXVpcmVkOiBbXG4gICAgICAnRGF5JyxcbiAgICAgICdDYW1wYWlnbicsXG4gICAgICAnQ29zdCcsXG4gICAgICAnQ1RSJyxcbiAgICAgICdBdmcuIENQTSdcbiAgICBdLFxuICAgIGRhdGVDb2x1bW46ICdEYXknLFxuICAgIGV4cGVjdGVkRm9ybWF0czogWydZWVlZLU1NLUREJywgJ0RELU1NLVlZWVknLCAnTU0vREQvWVlZWSddXG4gIH0sXG4gIHNob3BpZnk6IHtcbiAgICByZXF1aXJlZDogW1xuICAgICAgJ0RheScsXG4gICAgICAnVVRNIGNhbXBhaWduJyxcbiAgICAgICdVVE0gdGVybScsXG4gICAgICAnVVRNIGNvbnRlbnQnLFxuICAgICAgJ09ubGluZSBzdG9yZSB2aXNpdG9ycycsXG4gICAgICAnU2Vzc2lvbnMgdGhhdCBjb21wbGV0ZWQgY2hlY2tvdXQnXG4gICAgXSxcbiAgICBkYXRlQ29sdW1uOiAnRGF5JyxcbiAgICBleHBlY3RlZEZvcm1hdHM6IFsnWVlZWS1NTS1ERCcsICdERC1NTS1ZWVlZJywgJ01NL0REL1lZWVknXVxuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB2YWxpZGF0ZUNTVihwbGF0Zm9ybTogUGxhdGZvcm0sIGZpbGU6IEZpbGUpOiBQcm9taXNlPFZhbGlkYXRpb25SZXN1bHQ+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgUGFwYS5wYXJzZShmaWxlLCB7XG4gICAgICBoZWFkZXI6IHRydWUsXG4gICAgICBwcmV2aWV3OiAxMDAsXG4gICAgICBjb21wbGV0ZTogKHJlc3VsdHMpID0+IHtcbiAgICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IHBlcmZvcm1WYWxpZGF0aW9uKHBsYXRmb3JtLCByZXN1bHRzLmRhdGEsIHJlc3VsdHMubWV0YS5maWVsZHMgfHwgW10pXG4gICAgICAgIHJlc29sdmUodmFsaWRhdGlvbilcbiAgICAgIH0sXG4gICAgICBlcnJvcjogKGVycm9yKSA9PiB7XG4gICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgICAgIGhhc0Vycm9yczogdHJ1ZSxcbiAgICAgICAgICBoYXNXYXJuaW5nczogZmFsc2UsXG4gICAgICAgICAgbmVlZHNDb3JyZWN0aW9uOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcnM6IFt7IHR5cGU6ICdwYXJzZV9lcnJvcicsIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UgfV0sXG4gICAgICAgICAgd2FybmluZ3M6IFtdLFxuICAgICAgICAgIHJvd0NvdW50OiAwLFxuICAgICAgICAgIGNvbHVtbkNvdW50OiAwLFxuICAgICAgICAgIGRhdGVSYW5nZTogbnVsbFxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0pXG4gIH0pXG59XG5cbmZ1bmN0aW9uIHBlcmZvcm1WYWxpZGF0aW9uKHBsYXRmb3JtOiBQbGF0Zm9ybSwgZGF0YTogYW55W10sIGhlYWRlcnM6IHN0cmluZ1tdKTogVmFsaWRhdGlvblJlc3VsdCB7XG4gIGNvbnN0IHNjaGVtYSA9IFBMQVRGT1JNX1NDSEVNQVNbcGxhdGZvcm1dXG4gIGNvbnN0IGVycm9yczogVmFsaWRhdGlvbkVycm9yW10gPSBbXVxuICBjb25zdCB3YXJuaW5nczogVmFsaWRhdGlvbldhcm5pbmdbXSA9IFtdXG5cbiAgLy8gQ2hlY2sgcmVxdWlyZWQgY29sdW1uc1xuICBjb25zdCBtaXNzaW5nQ29sdW1ucyA9IHNjaGVtYS5yZXF1aXJlZC5maWx0ZXIoY29sID0+IFxuICAgICFoZWFkZXJzLnNvbWUoaGVhZGVyID0+IG5vcm1hbGl6ZUNvbHVtbk5hbWUoaGVhZGVyKSA9PT0gbm9ybWFsaXplQ29sdW1uTmFtZShjb2wpKVxuICApXG4gIFxuICBpZiAobWlzc2luZ0NvbHVtbnMubGVuZ3RoID4gMCkge1xuICAgIGVycm9ycy5wdXNoKHtcbiAgICAgIHR5cGU6ICdtaXNzaW5nX2NvbHVtbnMnLFxuICAgICAgbWVzc2FnZTogYE1pc3NpbmcgcmVxdWlyZWQgY29sdW1uczogJHttaXNzaW5nQ29sdW1ucy5qb2luKCcsICcpfWAsXG4gICAgICBjb2x1bW5zOiBtaXNzaW5nQ29sdW1uc1xuICAgIH0pXG4gIH1cblxuICAvLyBWYWxpZGF0ZSBkYXRlIGZvcm1hdHMgKFNUUklDVCAtIG11c3QgYmUgWVlZWS1NTS1ERClcbiAgY29uc3QgZGF0ZUNvbHVtbiA9IGZpbmRDb2x1bW5CeU5hbWUoaGVhZGVycywgc2NoZW1hLmRhdGVDb2x1bW4pXG4gIGlmIChkYXRlQ29sdW1uKSB7XG4gICAgY29uc3QgZGF0ZVZhbGlkYXRpb24gPSB2YWxpZGF0ZURhdGVGb3JtYXRzKGRhdGEsIGRhdGVDb2x1bW4pXG4gICAgXG4gICAgLy8gQ2hlY2sgZm9yIHdyb25nIGRhdGUgZm9ybWF0cyAtIG1ha2UgdGhpcyBhbiBFUlJPUiBub3Qgd2FybmluZ1xuICAgIGNvbnN0IG5vblN0YW5kYXJkRm9ybWF0cyA9IGRhdGVWYWxpZGF0aW9uLmRldGVjdGVkRm9ybWF0cy5maWx0ZXIoZm9ybWF0ID0+IGZvcm1hdCAhPT0gJ1lZWVktTU0tREQnKVxuICAgIGlmIChub25TdGFuZGFyZEZvcm1hdHMubGVuZ3RoID4gMCkge1xuICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICB0eXBlOiAnaW52YWxpZF9kYXRlX2Zvcm1hdCcsXG4gICAgICAgIG1lc3NhZ2U6IGBEYXRlIGNvbHVtbiAnJHtkYXRlQ29sdW1ufScgbXVzdCB1c2UgWVlZWS1NTS1ERCBmb3JtYXQuIEZvdW5kOiAke25vblN0YW5kYXJkRm9ybWF0cy5qb2luKCcsICcpfS4gRXhhbXBsZSBjb3JyZWN0IGZvcm1hdDogMjAyNS0xMS0xMGAsXG4gICAgICAgIGNvbHVtbnM6IFtkYXRlQ29sdW1uXVxuICAgICAgfSlcbiAgICB9XG4gICAgXG4gICAgLy8gQ2hlY2sgZm9yIGludmFsaWQvdW5wYXJzZWFibGUgZGF0ZXNcbiAgICBpZiAoZGF0ZVZhbGlkYXRpb24uaW52YWxpZERhdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2ludmFsaWRfZGF0ZV92YWx1ZXMnLFxuICAgICAgICBtZXNzYWdlOiBgSW52YWxpZCBkYXRlIHZhbHVlcyBmb3VuZCBpbiAnJHtkYXRlQ29sdW1ufSc6ICR7ZGF0ZVZhbGlkYXRpb24uaW52YWxpZERhdGVzLnNsaWNlKDAsIDMpLm1hcChkID0+IGQudmFsdWUpLmpvaW4oJywgJyl9YCxcbiAgICAgICAgY29sdW1uczogW2RhdGVDb2x1bW5dXG4gICAgICB9KVxuICAgIH1cbiAgICBcbiAgICAvLyBPbmx5IGFkZCB3YXJuaW5ncyBmb3IgbWlub3IgaXNzdWVzIGlmIG5vIGVycm9yc1xuICAgIGlmIChub25TdGFuZGFyZEZvcm1hdHMubGVuZ3RoID09PSAwICYmIGRhdGVWYWxpZGF0aW9uLmludmFsaWREYXRlcy5sZW5ndGggPT09IDAgJiYgZGF0ZVZhbGlkYXRpb24uZGV0ZWN0ZWRGb3JtYXRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHdhcm5pbmdzLnB1c2goe1xuICAgICAgICB0eXBlOiAnZGF0ZV9mb3JtYXRfaW5jb25zaXN0ZW5jeScsXG4gICAgICAgIG1lc3NhZ2U6IGBNdWx0aXBsZSBkYXRlIGZvcm1hdHMgZGV0ZWN0ZWQgaW4gJHtkYXRlQ29sdW1ufWAsXG4gICAgICAgIGRldGFpbHM6IGRhdGVWYWxpZGF0aW9uXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIC8vIFZhbGlkYXRlIG51bWVyaWMgY29sdW1uc1xuICBjb25zdCBudW1lcmljVmFsaWRhdGlvbiA9IHZhbGlkYXRlTnVtZXJpY0NvbHVtbnMocGxhdGZvcm0sIGRhdGEsIGhlYWRlcnMpXG4gIHdhcm5pbmdzLnB1c2goLi4ubnVtZXJpY1ZhbGlkYXRpb24pXG5cbiAgcmV0dXJuIHtcbiAgICBpc1ZhbGlkOiBlcnJvcnMubGVuZ3RoID09PSAwLFxuICAgIGhhc0Vycm9yczogZXJyb3JzLmxlbmd0aCA+IDAsXG4gICAgaGFzV2FybmluZ3M6IHdhcm5pbmdzLmxlbmd0aCA+IDAsXG4gICAgbmVlZHNDb3JyZWN0aW9uOiB3YXJuaW5ncy5sZW5ndGggPiAwLFxuICAgIGVycm9ycyxcbiAgICB3YXJuaW5ncyxcbiAgICByb3dDb3VudDogZGF0YS5sZW5ndGgsXG4gICAgY29sdW1uQ291bnQ6IGhlYWRlcnMubGVuZ3RoLFxuICAgIGRhdGVSYW5nZTogZGV0ZWN0RGF0ZVJhbmdlKGRhdGEsIGRhdGVDb2x1bW4pXG4gIH1cbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplQ29sdW1uTmFtZShuYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gbmFtZS50b0xvd2VyQ2FzZSgpLnRyaW0oKS5yZXBsYWNlKC9bXlxcd10vZywgJ18nKVxufVxuXG5mdW5jdGlvbiBmaW5kQ29sdW1uQnlOYW1lKGhlYWRlcnM6IHN0cmluZ1tdLCB0YXJnZXROYW1lOiBzdHJpbmcpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICByZXR1cm4gaGVhZGVycy5maW5kKGhlYWRlciA9PiBcbiAgICBub3JtYWxpemVDb2x1bW5OYW1lKGhlYWRlcikgPT09IG5vcm1hbGl6ZUNvbHVtbk5hbWUodGFyZ2V0TmFtZSlcbiAgKVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZURhdGVGb3JtYXRzKGRhdGE6IGFueVtdLCBkYXRlQ29sdW1uOiBzdHJpbmcpOiB7IGhhc0lzc3VlczogYm9vbGVhbjsgZGV0ZWN0ZWRGb3JtYXRzOiBzdHJpbmdbXTsgaW52YWxpZERhdGVzOiBhbnlbXTsgcmVjb21tZW5kZWRGb3JtYXQ6IHN0cmluZyB9IHtcbiAgY29uc3QgZm9ybWF0cyA9IG5ldyBTZXQ8c3RyaW5nPigpXG4gIGNvbnN0IGludmFsaWREYXRlczogYW55W10gPSBbXVxuICBcbiAgZGF0YS5zbGljZSgwLCA1MCkuZm9yRWFjaCgocm93LCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IGRhdGVWYWx1ZSA9IHJvd1tkYXRlQ29sdW1uXVxuICAgIGlmIChkYXRlVmFsdWUpIHtcbiAgICAgIGNvbnN0IGRldGVjdGVkRm9ybWF0ID0gZGV0ZWN0RGF0ZUZvcm1hdChkYXRlVmFsdWUpXG4gICAgICBpZiAoZGV0ZWN0ZWRGb3JtYXQpIHtcbiAgICAgICAgZm9ybWF0cy5hZGQoZGV0ZWN0ZWRGb3JtYXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnZhbGlkRGF0ZXMucHVzaCh7IHJvdzogaW5kZXgsIHZhbHVlOiBkYXRlVmFsdWUgfSlcbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIHtcbiAgICBoYXNJc3N1ZXM6IGZvcm1hdHMuc2l6ZSA+IDEgfHwgaW52YWxpZERhdGVzLmxlbmd0aCA+IDAsXG4gICAgZGV0ZWN0ZWRGb3JtYXRzOiBBcnJheS5mcm9tKGZvcm1hdHMpLFxuICAgIGludmFsaWREYXRlcyxcbiAgICByZWNvbW1lbmRlZEZvcm1hdDogJ1lZWVktTU0tREQnXG4gIH1cbn1cblxuZnVuY3Rpb24gZGV0ZWN0RGF0ZUZvcm1hdChkYXRlU3RyaW5nOiBzdHJpbmcpOiBzdHJpbmcgfCBudWxsIHtcbiAgY29uc3QgcGF0dGVybnMgPSBbXG4gICAgeyByZWdleDogL15cXGR7NH0tXFxkezJ9LVxcZHsyfSQvLCBmb3JtYXQ6ICdZWVlZLU1NLUREJyB9LFxuICAgIHsgcmVnZXg6IC9eXFxkezJ9LVxcZHsyfS1cXGR7NH0kLywgZm9ybWF0OiAnREQtTU0tWVlZWScgfSxcbiAgICB7IHJlZ2V4OiAvXlxcZHsyfVxcL1xcZHsyfVxcL1xcZHs0fSQvLCBmb3JtYXQ6ICdNTS9ERC9ZWVlZJyB9LFxuICAgIHsgcmVnZXg6IC9eXFxkezEsMn1cXC9cXGR7MSwyfVxcL1xcZHs0fSQvLCBmb3JtYXQ6ICdNL0QvWVlZWScgfVxuICBdXG5cbiAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIHBhdHRlcm5zKSB7XG4gICAgaWYgKHBhdHRlcm4ucmVnZXgudGVzdChkYXRlU3RyaW5nKSkge1xuICAgICAgcmV0dXJuIHBhdHRlcm4uZm9ybWF0XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsXG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTnVtZXJpY0NvbHVtbnMocGxhdGZvcm06IFBsYXRmb3JtLCBkYXRhOiBhbnlbXSwgaGVhZGVyczogc3RyaW5nW10pOiBWYWxpZGF0aW9uV2FybmluZ1tdIHtcbiAgY29uc3Qgd2FybmluZ3M6IFZhbGlkYXRpb25XYXJuaW5nW10gPSBbXVxuICBjb25zdCBudW1lcmljQ29sdW1ucyA9IGdldE51bWVyaWNDb2x1bW5zKHBsYXRmb3JtLCBoZWFkZXJzKVxuICBcbiAgbnVtZXJpY0NvbHVtbnMuZm9yRWFjaChjb2x1bW4gPT4ge1xuICAgIGNvbnN0IG5vbk51bWVyaWNWYWx1ZXMgPSBkYXRhLnNsaWNlKDAsIDUwKVxuICAgICAgLm1hcCgocm93LCBpbmRleCkgPT4gKHsgaW5kZXgsIHZhbHVlOiByb3dbY29sdW1uXSB9KSlcbiAgICAgIC5maWx0ZXIoaXRlbSA9PiBpdGVtLnZhbHVlICYmIGlzTmFOKHBhcnNlRmxvYXQoaXRlbS52YWx1ZS50b1N0cmluZygpLnJlcGxhY2UoL1ssJV0vZywgJycpKSkpXG4gICAgXG4gICAgaWYgKG5vbk51bWVyaWNWYWx1ZXMubGVuZ3RoID4gMCkge1xuICAgICAgd2FybmluZ3MucHVzaCh7XG4gICAgICAgIHR5cGU6ICdub25fbnVtZXJpY192YWx1ZXMnLFxuICAgICAgICBtZXNzYWdlOiBgTm9uLW51bWVyaWMgdmFsdWVzIGRldGVjdGVkIGluICR7Y29sdW1ufWAsXG4gICAgICAgIGNvbHVtbixcbiAgICAgICAgc2FtcGxlczogbm9uTnVtZXJpY1ZhbHVlcy5zbGljZSgwLCA1KVxuICAgICAgfSlcbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIHdhcm5pbmdzXG59XG5cbmZ1bmN0aW9uIGdldE51bWVyaWNDb2x1bW5zKHBsYXRmb3JtOiBQbGF0Zm9ybSwgaGVhZGVyczogc3RyaW5nW10pOiBzdHJpbmdbXSB7XG4gIGNvbnN0IG51bWVyaWNQYXR0ZXJuczogUmVjb3JkPFBsYXRmb3JtLCBzdHJpbmdbXT4gPSB7XG4gICAgbWV0YTogWydhbW91bnQnLCAnc3BlbnQnLCAnY29zdCcsICdjdHInLCAnY3BtJ10sXG4gICAgZ29vZ2xlOiBbJ2Nvc3QnLCAnY3RyJywgJ2NwbSddLFxuICAgIHNob3BpZnk6IFsndmlzaXRvcnMnLCAnc2Vzc2lvbnMnLCAnY2hlY2tvdXQnLCAnZHVyYXRpb24nLCAncGFnZXZpZXdzJ11cbiAgfVxuXG4gIHJldHVybiBoZWFkZXJzLmZpbHRlcihoZWFkZXIgPT4ge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVDb2x1bW5OYW1lKGhlYWRlcilcbiAgICByZXR1cm4gbnVtZXJpY1BhdHRlcm5zW3BsYXRmb3JtXS5zb21lKHBhdHRlcm4gPT4gbm9ybWFsaXplZC5pbmNsdWRlcyhwYXR0ZXJuKSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gZGV0ZWN0RGF0ZVJhbmdlKGRhdGE6IGFueVtdLCBkYXRlQ29sdW1uOiBzdHJpbmcgfCB1bmRlZmluZWQpOiBEYXRlUmFuZ2UgfCBudWxsIHtcbiAgaWYgKCFkYXRlQ29sdW1uIHx8IGRhdGEubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbFxuICBcbiAgY29uc3QgZGF0ZXMgPSBkYXRhXG4gICAgLm1hcChyb3cgPT4gcm93W2RhdGVDb2x1bW5dKVxuICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAubWFwKGRhdGVTdHIgPT4gbmV3IERhdGUoZGF0ZVN0cikpXG4gICAgLmZpbHRlcihkYXRlID0+ICFpc05hTihkYXRlLmdldFRpbWUoKSkpXG4gICAgLnNvcnQoKVxuXG4gIGlmIChkYXRlcy5sZW5ndGggPT09IDApIHJldHVybiBudWxsXG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydDogZGF0ZXNbMF0udG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdLFxuICAgIGVuZDogZGF0ZXNbZGF0ZXMubGVuZ3RoIC0gMV0udG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdLFxuICAgIHRvdGFsRGF5czogTWF0aC5jZWlsKChkYXRlc1tkYXRlcy5sZW5ndGggLSAxXS5nZXRUaW1lKCkgLSBkYXRlc1swXS5nZXRUaW1lKCkpIC8gKDEwMDAgKiA2MCAqIDYwICogMjQpKSArIDFcbiAgfVxufSJdLCJuYW1lcyI6WyJQYXBhIiwiUExBVEZPUk1fU0NIRU1BUyIsIm1ldGEiLCJyZXF1aXJlZCIsImRhdGVDb2x1bW4iLCJleHBlY3RlZEZvcm1hdHMiLCJnb29nbGUiLCJzaG9waWZ5IiwidmFsaWRhdGVDU1YiLCJwbGF0Zm9ybSIsImZpbGUiLCJQcm9taXNlIiwicmVzb2x2ZSIsInBhcnNlIiwiaGVhZGVyIiwicHJldmlldyIsImNvbXBsZXRlIiwicmVzdWx0cyIsInZhbGlkYXRpb24iLCJwZXJmb3JtVmFsaWRhdGlvbiIsImRhdGEiLCJmaWVsZHMiLCJlcnJvciIsImlzVmFsaWQiLCJoYXNFcnJvcnMiLCJoYXNXYXJuaW5ncyIsIm5lZWRzQ29ycmVjdGlvbiIsImVycm9ycyIsInR5cGUiLCJtZXNzYWdlIiwid2FybmluZ3MiLCJyb3dDb3VudCIsImNvbHVtbkNvdW50IiwiZGF0ZVJhbmdlIiwiaGVhZGVycyIsInNjaGVtYSIsIm1pc3NpbmdDb2x1bW5zIiwiZmlsdGVyIiwiY29sIiwic29tZSIsIm5vcm1hbGl6ZUNvbHVtbk5hbWUiLCJsZW5ndGgiLCJwdXNoIiwiam9pbiIsImNvbHVtbnMiLCJmaW5kQ29sdW1uQnlOYW1lIiwiZGF0ZVZhbGlkYXRpb24iLCJ2YWxpZGF0ZURhdGVGb3JtYXRzIiwibm9uU3RhbmRhcmRGb3JtYXRzIiwiZGV0ZWN0ZWRGb3JtYXRzIiwiZm9ybWF0IiwiaW52YWxpZERhdGVzIiwic2xpY2UiLCJtYXAiLCJkIiwidmFsdWUiLCJkZXRhaWxzIiwibnVtZXJpY1ZhbGlkYXRpb24iLCJ2YWxpZGF0ZU51bWVyaWNDb2x1bW5zIiwiZGV0ZWN0RGF0ZVJhbmdlIiwibmFtZSIsInRvTG93ZXJDYXNlIiwidHJpbSIsInJlcGxhY2UiLCJ0YXJnZXROYW1lIiwiZmluZCIsImZvcm1hdHMiLCJTZXQiLCJmb3JFYWNoIiwicm93IiwiaW5kZXgiLCJkYXRlVmFsdWUiLCJkZXRlY3RlZEZvcm1hdCIsImRldGVjdERhdGVGb3JtYXQiLCJhZGQiLCJoYXNJc3N1ZXMiLCJzaXplIiwiQXJyYXkiLCJmcm9tIiwicmVjb21tZW5kZWRGb3JtYXQiLCJkYXRlU3RyaW5nIiwicGF0dGVybnMiLCJyZWdleCIsInBhdHRlcm4iLCJ0ZXN0IiwibnVtZXJpY0NvbHVtbnMiLCJnZXROdW1lcmljQ29sdW1ucyIsImNvbHVtbiIsIm5vbk51bWVyaWNWYWx1ZXMiLCJpdGVtIiwiaXNOYU4iLCJwYXJzZUZsb2F0IiwidG9TdHJpbmciLCJzYW1wbGVzIiwibnVtZXJpY1BhdHRlcm5zIiwibm9ybWFsaXplZCIsImluY2x1ZGVzIiwiZGF0ZXMiLCJCb29sZWFuIiwiZGF0ZVN0ciIsIkRhdGUiLCJkYXRlIiwiZ2V0VGltZSIsInNvcnQiLCJzdGFydCIsInRvSVNPU3RyaW5nIiwic3BsaXQiLCJlbmQiLCJ0b3RhbERheXMiLCJNYXRoIiwiY2VpbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lib/validators.ts\n"));

/***/ })

});